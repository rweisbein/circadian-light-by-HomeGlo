<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Circadian Light - Daily Rhythm</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<style>
:root {
  --bg: #000;
  --panel: #111;
  --panel2: #252525;
  --card: #1a1a1a;
  --text: #e2e8f0;
  --muted: #94a3b8;
  --muted2: #64748b;
  --line: #334155;
  --line2: #2c2c2c;
  --grid: #202020;
  --accent: #feac60;
  --accent-hover: #ffc078;
  --ascend: rgba(120, 190, 255, 0.32);
  --ascend-border: rgba(120, 185, 245, 0.5);
  --descend: rgba(255, 220, 100, 0.12);
  --descend-border: rgba(255, 230, 128, 0.45);
}
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
body { padding: 0; }
h1 { margin: 0 0 18px; font-size: 28px; font-weight: 600; }
h2 { margin: 0 0 12px; font-size: 1.1rem; font-weight: 600; }

.container { max-width: 1200px; margin: 0 auto; padding: 20px; }

/* Page Header */
.page-header {
  background: var(--panel);
  border-bottom: 1px solid var(--line);
  padding: 12px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  position: sticky;
  top: 0;
  z-index: 100;
}
.rhythm-name-input {
  font-size: 1.2rem;
  font-weight: 600;
  background: transparent;
  border: none;
  color: var(--text);
  padding: 4px 0;
  width: auto;
  min-width: 120px;
  max-width: 300px;
}
.rhythm-name-input:focus {
  outline: none;
}
.header-actions {
  display: flex;
  gap: 12px;
  align-items: center;
  margin-left: auto;
}

/* Rhythm group labels */
.rhythm-group-label {
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--muted);
  margin: 10px 0 2px;
}
.rhythm-group-label.bed {
  border-top: 1px solid var(--line);
  padding-top: 10px;
  margin-top: 12px;
}

/* Alt time day bubbles */
.day-bubbles {
  display: flex;
  gap: 4px;
  align-items: center;
}
.day-bubble {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  border: 1px solid var(--line);
  background: transparent;
  color: var(--muted);
  font-size: 0.65rem;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  padding: 0;
  line-height: 1;
}
.day-bubble:hover {
  border-color: var(--accent);
  color: var(--text);
}
.day-bubble.active {
  background: var(--accent);
  border-color: var(--accent);
  color: #000;
}

/* Alt time row collapse */
.alt-time-row {
  transition: opacity 0.2s, max-height 0.2s;
  overflow: hidden;
}
.alt-time-row.collapsed {
  max-height: 0;
  opacity: 0;
  margin: 0;
  padding: 0;
}
.alt-time-row:not(.collapsed) {
  max-height: 60px;
  opacity: 1;
}

/* Section Blocks (cards) */
.section-block {
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
}

/* Parameter Rows */
.param-row {
  display: grid;
  grid-template-columns: 140px 1fr 140px;
  align-items: center;
  gap: 10px;
  margin: 0 0 8px 0;
  max-width: 600px;
}
/* Ranges section needs more breathing room between dual-range rows */
#ranges-section .param-row { margin: 0 0 14px 0; }
/* Solar slider rows: use explicit sibling margin, zero out nested param-row margin */
.color-rule-slider-row .param-row { margin: 0; }
.color-rule-slider-row + .color-rule-slider-row { margin-top: 8px; }
/* Hidden control rows - kept for future "custom" preset */
.param-row.is-hidden {
  display: none;
  pointer-events: none;
}
.param-row label {
  font-size: 0.85rem;
  color: var(--muted);
  font-weight: 600;
  text-align: right;
}
.param-row .value {
  font-size: 0.9rem;
  font-weight: 600;
  color: var(--text);
  text-align: right;
}

/* Sliders */
input[type=range] {
  width: 100%;
  background: transparent;
  appearance: none;
  height: 20px;
  padding: 0;
  margin: 0;
}
input[type=range]:focus { outline: none; }
input[type=range]::-webkit-slider-runnable-track {
  height: 4px;
  background: rgba(255,255,255,0.3);
  border-radius: 2px;
}
input[type=range]::-moz-range-track {
  height: 4px;
  background: rgba(255,255,255,0.3);
  border-radius: 2px;
}
input[type=range]::-webkit-slider-thumb {
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid rgba(0,0,0,0.3);
  margin-top: -6px;
  cursor: pointer;
}
input[type=range]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid rgba(0,0,0,0.3);
  cursor: pointer;
}

/* Chart Section */
.chart-wrapper { position: relative; margin-bottom: 6px; }
#chart { height: 450px; }
.chart-toolbar {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 6px 0 8px;
}
.chart-date-control {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  max-width: 300px;
}
.chart-date-display {
  font-size: 0.8rem;
  color: var(--text);
  min-width: 50px;
  font-weight: 600;
}
.chart-date-control input[type=range] {
  flex: 1;
}
.modeled-conditions {
  display: flex;
  align-items: center;
  margin-left: auto;
}
.modeled-conditions select {
  padding: 4px 8px;
  border-radius: 6px;
  border: 1px solid var(--line);
  background: var(--panel2);
  color: var(--text);
  font-size: 0.75rem;
}
.time-nav-group {
  display: flex;
  gap: 4px;
  align-items: center;
}
.time-nav-btn {
  --btn-bg: rgba(255,255,255,0.06);
  --btn-text: #fff;
  --btn-fill: 0;
  --btn-fill-opacity: 0;
  background: var(--btn-bg);
  border: 1px solid rgba(255,255,255,0.2);
  color: var(--btn-text);
  font-size: 0.65rem;
  padding: 3px 10px;
  border-radius: 999px;
  cursor: pointer;
  white-space: nowrap;
  transition: all 0.15s;
  position: relative;
  overflow: hidden;
}
.time-nav-btn::after {
  content: '';
  position: absolute;
  inset: 2px;
  border-radius: 999px;
  background: rgba(255,255,255,0.18);
  opacity: var(--btn-fill-opacity);
  pointer-events: none;
}
.time-nav-btn:hover {
  border-color: rgba(255,255,255,0.4);
}

/* Time hover label - above x-axis, shows time with phase color */
.time-hover-label {
  position: absolute;
  bottom: 70px;
  padding: 4px 9px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.3);
  background: rgba(5,5,5,0.88);
  color: #fff;
  font-size: 0.75rem;
  font-weight: 600;
  pointer-events: none;
  transform: translateX(-50%);
  opacity: 0;
  transition: opacity 0.12s ease, left 0.08s ease;
  white-space: nowrap;
  box-shadow: 0 4px 10px rgba(0,0,0,0.35);
  z-index: 100;
}

/* Cursor callout - shows values at cursor position */
.graph-cursor-callout {
  position: absolute;
  bottom: 10px;
  padding: 4px 10px;
  border-radius: 8px;
  border: 1.5px solid #fdfdfd;
  background: rgba(10,10,10,0.85);
  color: #fff;
  font-size: 0.78rem;
  font-weight: 600;
  pointer-events: none;
  transform: translateX(-50%);
  opacity: 0;
  transition: opacity 0.12s ease, left 0.08s ease;
  white-space: nowrap;
  z-index: 100;
}

/* Cursor Controls */
.cursor-controls {
  display: flex;
  justify-content: center;
  gap: 16px;
  margin-top: 4px;
}
.cursor-controls.hidden { display: none; }
.cursor-btn-group {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 4px;
}
.cursor-btn-group-label {
  font-size: 0.65rem;
  color: var(--muted);
  letter-spacing: 0.05em;
  text-transform: uppercase;
}
.cursor-btn {
  --btn-bg: rgba(255,255,255,0.06);
  --btn-text: #fff;
  --btn-fill: 0;
  --btn-fill-opacity: 0;
  border: 1px solid rgba(255,255,255,0.25);
  background: var(--btn-bg);
  color: var(--btn-text);
  font-size: 0.95rem;
  font-weight: 600;
  padding: 4px 0;
  border-radius: 999px;
  width: 72px;
  cursor: pointer;
  transition: background 0.15s, border 0.15s, color 0.15s;
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}
.cursor-btn::after {
  content: '';
  position: absolute;
  inset: 2px;
  border-radius: 999px;
  background: rgba(255,255,255,0.18);
  opacity: var(--btn-fill-opacity);
  transition: opacity 0.2s ease;
  pointer-events: none;
}
.cursor-btn .btn-arrow {
  position: relative;
  z-index: 1;
  font-size: 1rem;
  line-height: 1;
}
.cursor-btn:hover {
  border-color: rgba(255,255,255,0.45);
}
.cursor-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
.cursor-btn.at-extreme {
  opacity: 0.6;
  cursor: not-allowed;
}
.cursor-btn.at-extreme .btn-arrow {
  opacity: 0.4;
}

/* Dual Range Slider - fixed from llm_access for proper left handle grabbing */
.dual-range {
  position: relative;
  display: flex;
  align-items: center;
  gap: 8px;
}
.dual-track {
  position: relative;
  flex: 1;
  height: 6px;
  background: rgba(255,255,255,0.3);
  border-radius: 3px;
}
.dual-track.color-track {
  height: 8px;
  border-radius: 4px;
}
.dual-fill {
  position: absolute;
  top: 0;
  height: 100%;
  background: var(--accent);
  border-radius: inherit;
  pointer-events: none;
}
.dual-mask {
  position: absolute;
  top: 0;
  height: 100%;
  background: rgba(0,0,0,0.7);
  pointer-events: none;
}
.dual-range input[type=range] {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  width: 100%;
  height: 20px;
  background: transparent;
  pointer-events: none;
  cursor: pointer;
}
.dual-range input[type=range]::-webkit-slider-runnable-track {
  background: transparent;
}
.dual-range input[type=range]::-moz-range-track {
  background: transparent;
}
.dual-range input[type=range]::-webkit-slider-thumb {
  pointer-events: auto;
}
.dual-range input[type=range]::-moz-range-thumb {
  pointer-events: auto;
}
.dual-range input[type=range].range-min {
  z-index: 4;
}
.dual-range input[type=range].range-max {
  z-index: 3;
}
.dual-chip {
  font-size: 0.85rem;
  color: var(--muted);
  min-width: 60px;
}
.dual-chip.right { text-align: left; }

/* Color Value Chip Button */
.color-value-chip {
  border: none;
  border-radius: 999px;
  padding: 6px 14px;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  min-width: 80px;
  text-align: center;
}
.color-value-chip:hover {
  filter: brightness(1.1);
}

/* Temporary ceiling/floor chip (shown when runtime differs from config) */
.temp-ceiling-chip {
  display: inline-block;
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 0.75rem;
  font-weight: 600;
  margin-left: 6px;
  background: rgba(255, 255, 255, 0.15);
  color: #ccc;
  border: 1px dashed rgba(255, 255, 255, 0.3);
}
.temp-ceiling-chip.hidden {
  display: none;
}

/* Temporary bounds row */
.temp-bounds-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0 4px 140px;
  font-size: 0.8rem;
}
.temp-bounds-row.hidden {
  display: none;
}
.temp-bounds-label {
  color: #888;
  font-style: italic;
}

/* Lock checkbox for range controls */
.lock-checkbox-wrap {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  margin-left: 8px;
  font-size: 0.75rem;
  color: #888;
  cursor: pointer;
  user-select: none;
}
.lock-checkbox-wrap input[type="checkbox"] {
  width: 14px;
  height: 14px;
  margin: 0;
  cursor: pointer;
  accent-color: #666;
}
.lock-checkbox-wrap .lock-icon {
  font-size: 0.8rem;
  opacity: 0.6;
}
.lock-checkbox-wrap input[type="checkbox"]:checked + .lock-icon {
  opacity: 1;
  color: #f5a623;
}

/* Color Slider Popup */
.color-controls-wrap {
  position: relative;
  display: inline-block;
}
.color-slider-popup {
  position: absolute;
  top: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: #101010;
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 10px;
  padding: 12px 14px;
  box-shadow: 0 12px 24px rgba(0,0,0,0.45);
  min-width: 280px;
  display: none;
  z-index: 50;
}
.color-slider-popup.is-open {
  display: block;
}
.color-slider-popup .dual-track {
  height: 10px;
  border-radius: 5px;
}
.color-slider-popup input[type=range] {
  height: 20px;
}

/* Color Rule Stack */
.color-rule-grid {
  display: flex;
  flex-direction: column;
  gap: 0;
  margin-top: 16px;
}
.color-rule-stack {
  padding: 10px 0 2px;
  border-top: 1px solid var(--line);
}
.color-rule-stack:first-child { border-top: none; padding-top: 0; }
.color-rule-stack-label {
  display: grid;
  grid-template-columns: 140px 1fr;
  align-items: center;
  gap: 10px;
  margin-bottom: 4px;
  max-width: 600px;
}
.color-rule-stack-label .color-rule-label-left {
  display: flex;
  align-items: center;
  gap: 8px;
}
.color-rule-stack-label .color-rule-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}
.color-rule-stack-label select {
  padding: 4px 8px;
  border-radius: 6px;
  border: 1px solid var(--line);
  background: var(--panel2);
  color: var(--text);
  font-size: 0.85rem;
}
.color-rule-label {
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--muted);
}
.info-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  position: relative;
  width: 16px;
  height: 16px;
  margin-left: 6px;
  font-size: 11px;
  font-weight: 600;
  color: rgba(255,255,255,0.5);
  border: 1px solid rgba(255,255,255,0.3);
  border-radius: 50%;
  cursor: pointer;
  vertical-align: middle;
  user-select: none;
  transition: all 0.15s ease;
}
.info-icon:hover {
  color: rgba(255,255,255,0.8);
  border-color: rgba(255,255,255,0.5);
}
.info-tooltip {
  display: none;
  position: absolute;
  top: 24px;
  left: 50%;
  transform: translateX(-50%);
  width: 280px;
  padding: 10px 12px;
  background: rgba(30,30,35,0.98);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  font-size: 0.85rem;
  font-weight: 400;
  line-height: 1.4;
  color: rgba(255,255,255,0.85);
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  z-index: 100;
}
.info-tooltip.is-open {
  display: block;
}
.color-rule-toggle input[type=checkbox] {
  width: 16px;
  height: 16px;
  accent-color: #7CFF72;
}
.color-rule-stack-body {
  display: block;
}
.color-rule-stack-body.is-disabled {
  opacity: 0.4;
  pointer-events: none;
}
.color-rule-slider-row {
  max-width: 600px;
}
.color-rule-slider-row.is-disabled {
  opacity: 0.35;
  pointer-events: none;
}
.param-row .offset-text {
  font-size: 0.85rem;
  color: var(--muted);
  text-align: left;
}


/* Buttons */
.btn {
  border: 1px solid rgba(255,255,255,0.3);
  background: rgba(255,255,255,0.1);
  color: #fff;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.9rem;
  transition: all 0.15s;
}
.btn:hover { background: rgba(255,255,255,0.15); }
.btn-primary {
  background: var(--accent);
  border-color: var(--accent);
}
.btn-primary:hover { filter: brightness(1.1); }

/* Collapsible Section */
.collapsible-section {
  margin-top: 16px;
  border-top: 1px solid var(--line);
  padding-top: 12px;
}
.collapsible-header {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  user-select: none;
  color: var(--muted);
  font-size: 0.85rem;
}
.collapsible-header:hover {
  color: var(--text);
}
.collapsible-arrow {
  transition: transform 0.2s ease;
  font-size: 0.7rem;
}
.collapsible-section.is-open .collapsible-arrow {
  transform: rotate(90deg);
}
.collapsible-content {
  display: none;
  padding-top: 12px;
}
.collapsible-section.is-open .collapsible-content {
  display: block;
}
.location-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}
.location-field {
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.location-field label {
  font-size: 0.8rem;
  color: var(--muted);
}
.location-field input {
  padding: 8px 10px;
  border-radius: 6px;
  border: 1px solid var(--line);
  background: var(--panel2);
  color: var(--text);
  font-size: 0.9rem;
}
.location-field input:disabled {
  opacity: 0.5;
}
.location-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  font-size: 0.85rem;
  color: var(--muted);
}
.location-toggle input[type=checkbox] {
  width: 14px;
  height: 14px;
}

/* Status Messages */
.success {
  color: #51cf66;
  font-size: 0.9rem;
  margin: 10px 0;
  padding: 12px 16px;
  background: rgba(81,207,102,0.15);
  border: 1px solid rgba(81,207,102,0.3);
  border-radius: 8px;
  font-weight: 600;
}
.error {
  color: #ff6b6b;
  font-size: 0.9rem;
  margin: 10px 0;
  padding: 12px 16px;
  background: rgba(255,107,107,0.15);
  border: 1px solid rgba(255,107,107,0.3);
  border-radius: 8px;
  font-weight: 600;
}

/* Live Design Controls */
.live-design-controls {
  display: flex;
  align-items: center;
  padding: 4px 0;
  margin-bottom: 12px;
  gap: 16px;
}
.live-design-controls label {
  font-size: 0.9rem;
  color: var(--muted);
  font-weight: 600;
}
.live-design-controls select {
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(255,255,255,0.06);
  color: #fff;
  min-width: 180px;
  font-size: 0.9rem;
}
.live-design-controls select:focus {
  outline: none;
  border-color: dodgerblue;
}
.live-design-link {
  font-size: 0.85rem;
  color: var(--muted);
  cursor: pointer;
  text-decoration: none;
  background: none;
  border: none;
  padding: 0;
  font-family: inherit;
}
.live-design-link:hover { color: var(--text); text-decoration: underline; }
.live-design-status {
  font-size: 0.8rem;
  color: var(--text);
  margin-left: 4px;
}
.live-design-status.active {
  color: var(--text);
}
@keyframes live-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}
.live-design-status.live-blink {
  animation: live-pulse 1.8s ease-in-out infinite;
}

/* Responsive */
@media (max-width: 640px) {
  .param-row { grid-template-columns: 1fr; gap: 4px; }
  .cursor-controls { flex-wrap: wrap; gap: 24px; }
  .solar-rule { grid-template-columns: 1fr; }
}

/* GloZone Management Styles */
.glozone-section {
  margin-bottom: 16px;
}
.glozone-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}
.glozone-header h2 {
  margin: 0;
  font-size: 1rem;
  color: var(--muted);
}
.glozone-tabs {
  display: flex;
  gap: 8px;
}
.glozone-tab {
  padding: 6px 14px;
  border: 1px solid var(--line);
  border-radius: 6px;
  background: var(--panel);
  color: var(--muted);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s;
}
.glozone-tab:hover {
  border-color: var(--accent);
  color: var(--text);
}
.glozone-tab.active {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
}
.glozone-content {
  display: none;
}
.glozone-content.active {
  display: block;
}

/* Zone/Preset Lists */
.glozone-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.glozone-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 14px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 8px;
  transition: border-color 0.15s;
}
.glozone-item:hover {
  border-color: var(--accent);
}
.glozone-item.selected {
  border-color: var(--accent);
  background: rgba(30, 144, 255, 0.1);
}
.glozone-item-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.glozone-item-name {
  font-weight: 600;
  font-size: 0.95rem;
}
.glozone-item-meta {
  font-size: 0.75rem;
  color: var(--muted2);
}
.glozone-item-actions {
  display: flex;
  gap: 6px;
}
.glozone-item-actions button {
  padding: 4px 10px;
  font-size: 0.75rem;
  border: 1px solid var(--line);
  border-radius: 4px;
  background: transparent;
  color: var(--muted);
  cursor: pointer;
  transition: all 0.15s;
}
.glozone-item-actions button:hover {
  border-color: var(--accent);
  color: var(--text);
}
.glozone-item-actions button.delete:hover {
  border-color: #ef4444;
  color: #ef4444;
}

/* Add New Button */
.glozone-add {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 10px;
  border: 1px dashed var(--line);
  border-radius: 8px;
  background: transparent;
  color: var(--muted);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s;
  width: 100%;
  margin-top: 8px;
}
.glozone-add:hover {
  border-color: var(--accent);
  color: var(--accent);
}

/* Zone Detail Panel */
.glozone-detail {
  margin-top: 12px;
  padding: 14px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 8px;
}
.glozone-detail-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}
.glozone-detail-title {
  font-weight: 600;
  font-size: 1rem;
}
.glozone-rename-btn {
  padding: 4px 10px;
  font-size: 0.75rem;
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 4px;
  color: var(--text);
  cursor: pointer;
  transition: all 0.2s;
}
.glozone-rename-btn:hover {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}
.glozone-detail-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 10px;
}
.glozone-detail-row label {
  font-size: 0.85rem;
  color: var(--muted);
  min-width: 80px;
}
.glozone-detail-row select,
.glozone-detail-row input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid var(--line);
  border-radius: 6px;
  background: var(--panel);
  color: var(--text);
  font-size: 0.9rem;
}

/* Area Assignment */
.area-assignment {
  margin-top: 12px;
}
.area-assignment-header {
  font-size: 0.85rem;
  color: var(--muted);
  margin-bottom: 8px;
}
.area-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}
.area-chip {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 10px;
  background: rgba(30, 144, 255, 0.15);
  border: 1px solid rgba(30, 144, 255, 0.3);
  border-radius: 12px;
  font-size: 0.8rem;
  color: var(--text);
}
.area-chip .remove {
  cursor: pointer;
  opacity: 0.6;
  font-size: 0.9rem;
}
.area-chip .remove:hover {
  opacity: 1;
  color: #ef4444;
}
.area-chip.unassigned {
  background: rgba(255, 255, 255, 0.05);
  border-color: var(--line);
  cursor: pointer;
}
.area-chip.unassigned:hover {
  border-color: var(--accent);
}
/* Drag and Drop */
.area-chip[draggable="true"] {
  cursor: grab;
}
.area-chip[draggable="true"]:active {
  cursor: grabbing;
}
.area-chip.dragging {
  opacity: 0.5;
}
.area-chips.drag-over {
  background: rgba(var(--accent-rgb, 99, 102, 241), 0.1);
  border-radius: 8px;
  outline: 2px dashed var(--accent);
  outline-offset: 2px;
}
.drop-zone {
  min-height: 40px;
  transition: all 0.2s;
}

/* Empty State */
.glozone-empty {
  text-align: center;
  padding: 20px;
  color: var(--muted2);
  font-size: 0.9rem;
}

/* Modal Styles */
.glozone-modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s, visibility 0.2s;
}
.glozone-modal-overlay.visible {
  opacity: 1;
  visibility: visible;
}
.glozone-modal {
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 20px;
  min-width: 320px;
  max-width: 90vw;
  max-height: 80vh;
  overflow-y: auto;
}
.glozone-modal h3 {
  margin: 0 0 16px;
  font-size: 1.1rem;
}
.glozone-modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 16px;
}
.glozone-modal-actions button {
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 0.9rem;
  cursor: pointer;
}
.glozone-modal-actions .btn-cancel {
  background: transparent;
  border: 1px solid var(--line);
  color: var(--muted);
}
.glozone-modal-actions .btn-confirm {
  background: var(--accent);
  border: 1px solid var(--accent);
  color: #fff;
}

/* Back-button page header */
.back-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border-radius: 8px;
  border: 1px solid var(--line);
  background: var(--card);
  color: var(--text);
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}
.back-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: var(--accent);
}
.back-btn svg {
  width: 20px;
  height: 20px;
}

/* Header action links */
.header-link { background: none; border: none; font-size: 0.8rem; cursor: pointer; padding: 0; }
.header-link-cancel { color: var(--muted); }
.header-link-cancel:hover { color: var(--text); }
.header-link-save { color: var(--accent); font-weight: 600; transition: color 0.6s ease; }
.header-link-save:hover { opacity: 0.8; }
.header-link-save.saved { color: var(--text); }
</style>
</head>
<body>
<!-- Page Header -->
<header class="page-header">
  <button class="back-btn" onclick="goBack()" title="Back">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="15 18 9 12 15 6"/>
    </svg>
  </button>
  <span style="color: var(--muted); font-size: 1.1rem; font-weight: 500;">Design:</span>
  <input type="text" class="rhythm-name-input" id="rhythm-name" value="Daily Rhythm 1" placeholder="Rhythm name">
  <div class="header-actions">
    <button class="header-link header-link-cancel" id="cancel-btn">Cancel</button>
    <button class="header-link header-link-save" id="save-config">Save</button>
  </div>
</header>

<div class="container">
  <div id="save-status"></div>

  <!-- Live Design Controls -->
  <div class="live-design-controls" id="live-design-controls">
    <label for="live-area-select">Live Design:</label>
    <select id="live-area-select">
      <option value="">Select Area</option>
    </select>
    <a href="#" class="live-design-link" id="live-design-toggle" style="display: none;">Pause</a>
    <span class="live-design-status" id="live-design-status"></span>
  </div>

  <div class="section-block">
    <h2>Sleep</h2>
    <div class="param-row" style="grid-template-columns: 140px 1fr;">
      <label>Pattern</label>
      <select id="activity-preset" style="background:var(--panel2);border:1px solid var(--line);border-radius:6px;color:var(--text);font-size:0.85rem;padding:6px 10px;max-width:180px;">
        <option value="young">Young Child</option>
        <option value="adult" selected>Adult</option>
        <option value="nightowl">Night Owl</option>
        <option value="duskbat">Dusk Bat</option>
        <option value="shiftearly">Shift Early</option>
        <option value="shiftlate">Shift Late</option>
      </select>
    </div>
    <div class="rhythm-group-label">Wake</div>
    <div class="param-row">
      <label>Time</label>
      <input type="range" id="wake-time" min="0" max="24" step="0.25" value="7">
      <span class="dual-chip right" id="wake-time-display">7:00a</span>
    </div>
    <div class="param-row">
      <label>Alt days</label>
      <div class="day-bubbles" id="wake-alt-days">
        <button class="day-bubble" data-day="0">Mo</button>
        <button class="day-bubble" data-day="1">Tu</button>
        <button class="day-bubble" data-day="2">We</button>
        <button class="day-bubble" data-day="3">Th</button>
        <button class="day-bubble" data-day="4">Fr</button>
        <button class="day-bubble" data-day="5">Sa</button>
        <button class="day-bubble" data-day="6">Su</button>
      </div>
    </div>
    <div class="param-row alt-time-row collapsed" id="wake-alt-time-row">
      <label>Alt time</label>
      <input type="range" id="wake-alt-time" min="0" max="24" step="0.25" value="9">
      <span class="dual-chip right" id="wake-alt-time-display">9:00a</span>
    </div>
    <div class="param-row">
      <label>At wake</label>
      <input type="range" id="wake-brightness" min="10" max="90" step="5" value="50">
      <span class="dual-chip right" id="wake-brightness-display">50%</span>
    </div>
    <div class="param-row">
      <label>Speed</label>
      <input type="range" id="wake-speed" min="1" max="10" step="1" value="6">
      <span class="dual-chip right" id="wake-speed-display">Crisp (6)</span>
    </div>
    <div class="rhythm-group-label bed">Bed</div>
    <div class="param-row">
      <label>Time</label>
      <input type="range" id="bed-time" min="0" max="36" step="0.25" value="21">
      <span class="dual-chip right" id="bed-time-display">9:00p</span>
    </div>
    <div class="param-row">
      <label>Alt days</label>
      <div class="day-bubbles" id="bed-alt-days">
        <button class="day-bubble" data-day="0">Mo</button>
        <button class="day-bubble" data-day="1">Tu</button>
        <button class="day-bubble" data-day="2">We</button>
        <button class="day-bubble" data-day="3">Th</button>
        <button class="day-bubble" data-day="4">Fr</button>
        <button class="day-bubble" data-day="5">Sa</button>
        <button class="day-bubble" data-day="6">Su</button>
      </div>
    </div>
    <div class="param-row alt-time-row collapsed" id="bed-alt-time-row">
      <label>Alt time</label>
      <input type="range" id="bed-alt-time" min="0" max="36" step="0.25" value="23">
      <span class="dual-chip right" id="bed-alt-time-display">11:00p</span>
    </div>
    <div class="param-row">
      <label>At bed</label>
      <input type="range" id="bed-brightness" min="10" max="90" step="5" value="50">
      <span class="dual-chip right" id="bed-brightness-display">50%</span>
    </div>
    <div class="param-row">
      <label>Speed</label>
      <input type="range" id="bed-speed" min="1" max="10" step="1" value="4">
      <span class="dual-chip right" id="bed-speed-display">Smooth (4)</span>
    </div>
    <!-- Hidden fields for ascend/descend (set by sleep pattern) -->
    <input type="range" id="ascend-start" min="0" max="24" step="0.5" value="3" style="display:none">
    <input type="range" id="descend-start" min="0" max="36" step="0.5" value="12" style="display:none">
  </div>

  <!-- Chart -->
  <div class="section-block">
    <div class="chart-toolbar">
      <div class="chart-date-control">
        <span class="chart-date-display" id="chart-date-display">Today</span>
        <input type="range" id="chart-date-slider" min="0" max="364" value="0">
      </div>
      <div class="modeled-conditions">
        <select id="modeled-conditions" title="Preview how weather affects the color curve">
          <option value="1.0">Clear sun</option>
          <option value="0.6">Partly cloudy</option>
          <option value="0.3">Overcast</option>
          <option value="0.15">Heavy overcast</option>
          <option value="0">Dark / indoor</option>
        </select>
      </div>
      <div class="time-nav-group">
        <button class="time-nav-btn" id="cursor-time-minus" title="-5 minutes">-5 min</button>
        <button class="time-nav-btn" id="cursor-time-now" title="Jump to current time">Now</button>
        <button class="time-nav-btn" id="cursor-time-plus" title="+5 minutes">+5 min</button>
      </div>
    </div>
    <div class="chart-wrapper">
      <div id="chart"></div>
      <div class="time-hover-label" id="time-hover-label"></div>
      <div class="graph-cursor-callout" id="cursor-callout"></div>
    </div>

    <!-- Cursor Controls -->
    <div class="cursor-controls hidden" id="cursor-controls">
      <div class="cursor-btn-group">
        <span class="cursor-btn-group-label">Step</span>
        <button class="cursor-btn" id="cursor-step-up" data-mode="combo" title="Step Up"><span class="btn-arrow">↑</span></button>
        <button class="cursor-btn" id="cursor-step-down" data-mode="combo" title="Step Down"><span class="btn-arrow">↓</span></button>
      </div>
      <div class="cursor-btn-group">
        <span class="cursor-btn-group-label">Bright</span>
        <button class="cursor-btn" id="cursor-bright-up" data-mode="brightness" title="Brighten"><span class="btn-arrow">↑</span></button>
        <button class="cursor-btn" id="cursor-bright-down" data-mode="brightness" title="Dim"><span class="btn-arrow">↓</span></button>
      </div>
      <div class="cursor-btn-group">
        <span class="cursor-btn-group-label">Color</span>
        <button class="cursor-btn" id="cursor-color-up" data-mode="color" title="Cooler"><span class="btn-arrow">↑</span></button>
        <button class="cursor-btn" id="cursor-color-down" data-mode="color" title="Warmer"><span class="btn-arrow">↓</span></button>
      </div>
      <div class="cursor-btn-group">
        <span class="cursor-btn-group-label">&nbsp;</span>
        <button class="cursor-btn" id="cursor-reset" title="Reset to curve"><span class="btn-arrow" style="font-size:0.75rem">Reset</span></button>
      </div>
    </div>
    <div style="display:flex;justify-content:flex-end;margin-top:8px;">
      <label style="display:flex;align-items:center;gap:6px;font-size:0.75rem;color:var(--muted);cursor:pointer;user-select:none;">
        <input type="checkbox" id="simple-mode" checked style="width:14px;height:14px;accent-color:var(--muted2);">
        Simple
      </label>
    </div>
    <!-- Hidden increment inputs (synced from master Increments slider) -->
    <input type="number" id="step-increments" style="display:none" value="10">
    <input type="number" id="brightness-increments" style="display:none" value="10">
    <input type="number" id="color-increments" style="display:none" value="10">

  </div>

  <!-- Ranges -->
  <div class="section-block" id="ranges-section">
    <h2>Ranges</h2>

    <div class="param-row">
      <label>Color temp.</label>
      <div class="dual-range">
        <div class="dual-track color-track" id="color-track">
          <div class="dual-mask" id="color-mask-left"></div>
          <div class="dual-mask" id="color-mask-right"></div>
        </div>
        <input type="range" id="color-min" class="range-min" min="500" max="6500" step="100" value="500">
        <input type="range" id="color-max" class="range-max" min="500" max="6500" step="100" value="6500">
      </div>
      <span class="dual-chip" id="color-range-display">500 – 6500 K</span>
    </div>

    <div class="param-row">
      <label>Brightness</label>
      <div class="dual-range">
        <div class="dual-track" id="brightness-track" style="background:linear-gradient(to right,#111,#fff);">
          <div class="dual-mask" id="brightness-mask-left"></div>
          <div class="dual-mask" id="brightness-mask-right"></div>
        </div>
        <input type="range" id="brightness-min" class="range-min" min="1" max="100" step="1" value="1">
        <input type="range" id="brightness-max" class="range-max" min="1" max="100" step="1" value="100">
      </div>
      <span class="dual-chip" id="brightness-range-display">1 – 100%</span>
    </div>

    <div class="param-row">
      <label>Increments</label>
      <input type="range" id="step-count" min="1" max="50" step="1" value="10">
      <span class="dual-chip right" id="step-count-display">10 steps</span>
    </div>

  </div>

  <!-- Solar Adjustments -->
  <div class="section-block">
    <h2>Solar Adjustments</h2>
    <div class="color-rule-grid">
      <div class="color-rule-stack" data-color-row="night">
        <div class="color-rule-stack-label">
          <div class="color-rule-label-left">
            <div class="color-rule-toggle"><input type="checkbox" id="warm-night-enabled"></div>
            <label class="color-rule-label">Warm night<span class="info-icon" data-tooltip="warm-night-info">i<span class="info-tooltip" id="warm-night-info">Caps color temperature when sun isn't up; if your curve is cool (high K) between sunset and sunrise, this warms it.</span></span></label>
          </div>
          <div class="color-rule-controls">
            <select id="warm-night-mode">
              <option value="all">all night</option>
              <option value="sunrise">before sunrise</option>
              <option value="sunset">after sunset</option>
            </select>
            <div class="color-controls-wrap">
              <button type="button" class="color-value-chip" id="warm-night-target-chip">2700 K</button>
              <div class="color-slider-popup" id="warm-night-popup">
                <div class="dual-range">
                  <div class="dual-track color-track" id="warm-night-track"></div>
                  <input type="range" id="warm-night-target" class="range-min" min="500" max="6500" step="100" value="2700">
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="color-rule-stack-body" id="warm-night-body">
          <div class="color-rule-slider-row" data-rule-window="sunset">
            <div class="param-row">
              <label>Start</label>
              <input type="range" id="warm-night-start" min="-180" max="180" step="30" value="-60">
              <span class="offset-text" id="warm-night-start-text">1 hr before sunset</span>
            </div>
          </div>
          <div class="color-rule-slider-row" data-rule-window="sunrise">
            <div class="param-row">
              <label>End</label>
              <input type="range" id="warm-night-end" min="-180" max="180" step="30" value="60">
              <span class="offset-text" id="warm-night-end-text">1 hr after sunrise</span>
            </div>
          </div>
          <div class="color-rule-slider-row" data-rule-window="any">
            <div class="param-row">
              <label>Fade</label>
              <input type="range" id="warm-night-fade" min="0" max="300" step="30" value="60">
              <span class="offset-text" id="warm-night-fade-text">1 hr</span>
            </div>
          </div>
        </div>
      </div>

      <div class="color-rule-stack" data-color-row="daylight">
        <div class="color-rule-stack-label">
          <div class="color-rule-label-left">
            <label class="color-rule-label">Daylight blend<span class="info-icon" data-tooltip="daylight-info">i<span class="info-tooltip" id="daylight-info">Pushes color toward a target based on outdoor brightness. Set to 0 K to disable. Higher color gain = stronger push.</span></span></label>
          </div>
          <div class="color-rule-controls">
            <div class="color-controls-wrap">
              <button type="button" class="color-value-chip" id="daylight-cct-chip">5500 K</button>
              <div class="color-slider-popup" id="daylight-cct-popup">
                <div class="dual-range">
                  <div class="dual-track color-track" id="daylight-cct-track"></div>
                  <input type="range" id="daylight-cct" class="range-min" min="0" max="6500" step="100" value="5500">
                </div>
              </div>
            </div>
          </div>
        </div>
        <div class="color-rule-stack-body" id="daylight-body">
          <div class="param-row">
            <label>Color sensitivity</label>
            <input type="range" id="color-sensitivity" min="0" max="9" step="1" value="6">
            <span class="offset-text" id="color-sensitivity-text">Strong</span>
          </div>
          <div class="param-row">
            <label>Brightness sensitivity</label>
            <input type="range" id="brightness-sensitivity" min="0" max="9" step="1" value="9">
            <span class="offset-text" id="brightness-sensitivity-text">Maximum</span>
          </div>
          <div class="param-row">
            <label>Daylight fade</label>
            <input type="range" id="daylight-fade" min="0" max="180" step="15" value="60">
            <span class="offset-text" id="daylight-fade-text">1 hr</span>
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script src="./shared.js"></script>
<script>
// ============================================================
// Circadian Light Designer - Ascend/Descend Model
// ============================================================

const GRAPH_Y_MAX = 125;
const SPEED_LABELS = ['', 'Calm', 'Gentle', 'Soft', 'Smooth', 'Balanced', 'Crisp', 'Fast', 'Snappy', 'Quick', 'Sharp'];
const SPEED_TO_SLOPE = [0, 0.4, 0.6, 0.8, 1.0, 1.3, 1.7, 2.3, 3.0, 4.0, 5.5];

// Colors matching llm_access.html
const ASCEND_COLORS = {
  shade: 'rgba(120,190,255,0.35)',
  text: '#5cb3ff',
  boundary: 'rgba(120,185,245,0.55)',
  axis: '#5cb3ff',
  hoverBg: '#7fc7ff'
};
const DESCEND_COLORS = {
  shade: 'rgba(255,220,100,0.12)',
  text: '#ffe680',
  boundary: 'rgba(255,230,128,0.85)',
  axis: 'rgba(255,230,128,0.7)',
  hoverBg: '#ffe680'
};

// Activity Presets
// warm_night_enabled: true for young, adult, nightowl
// daylight_cct: 5500 for all (intensity-based daylight blend)
const ACTIVITY_PRESETS = {
  young: { wake_time: 6.0, bed_time: 18.0, ascend_start: 0.0, descend_start: 12.0, warm_night_enabled: true, daylight_cct: 5500 },
  adult: { wake_time: 7.0, bed_time: 21.0, ascend_start: 3.0, descend_start: 12.0, warm_night_enabled: true, daylight_cct: 5500 },
  nightowl: { wake_time: 10.0, bed_time: 2.0, ascend_start: 8.0, descend_start: 16.0, warm_night_enabled: true, daylight_cct: 5500 },
  duskbat: { wake_time: 14.0, bed_time: 6.0, ascend_start: 12.0, descend_start: 20.0, warm_night_enabled: false, daylight_cct: 5500 },
  shiftearly: { wake_time: 18.0, bed_time: 10.0, ascend_start: 16.0, descend_start: 0.0, warm_night_enabled: false, daylight_cct: 5500 },
  shiftlate: { wake_time: 22.0, bed_time: 14.0, ascend_start: 20.0, descend_start: 4.0, warm_night_enabled: false, daylight_cct: 5500 }
};

const SENSITIVITY_STEPS = [
  { label: "None",        multiplier: 0.00 },
  { label: "Minimal",     multiplier: 0.15 },
  { label: "Low",         multiplier: 0.35 },
  { label: "Slight",      multiplier: 0.55 },
  { label: "Moderate",    multiplier: 0.80 },
  { label: "Noticeable",  multiplier: 1.10 },
  { label: "Strong",      multiplier: 1.50 },
  { label: "High",        multiplier: 2.00 },
  { label: "Very high",   multiplier: 3.00 },
  { label: "Maximum",     multiplier: 5.00 },
];

function findClosestSensitivityStep(value) {
  let closest = 0, minDist = Infinity;
  for (let i = 0; i < SENSITIVITY_STEPS.length; i++) {
    const dist = Math.abs(SENSITIVITY_STEPS[i].multiplier - value);
    if (dist < minDist) { minDist = dist; closest = i; }
  }
  return closest;
}

// Simple mode - hides advanced chart elements
let simpleMode = true;

// State
let config = {
  ascend_start: 3.0,
  descend_start: 12.0,
  wake_time: 7.0,
  bed_time: 21.0,
  wake_speed: 6,
  bed_speed: 4,
  min_color_temp: 500,
  max_color_temp: 6500,
  min_brightness: 1,
  max_brightness: 100,
  max_dim_steps: 10,
  step_increments: null,        // defaults to max_dim_steps
  brightness_increments: null,  // defaults to max_dim_steps
  color_increments: null,       // defaults to max_dim_steps
  warm_night_enabled: true,  // default matches adult preset
  warm_night_mode: 'all',
  warm_night_target: 2700,
  warm_night_start: -60,  // minutes offset from sunset (negative = before)
  warm_night_end: 60,     // minutes offset from sunrise (positive = after)
  warm_night_fade: 60,    // fade duration in minutes
  daylight_cct: 5500,
  daylight_fade: 60,
  color_sensitivity: 1.50,
  brightness_sensitivity: 5.0,
  activity_preset: 'adult',
  use_ha_location: true,
  latitude: 35.0,
  longitude: -78.6,
  timezone: 'US/Eastern'
};

// Current sun times (cached for solar rules)
let sunTimes = { sunrise: 6, sunset: 18, solarNoon: 12, solarMid: 0 };

// Runtime state for current phase (resets at phase transitions)
// Only one phase is active at a time, so we only need one midpoint per axis
let runtimeState = {
  enabled: false,              // Whether circadian lighting is active
  frozen: false,               // Whether to freeze at current position (stop following time)
  brightness_mid: null,        // Current phase's brightness midpoint (falls back to wake_time or bed_time)
  color_mid: null,             // Current phase's color midpoint (falls back to wake_time or bed_time)
  color_override: null,        // Solar rule target offset (Kelvin) from color stepping
};

// Cursor state
let cursorHour = null;
let graphData = null;
let lastCursorPhase = null;  // Track phase for reset on transition

// Live Design state
let liveDesignEnabled = false;
let liveDesignAreaId = null;
let liveDesignFirstApply = false;  // Use longer transition on first apply after entering

// ============================================================
// Solar Calculation Helpers
// ============================================================

const rad = d => d * Math.PI / 180;

function wrap24(x) {
  return ((x % 24) + 24) % 24;
}

// Check if hour is within a time window (handles midnight wrap-around)
function isInTimeWindow(hour, windowStart, windowEnd) {
  hour = wrap24(hour);
  windowStart = wrap24(windowStart);
  windowEnd = wrap24(windowEnd);

  if (windowStart > windowEnd) {
    // Wraps around midnight
    return hour >= windowStart || hour <= windowEnd;
  } else {
    return hour >= windowStart && hour <= windowEnd;
  }
}

// Get warm_night window boundaries based on current config and sun times
function getWarmNightWindow() {
  if (!config || !sunTimes || !config.warm_night_enabled) return null;

  const { sunrise, sunset } = sunTimes;
  const solarMid = wrap24(sunTimes.solarMid);
  const startOffsetHrs = config.warm_night_start / 60;
  const endOffsetHrs = config.warm_night_end / 60;
  const mode = config.warm_night_mode;

  let windowStart, windowEnd;
  if (mode === 'sunrise') {
    windowStart = solarMid;
    windowEnd = wrap24(sunrise + endOffsetHrs);
  } else if (mode === 'sunset') {
    windowStart = wrap24(sunset + startOffsetHrs);
    windowEnd = solarMid;
  } else {
    windowStart = wrap24(sunset + startOffsetHrs);
    windowEnd = wrap24(sunrise + endOffsetHrs);
  }

  return { windowStart, windowEnd };
}

// ============================================================
// Single-Point Value Calculation (source of truth)
// ============================================================

/**
 * Check if hour is in window and calculate fade weight.
 */
function getWindowWeight(hour, windowStart, windowEnd, fadeHrs) {
  const h = wrap24(hour);
  let inWindow = false;
  let distFromStart = 0;
  let distToEnd = 0;

  if (windowStart > windowEnd) {
    // Wraps around midnight
    inWindow = h >= windowStart || h <= windowEnd;
    if (inWindow) {
      distFromStart = h >= windowStart ? (h - windowStart) : (h + 24 - windowStart);
      distToEnd = h <= windowEnd ? (windowEnd - h) : (windowEnd + 24 - h);
    }
  } else {
    // Normal range
    inWindow = h >= windowStart && h <= windowEnd;
    if (inWindow) {
      distFromStart = h - windowStart;
      distToEnd = windowEnd - h;
    }
  }

  if (!inWindow) {
    return { inWindow: false, weight: 0 };
  }

  // Calculate fade weight
  let weight = 1;
  if (fadeHrs > 0.01) {
    if (distFromStart < fadeHrs) {
      weight = Math.min(weight, distFromStart / fadeHrs);
    }
    if (distToEnd < fadeHrs) {
      weight = Math.min(weight, distToEnd / fadeHrs);
    }
  }

  return { inWindow: true, weight };
}

/**
 * Apply warm_night and daylight blend solar rules to a single CCT value at a given hour.
 */
function applySolarRuleAtHour(baseCCT, hour) {
  if (!sunTimes) return baseCCT;

  let cct = baseCCT;
  const { sunrise, sunset, solarMid } = sunTimes;

  // Warm night — ceiling
  if (config.warm_night_enabled) {
    let warmTarget = config.warm_night_target;
    if (runtimeState.color_override && runtimeState.color_override > 0) {
      warmTarget += runtimeState.color_override;
    }

    if (cct > warmTarget) {
      const fadeHrs = config.warm_night_fade / 60;
      const startOffsetHrs = config.warm_night_start / 60;
      const endOffsetHrs = config.warm_night_end / 60;
      const mode = config.warm_night_mode;

      let ws, we;
      if (mode === 'sunrise') {
        ws = wrap24(solarMid);
        we = wrap24(sunrise + endOffsetHrs);
      } else if (mode === 'sunset') {
        ws = wrap24(sunset + startOffsetHrs);
        we = wrap24(solarMid);
      } else {
        ws = wrap24(sunset + startOffsetHrs);
        we = wrap24(sunrise + endOffsetHrs);
      }

      const { inWindow, weight } = getWindowWeight(hour, ws, we, fadeHrs);
      if (inWindow && weight > 0) {
        cct = cct + (warmTarget - cct) * weight;
      }
    }
  }

  // Daylight color blend (intensity-based)
  // Condition multiplier from dropdown modulates clear-sky lux at this hour's sun elevation
  const conditionMult = parseFloat(document.getElementById('modeled-conditions')?.value ?? '1.0');
  const dateStr = getSelectedDateISO();
  const elev = getSunElevationAtHour(hour, config.latitude, config.longitude, dateStr);
  const outdoorNorm = elevationToOutdoorNorm(elev, conditionMult);
  const daylightCct = config.daylight_cct || 0;
  const colorSensitivity = config.color_sensitivity ?? 1.50;
  if (daylightCct > 0 && outdoorNorm > 0) {
    let blend = Math.min(1.0, outdoorNorm * colorSensitivity);
    // Apply daylight fade: ramp blend over daylight_fade minutes after sunrise / before sunset
    if (config.daylight_fade > 0) {
      const fadeHrs = config.daylight_fade / 60;
      const h = ((hour % 24) + 24) % 24;
      const distSunrise = ((h - sunrise) % 24 + 24) % 24;
      const distSunset = ((sunset - h) % 24 + 24) % 24;
      let tw = 1.0;
      if (distSunrise < fadeHrs) tw = Math.min(tw, distSunrise / fadeHrs);
      if (distSunset < fadeHrs) tw = Math.min(tw, distSunset / fadeHrs);
      blend *= tw;
    }
    let daylightTarget = daylightCct;
    if (runtimeState.color_override && runtimeState.color_override < 0) {
      daylightTarget += runtimeState.color_override;
    }
    if (daylightTarget > cct) {
      cct += (daylightTarget - cct) * blend;
    }
  }

  return cct;
}

/**
 * Get Python weekday (0=Mon..6=Sun) for the chart date slider.
 */
function getChartWeekday() {
  const slider = document.getElementById('chart-date-slider');
  const dayOffset = slider ? parseInt(slider.value) : 0;
  const target = new Date(new Date().getFullYear(), 0, 1 + dayOffset);
  return (target.getDay() + 6) % 7;  // JS getDay (0=Sun) → Python weekday (0=Mon)
}

/**
 * Resolve effective wake/bed times based on alt days and overrides (JS mirror of brain.py).
 */
function resolveEffectiveTiming(hour, weekday) {
  let wake = config.wake_time;
  let bed = config.bed_time;

  // Alt wake
  if (config.wake_alt_time != null && (config.wake_alt_days || []).includes(weekday)) {
    wake = config.wake_alt_time;
  }

  // Alt bed: post-midnight pre-ascend uses yesterday's weekday
  let bedWeekday = weekday;
  if (hour < config.ascend_start) {
    bedWeekday = (weekday + 6) % 7;  // yesterday
  }
  if (config.bed_alt_time != null && (config.bed_alt_days || []).includes(bedWeekday)) {
    bed = config.bed_alt_time;
  }

  return { wake, bed };
}

/**
 * JS mirror of brain.py inverse_midpoint.
 */
function inverseMidpoint(x, targetValue, slope, y0, y1) {
  const epsilon = 0.001;
  const clamped = Math.max(y0 + epsilon, Math.min(y1 - epsilon, targetValue));
  const ratio = (clamped - y0) / (y1 - y0);
  try {
    return x + Math.log((1 - ratio) / ratio) / slope;
  } catch (e) {
    return x;
  }
}

/**
 * JS mirror of brain.py compute_shifted_midpoint.
 */
function computeShiftedMidpoint(targetTimeH48, brightnessPct, slope, bMinNorm, bMaxNorm) {
  if (brightnessPct === 50) return targetTimeH48;
  const targetNorm = bMinNorm + (bMaxNorm - bMinNorm) * (brightnessPct / 100);
  return inverseMidpoint(targetTimeH48, targetNorm, slope, bMinNorm, bMaxNorm);
}

/**
 * Calculate brightness, CCT, and phase at a specific hour.
 * Single source of truth for curve + solar rule calculations.
 */
function getValuesAtTime(hour) {
  // Phase detection
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  const h48 = hour < tAscend ? hour + 24 : hour;
  const inAscend = h48 >= tAscend && h48 < tDescend;
  const phase = inAscend ? 'Ascend' : 'Descend';

  // Slopes - clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];

  // Config bounds (only use these, no runtime overrides)
  const bMin = config.min_brightness / 100;
  const bMax = config.max_brightness / 100;
  const cLow = config.min_color_temp;
  const cHigh = config.max_color_temp;

  // Resolve effective timing for chart weekday
  const weekday = getChartWeekday();
  const timing = resolveEffectiveTiming(hour, weekday);

  // Brightness midpoint (runtimeState applies to current phase only)
  let wakeMid = inAscend ? (runtimeState.brightness_mid ?? timing.wake) : timing.wake;
  let bedMid = !inAscend ? (runtimeState.brightness_mid ?? timing.bed) : timing.bed;

  // Apply brightness target shift when not stepping (no runtimeState.brightness_mid)
  if (runtimeState.brightness_mid == null) {
    const slope = inAscend ? kAscend : -kDescend;
    const brightPct = inAscend ? (config.wake_brightness || 50) : (config.bed_brightness || 50);
    if (brightPct !== 50) {
      if (inAscend) {
        let mid48 = wakeMid;
        while (mid48 < tAscend) mid48 += 24;
        while (mid48 > tDescend) mid48 -= 24;
        const shifted = computeShiftedMidpoint(mid48, brightPct, slope, bMin, bMax);
        wakeMid = shifted % 24;
      } else {
        let mid48 = bedMid;
        while (mid48 < tDescend) mid48 += 24;
        while (mid48 > tDescend + 24) mid48 -= 24;
        const shifted = computeShiftedMidpoint(mid48, brightPct, slope, bMin, bMax);
        bedMid = shifted % 24;
      }
    }
  }

  let wakeMid48 = wakeMid;
  while (wakeMid48 < tAscend) wakeMid48 += 24;
  while (wakeMid48 > tDescend) wakeMid48 -= 24;

  let bedMid48 = bedMid;
  while (bedMid48 < tDescend) bedMid48 += 24;
  while (bedMid48 > tDescend + 24) bedMid48 -= 24;

  // Calculate brightness
  let brightnessNorm;
  if (inAscend) {
    brightnessNorm = logistic(h48, wakeMid48, kAscend, bMin, bMax);
  } else {
    const hDescend48 = h48 < tDescend ? h48 + 24 : h48;
    brightnessNorm = logistic(hDescend48, bedMid48, -kDescend, bMin, bMax);
  }
  const brightness = brightnessNorm * 100;

  // Color midpoint — uses resolved timing but NO brightness target shift
  const colorWakeMid = inAscend ? (runtimeState.color_mid ?? timing.wake) : timing.wake;
  const colorBedMid = !inAscend ? (runtimeState.color_mid ?? timing.bed) : timing.bed;

  let colorWakeMid48 = colorWakeMid;
  while (colorWakeMid48 < tAscend) colorWakeMid48 += 24;
  while (colorWakeMid48 > tDescend) colorWakeMid48 -= 24;

  let colorBedMid48 = colorBedMid;
  while (colorBedMid48 < tDescend) colorBedMid48 += 24;
  while (colorBedMid48 > tDescend + 24) colorBedMid48 -= 24;

  // Calculate base CCT
  let colorNorm;
  if (inAscend) {
    colorNorm = logistic(h48, colorWakeMid48, kAscend, 0, 1);
  } else {
    const hDescend48 = h48 < tDescend ? h48 + 24 : h48;
    colorNorm = logistic(hDescend48, colorBedMid48, -kDescend, 0, 1);
  }
  colorNorm = Math.max(0, Math.min(1, colorNorm));
  let cct = cLow + (cHigh - cLow) * colorNorm;

  // Apply solar rules
  cct = applySolarRuleAtHour(cct, hour);

  return { brightness, cct, phase };
}

/**
 * Calculate what step up/down would produce.
 * Simulates stepCursor logic to preview button results.
 * @param {Object} cursorPoint - Current cursor point with x (hour), y (brightness), cct
 * @returns {Object} { upBri, upCCT, downBri, downCCT }
 */
function getStepPreview(cursorPoint) {
  // Defensive check
  if (!cursorPoint || !config) {
    return { upBri: 100, upCCT: 4000, downBri: 10, downCCT: 2700 };
  }

  const hour = cursorPoint.x;
  const currentBri = cursorPoint.y;
  const currentCCT = cursorPoint.cct;

  // Step Up/Down uses step_increments
  const steps = config.step_increments ?? config.max_dim_steps ?? 10;

  // Config bounds (only use these, no runtime overrides)
  const bMin = config.min_brightness;
  const bMax = config.max_brightness;
  const cMin = config.min_color_temp;
  const cMax = config.max_color_temp;

  // Step size based on config range
  const briStep = (bMax - bMin) / steps;

  // Phase detection
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;
  const h48 = hour < tAscend ? hour + 24 : hour;
  const inAscend = h48 >= tAscend && h48 < tDescend;

  // Clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];
  const slope = inAscend ? kAscend : -kDescend;

  // Helper: calculate CCT for a target brightness (simulates curve traversal)
  function getStepResultCCT(targetBri) {
    // Within bounds - traverse the diverged curve
    const briMid = runtimeState.brightness_mid ?? (inAscend ? config.wake_time : config.bed_time);
    const colorMid = runtimeState.color_mid ?? (inAscend ? config.wake_time : config.bed_time);

    // Lift midpoints into 48h space
    let briMid48 = briMid;
    let colorMid48 = colorMid;
    if (inAscend) {
      while (briMid48 < tAscend) briMid48 += 24;
      while (colorMid48 < tAscend) colorMid48 += 24;
    } else {
      while (briMid48 < tDescend) briMid48 += 24;
      while (colorMid48 < tDescend) colorMid48 += 24;
    }

    // Calculate virtual time T' where brightness = targetBri
    const bMinNorm = bMin / 100;
    const bMaxNorm = bMax / 100;
    const clampedBri = Math.max(bMin + 0.1, Math.min(bMax - 0.1, targetBri));
    const targetBriNorm = clampedBri / 100;
    const briRatio = (targetBriNorm - bMinNorm) / (bMaxNorm - bMinNorm);

    // Avoid extreme virtual time values near bounds
    // The 0.99/0.01 threshold catches edge cases where virtual time would
    // extrapolate far beyond the curve, producing bogus CCT values
    if (briRatio <= 0.01 || briRatio >= 0.99) {
      return currentCCT;
    }

    const virtualTime = briMid48 + Math.log(briRatio / (1 - briRatio)) / slope;

    // Get color at virtual time from color curve (base curve)
    let colorNorm;
    if (inAscend) {
      colorNorm = logistic(virtualTime, colorMid48, slope, 0, 1);
    } else {
      const vtDescend = virtualTime < tDescend ? virtualTime + 24 : virtualTime;
      colorNorm = logistic(vtDescend, colorMid48, slope, 0, 1);
    }
    colorNorm = Math.max(0, Math.min(1, colorNorm));
    const baseCCT = cMin + (cMax - cMin) * colorNorm;

    // Clamp to config bounds
    return Math.max(cMin, Math.min(cMax, baseCCT));
  }

  // Check if at config bounds
  const atMaxBri = currentBri >= bMax - 0.5;
  const atMinBri = currentBri <= bMin + 0.5;

  // Calculate step up preview
  let upBri, upCCT;
  if (atMaxBri) {
    // At config bound, can't go further
    upBri = currentBri;
    upCCT = currentCCT;
  } else {
    upBri = Math.min(bMax, currentBri + briStep);
    upCCT = getStepResultCCT(upBri);
  }

  // Calculate step down preview
  let downBri, downCCT;
  if (atMinBri) {
    // At config bound, can't go further
    downBri = currentBri;
    downCCT = currentCCT;
  } else {
    downBri = Math.max(bMin, currentBri - briStep);
    downCCT = getStepResultCCT(downBri);
  }

  return { upBri, upCCT, downBri, downCCT };
}

/**
 * Preview brightness button results (matches stepCursor logic for brightness-only).
 * @returns {Object} { up: { value, atExtreme }, down: { value, atExtreme } }
 */
function getBrightnessPreview() {
  const currentBri = getBrightnessAtCursor();
  if (currentBri === null) {
    return {
      up: { value: 100, atExtreme: true },
      down: { value: 10, atExtreme: true }
    };
  }

  const bMin = config.min_brightness;
  const bMax = config.max_brightness;
  const steps = config.brightness_increments ?? config.max_dim_steps ?? 10;
  const briStep = (bMax - bMin) / steps;

  const atMaxBri = currentBri >= bMax - 0.5;
  const atMinBri = currentBri <= bMin + 0.5;

  const upValue = atMaxBri ? currentBri : Math.min(bMax, currentBri + briStep);
  const downValue = atMinBri ? currentBri : Math.max(bMin, currentBri - briStep);

  return {
    up: { value: upValue, atExtreme: atMaxBri },
    down: { value: downValue, atExtreme: atMinBri }
  };
}

/**
 * Preview color button results (matches stepCursor logic for color-only).
 * Applies solar rules to get the actual displayed result.
 * @returns {Object} { up: { value, atExtreme }, down: { value, atExtreme } }
 */
function getColorPreview() {
  const displayedCCT = getDisplayedCCTAtCursor();
  if (displayedCCT === null || cursorHour === null) {
    return {
      up: { value: 6500, atExtreme: true },
      down: { value: 2700, atExtreme: true }
    };
  }

  const cMin = config.min_color_temp;
  const cMax = config.max_color_temp;
  const steps = config.color_increments ?? config.max_dim_steps ?? 10;
  const cctStep = (cMax - cMin) / steps;

  // Check config bounds (same as stepCursor)
  const atConfigMax = displayedCCT >= cMax - 10;
  const atConfigMin = displayedCCT <= cMin + 10;

  // Calculate raw targets (same as stepCursor)
  const rawUpTarget = Math.min(cMax, displayedCCT + cctStep);
  const rawDownTarget = Math.max(cMin, displayedCCT - cctStep);

  // Apply solar rules to get what will actually be displayed
  const upDisplayed = applySolarRuleAtHour(rawUpTarget, cursorHour);
  const downDisplayed = applySolarRuleAtHour(rawDownTarget, cursorHour);

  // At extreme if at config bounds OR if solar rules capped the result
  const upAtExtreme = atConfigMax || Math.abs(upDisplayed - displayedCCT) < 10;
  const downAtExtreme = atConfigMin || Math.abs(downDisplayed - displayedCCT) < 10;

  return {
    up: { value: upDisplayed, atExtreme: upAtExtreme },
    down: { value: downDisplayed, atExtreme: downAtExtreme }
  };
}

function dayOfYear(dateStr) {
  const d = new Date(dateStr + 'T12:00:00');
  const s = new Date(d.getFullYear(), 0, 0);
  return Math.floor((d - s) / 86400000);
}

function solarDeclination(doy) {
  return (23.44 * Math.PI / 180) * Math.sin(2 * Math.PI * (284 + doy) / 365);
}

function getSunTimes(lat, lon, dateStr) {
  const date = new Date(dateStr || new Date().toISOString());
  const n = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
  const J = n + ((lon < 0 ? 360 + lon : lon) / 360);
  const M = (357.5291 + 0.9856 * J) % 360;
  const C = 1.9148 * Math.sin(rad(M)) + 0.02 * Math.sin(rad(2 * M)) + 0.0003 * Math.sin(rad(3 * M));
  const L = (M + 102.9372 + C + 180) % 360;
  const D = Math.asin(Math.sin(rad(L)) * Math.sin(rad(23.44)));
  const cosH0 = (Math.cos(rad(90.833)) - Math.sin(rad(lat)) * Math.sin(D)) / (Math.cos(rad(lat)) * Math.cos(D));

  if (cosH0 < -1 || cosH0 > 1) {
    const sn = 12 - date.getTimezoneOffset() / 60 - (lon / 15);
    return { sunrise: sn - 6, sunset: sn + 6, solarNoon: sn, solarMid: (sn + 12) % 24 };
  }

  const H0 = Math.acos(cosH0);
  const dl = (2 * H0 * 180 / Math.PI) / 15;
  const tz = -date.getTimezoneOffset() / 60;
  const sn = 12 + tz - (lon / 15);
  return { sunrise: sn - dl / 2, sunset: sn + dl / 2, solarNoon: sn, solarMid: (sn + 12) % 24 };
}

/**
 * Estimate sun elevation (degrees) at a given hour, using lat/lon and date.
 * Returns 0 for below-horizon.
 */
function getSunElevationAtHour(hour, lat, lon, dateStr) {
  const date = new Date(dateStr || new Date().toISOString());
  const doy = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
  const decl = solarDeclination(doy);
  const latRad = lat * Math.PI / 180;
  const tz = -date.getTimezoneOffset() / 60;
  const solarNoon = 12 + tz - (lon / 15);
  const hourAngle = (hour - solarNoon) * 15 * Math.PI / 180;
  const sinElev = Math.sin(latRad) * Math.sin(decl) + Math.cos(latRad) * Math.cos(decl) * Math.cos(hourAngle);
  return Math.max(0, Math.asin(sinElev) * 180 / Math.PI);
}

/**
 * Convert sun elevation to outdoor_normalized (0-1) with condition multiplier.
 * Models: clear_sky_lux = 120000 * sin(elev), then log-scale to 0-1.
 */
function elevationToOutdoorNorm(elevDeg, conditionMultiplier) {
  if (elevDeg <= 0 || conditionMultiplier <= 0) return 0;
  const FULL_SUN_INTENSITY = 8.4;
  const clearSkyLux = 120000 * Math.sin(elevDeg * Math.PI / 180);
  const estimatedLux = clearSkyLux * conditionMultiplier;
  if (estimatedLux <= 300) return 0;
  return Math.min(1.0, Math.log2(estimatedLux / 300) / FULL_SUN_INTENSITY);
}

function getSelectedDateISO() {
  const slider = document.getElementById('chart-date-slider');
  const dayOffset = slider ? parseInt(slider.value) : 0;
  const now = new Date();
  const target = new Date(now.getFullYear(), 0, 1 + dayOffset);
  return target.toISOString().split('T')[0];
}

// ============================================================
// Color Helpers - loaded from shared.js
// ============================================================

// Generate color gradient for slider tracks
function updateColorGradients() {
  const minK = config.min_color_temp;
  const maxK = config.max_color_temp;
  const steps = 16;

  // Main color track
  const colorTrack = document.getElementById('color-track');
  if (colorTrack) {
    const stops = [];
    for (let i = 0; i <= steps; i++) {
      const k = 500 + (6000 * i / steps);
      stops.push(`${cctToRGB(k)} ${(i / steps) * 100}%`);
    }
    colorTrack.style.background = `linear-gradient(90deg, ${stops.join(',')})`;

    // Update masks
    const maskLeft = document.getElementById('color-mask-left');
    const maskRight = document.getElementById('color-mask-right');
    if (maskLeft && maskRight) {
      const leftPct = ((minK - 500) / 6000) * 100;
      const rightPct = ((maxK - 500) / 6000) * 100;
      maskLeft.style.left = '0%';
      maskLeft.style.width = `${leftPct}%`;
      maskRight.style.left = `${rightPct}%`;
      maskRight.style.width = `${100 - rightPct}%`;
    }
  }

  // Warm night track - gradient matches slider's dynamic bounds
  const warmTrack = document.getElementById('warm-night-track');
  const warmSlider = document.getElementById('warm-night-target');
  if (warmTrack && warmSlider) {
    const warmMin = parseInt(warmSlider.min) || minK;
    const warmMax = parseInt(warmSlider.max) || maxK;
    const stops = [];
    for (let i = 0; i <= steps; i++) {
      const k = warmMin + ((warmMax - warmMin) * i / steps);
      stops.push(`${cctToRGB(k)} ${(i / steps) * 100}%`);
    }
    warmTrack.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
  }

  // Daylight CCT track - gradient matches slider's dynamic bounds
  const daylightTrack = document.getElementById('daylight-cct-track');
  const daylightSlider = document.getElementById('daylight-cct');
  if (daylightTrack && daylightSlider) {
    const daylightMin = parseInt(daylightSlider.min) || minK;
    const daylightMax = parseInt(daylightSlider.max) || maxK;
    const stops = [];
    for (let i = 0; i <= steps; i++) {
      const k = daylightMin + ((daylightMax - daylightMin) * i / steps);
      stops.push(`${cctToRGB(Math.max(500, k))} ${(i / steps) * 100}%`);
    }
    daylightTrack.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
  }

  // Update target chips
  updateColorChips();
}

function updateColorChips() {
  const warmChip = document.getElementById('warm-night-target-chip');
  if (warmChip) {
    const k = config.warm_night_target;
    warmChip.textContent = `${k} K`;
    warmChip.style.background = cctToRGB(k);
    warmChip.style.color = readableTextColor(cctToRGB(k));
  }

  const daylightChip = document.getElementById('daylight-cct-chip');
  if (daylightChip) {
    const k = config.daylight_cct;
    daylightChip.textContent = k > 0 ? `${k} K` : 'Off';
    daylightChip.style.background = k > 0 ? cctToRGB(k) : '#666';
    daylightChip.style.color = k > 0 ? readableTextColor(cctToRGB(k)) : '#fff';
  }

}

// Apply solar color rules to CCT curve (batch version for chart rendering)
function adjustCCTForSolarRules(cctArray, hoursArray, sunrise, sunset) {
  if (!config.warm_night_enabled && !config.daylight_cct) return;
  for (let i = 0; i < cctArray.length; i++) {
    cctArray[i] = applySolarRuleAtHour(cctArray[i], hoursArray[i]);
  }
}

// ============================================================
// Utility Functions
// ============================================================

function formatHour(h) {
  const h24 = ((h % 24) + 24) % 24;
  let hr = Math.floor(h24);
  let min = Math.round((h24 - hr) * 60);
  // Handle rounding to 60 minutes
  if (min === 60) {
    min = 0;
    hr = (hr + 1) % 24;
  }
  const suffix = hr < 12 ? 'a' : 'p';
  const hr12 = hr === 0 ? 12 : (hr > 12 ? hr - 12 : hr);
  return min === 0 ? `${hr12}:00${suffix}` : `${hr12}:${min.toString().padStart(2, '0')}${suffix}`;
}

function fmtTime(h) {
  return formatHour(h);
}

function logistic(x, midpoint, slope, y0, y1) {
  try {
    const expVal = Math.exp(-slope * (x - midpoint));
    return y0 + (y1 - y0) / (1 + expVal);
  } catch {
    return slope * (x - midpoint) > 0 ? y1 : y0;
  }
}

// ============================================================
// Curve Calculation
// ============================================================

// ============================================================
// Core Calculation Functions (single source of truth)
// These mirror brain.py's CircadianLight.calculate_* methods
// ============================================================

/**
 * Calculate brightness at a specific hour (0-1 scale).
 * This is the single source of truth for brightness calculations.
 */
function calculateBrightnessAtHour(hour) {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  // Determine current phase from cursor for runtimeState application
  const cursorH48 = cursorHour !== null ? (cursorHour < tAscend ? cursorHour + 24 : cursorHour) : tAscend;
  const cursorInAscend = cursorH48 >= tAscend && cursorH48 < tDescend;

  // Resolve effective timing for chart weekday
  const weekday = getChartWeekday();
  const timing = resolveEffectiveTiming(hour, weekday);

  // runtimeState midpoints apply to current phase only
  let wakeMid = cursorInAscend ? (runtimeState.brightness_mid ?? timing.wake) : timing.wake;
  let bedMid = !cursorInAscend ? (runtimeState.brightness_mid ?? timing.bed) : timing.bed;

  // Clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];

  // Config bounds (only use these, no runtime overrides)
  const bMin = config.min_brightness / 100;
  const bMax = config.max_brightness / 100;

  // Phase detection for this hour
  const h48 = hour < tAscend ? hour + 24 : hour;
  const inAscend = h48 >= tAscend && h48 < tDescend;

  // Apply brightness target shift when not stepping
  if (runtimeState.brightness_mid == null) {
    const slope = inAscend ? kAscend : -kDescend;
    const brightPct = inAscend ? (config.wake_brightness || 50) : (config.bed_brightness || 50);
    if (brightPct !== 50) {
      if (inAscend) {
        let rawMid48 = wakeMid;
        while (rawMid48 < tAscend) rawMid48 += 24;
        while (rawMid48 > tDescend) rawMid48 -= 24;
        rawMid48 = Math.max(tAscend + 0.01, Math.min(tDescend - 0.01, rawMid48));
        wakeMid = computeShiftedMidpoint(rawMid48, brightPct, slope, bMin, bMax) % 24;
      } else {
        const phaseEnd = tDescend + 24;
        let rawMid48 = bedMid;
        while (rawMid48 < tDescend) rawMid48 += 24;
        while (rawMid48 > phaseEnd) rawMid48 -= 24;
        rawMid48 = Math.max(tDescend + 0.01, Math.min(phaseEnd - 0.01, rawMid48));
        bedMid = computeShiftedMidpoint(rawMid48, brightPct, slope, bMin, bMax) % 24;
      }
    }
  }

  // Lift midpoint to 48h space and clamp to phase boundaries
  let mid48;
  if (inAscend) {
    mid48 = wakeMid;
    while (mid48 < tAscend - 12) mid48 += 24;
    while (mid48 > tDescend + 12) mid48 -= 24;
    mid48 = Math.max(tAscend + 0.01, Math.min(tDescend - 0.01, mid48));
  } else {
    mid48 = bedMid;
    const phaseEnd = tDescend + 24;
    while (mid48 < tDescend - 12) mid48 += 24;
    while (mid48 > phaseEnd + 12) mid48 -= 24;
    mid48 = Math.max(tDescend + 0.01, Math.min(phaseEnd - 0.01, mid48));
  }

  // Calculate brightness from logistic curve
  let value;
  if (inAscend) {
    value = logistic(h48, mid48, kAscend, bMin, bMax);
  } else {
    const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
    value = logistic(hDescend48, mid48, -kDescend, bMin, bMax);
  }

  // Clamp to bounds (matches brain.py)
  return Math.max(bMin, Math.min(bMax, value));
}

/**
 * Calculate color temperature at a specific hour (Kelvin).
 * This is the single source of truth for CCT calculations.
 * @param {number} hour - Hour (0-24)
 * @param {boolean} applySolar - Whether to apply solar rules (default true)
 */
function calculateColorAtHour(hour, applySolar = true) {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  // Determine current phase from cursor for runtimeState application
  const cursorH48 = cursorHour !== null ? (cursorHour < tAscend ? cursorHour + 24 : cursorHour) : tAscend;
  const cursorInAscend = cursorH48 >= tAscend && cursorH48 < tDescend;

  // Resolve effective timing for chart weekday (alt times)
  const weekday = getChartWeekday();
  const timing = resolveEffectiveTiming(hour, weekday);

  // runtimeState midpoints apply to current phase only
  const colorWakeMid = cursorInAscend ? (runtimeState.color_mid ?? timing.wake) : timing.wake;
  const colorBedMid = !cursorInAscend ? (runtimeState.color_mid ?? timing.bed) : timing.bed;

  // Clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];

  // Config bounds (only use these, no runtime overrides)
  const cLow = config.min_color_temp;
  const cHigh = config.max_color_temp;

  // Phase detection for this hour
  const h48 = hour < tAscend ? hour + 24 : hour;
  const inAscend = h48 >= tAscend && h48 < tDescend;

  // Lift midpoint to 48h space and clamp to phase boundaries
  // This prevents wrap-around issues when midpoint is near/past phase boundary
  let mid48;
  if (inAscend) {
    mid48 = colorWakeMid;
    // Lift into valid range first
    while (mid48 < tAscend - 12) mid48 += 24;
    while (mid48 > tDescend + 12) mid48 -= 24;
    // Clamp to phase boundaries (with small margin for numerical stability)
    mid48 = Math.max(tAscend + 0.01, Math.min(tDescend - 0.01, mid48));
  } else {
    mid48 = colorBedMid;
    const phaseEnd = tDescend + 24;
    // Lift into valid range first
    while (mid48 < tDescend - 12) mid48 += 24;
    while (mid48 > phaseEnd + 12) mid48 -= 24;
    // Clamp to phase boundaries (with small margin for numerical stability)
    mid48 = Math.max(tDescend + 0.01, Math.min(phaseEnd - 0.01, mid48));
  }

  // Calculate normalized color value (0-1)
  let normalized;
  if (inAscend) {
    normalized = logistic(h48, mid48, kAscend, 0, 1);
  } else {
    const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
    normalized = logistic(hDescend48, mid48, -kDescend, 0, 1);
  }
  normalized = Math.max(0, Math.min(1, normalized));

  // Convert to Kelvin
  let cct = cLow + (cHigh - cLow) * normalized;

  // Apply solar rules if requested
  if (applySolar) {
    cct = applySolarRuleAtHour(cct, hour);
  }

  return cct;
}

/**
 * Get phase (Ascend/Descend) at a specific hour.
 */
function getPhaseAtHour(hour) {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  const h48 = hour < tAscend ? hour + 24 : hour;
  return h48 < tDescend ? 'Ascend' : 'Descend';
}

/**
 * Generate curve data for chart rendering.
 * Uses the core calculation functions to ensure consistency.
 */
function calculateCurveData() {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  const hours = Array.from({ length: 480 }, (_, i) => (i * 3) / 60);

  // Use core calculation functions for each data point
  const brightness = hours.map(h => calculateBrightnessAtHour(h));
  const cct = hours.map(h => calculateColorAtHour(h, false));  // Solar rules applied separately in renderChart
  const phase = hours.map(h => getPhaseAtHour(h));

  return { hours, brightness, cct, phase, tAscend, tDescend };
}

// Get brightness at specific x value
function getBrightnessAt(xVal, brightnessPct, samplesPerHour) {
  const idx = Math.min(brightnessPct.length - 1, Math.max(0, Math.round(xVal * samplesPerHour)));
  return brightnessPct[idx];
}

// Generate phase segments for shading
function spanSegments(start, end) {
  let delta = ((end - start) % 24 + 24) % 24;
  if (delta === 0) delta = 24;
  const startWrap = wrap24(start);
  const endWrap = (startWrap + delta) % 24;
  if (delta === 24) return [{ start: 0, end: 24 }];
  if (startWrap < endWrap) return [{ start: startWrap, end: endWrap }];
  return [
    { start: startWrap, end: 24 },
    { start: 0, end: endWrap }
  ];
}

// ============================================================
// Chart Rendering
// ============================================================

function renderChart() {
  const dateStr = getSelectedDateISO();
  const { sunrise, sunset, solarNoon, solarMid } = getSunTimes(config.latitude, config.longitude, dateStr);

  // Cache sun times for color rules
  sunTimes = { sunrise, sunset, solarNoon, solarMid };

  const data = calculateCurveData();

  // Apply solar color rules to CCT
  adjustCCTForSolarRules(data.cct, data.hours, sunrise, sunset);

  const { hours, brightness, cct, phase, tAscend, tDescend } = data;
  const brightnessPct = brightness.map(v => v * 100);

  // Store graph data for cursor functions (include brightnessPct for 0-100 scale)
  graphData = { ...data, brightnessPct };
  const samplesPerHour = hours.length / 24;

  // Build traces
  const traces = [];

  // Color-gradient brightness curve (filled + line segments)
  const step = 2;
  for (let i = step; i < hours.length; i += step) {
    const color = cctToRGB(cct[i]);
    const fillColor = colorWithAlpha(color, 0.5);
    const x0 = hours[i - step];
    const x1 = hours[i];
    const y0 = brightnessPct[i - step];
    const y1 = brightnessPct[i];

    // Filled area under curve
    traces.push({
      type: 'scatter',
      mode: 'lines',
      x: [x0, x1, x1, x0],
      y: [y0, y1, 0, 0],
      fill: 'toself',
      line: { width: 0 },
      fillcolor: fillColor,
      hoverinfo: 'skip',
      showlegend: false
    });

    // Colored line segment
    traces.push({
      type: 'scatter',
      mode: 'lines',
      x: [x0, x1],
      y: [y0, y1],
      line: { width: 3, color },
      hoverinfo: 'skip',
      showlegend: false
    });
  }

  // Sun curve - LINE ONLY, no fill
  const lat = config.latitude;
  const latRad = lat * Math.PI / 180;
  const doyToday = dayOfYear(dateStr);
  const doyWinter = dayOfYear(`${new Date(dateStr).getFullYear()}-12-21`);
  const deltaToday = solarDeclination(doyToday);
  const deltaWinter = solarDeclination(doyWinter);

  const H = hours.map(hh => (hh - solarNoon) * (Math.PI / 12));

  function zenith(phi, delta, Hr) {
    const c = Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(Hr);
    return Math.acos(Math.max(-1, Math.min(1, c)));
  }

  function ghiHaurwitz(z) {
    if (z >= Math.PI / 2) return 0;
    const mu = Math.cos(z);
    return 1098 * mu * Math.exp(-0.057 / mu);
  }

  const ghiToday = H.map(Hr => ghiHaurwitz(zenith(latRad, deltaToday, Hr)));
  const ghiWinter = H.map(Hr => ghiHaurwitz(zenith(latRad, deltaWinter, Hr)));
  const alpha = 1.5 / Math.max(...ghiWinter, 0.001);
  const sunScaledPct = ghiToday.map(v => v * alpha * 100);

  // Sun curve - just line, no fill (hidden in simple mode)
  if (!simpleMode) {
    traces.push({
      type: 'scatter',
      mode: 'lines',
      x: hours,
      y: sunScaledPct,
      line: { width: 1, color: 'rgba(255,255,255,0.25)' },
      name: 'Sun',
      hoverinfo: 'skip',
      showlegend: true
    });
  }

  // Hover trace - CCT colored background, shows phase, no time
  const hoverDetails = brightnessPct.map((v, i) => {
    const pct = Math.round(v);
    const kelvin = Math.round(cct[i]);
    return `${pct}% • ${kelvin}K`;
  });

  const hoverBgColors = cct.map(k => colorWithAlpha(cctToRGB(k), 0.92));
  const hoverTextColors = cct.map(k => readableTextColor(cctToRGB(k)));
  const hoverBorderColors = cct.map(k => colorWithAlpha(cctToRGB(k), 0.65));

  traces.push({
    type: 'scatter',
    mode: 'lines',
    x: hours,
    y: brightnessPct,
    line: { width: 0 },
    showlegend: false,
    text: hoverDetails,
    hovertemplate: '%{text}<extra></extra>',
    hoverlabel: {
      bgcolor: hoverBgColors,
      bordercolor: hoverBorderColors,
      font: { color: hoverTextColors, size: 13 }
    }
  });

  // Legend placeholder for Circadian Light
  traces.push({
    type: 'scatter',
    mode: 'lines',
    x: [null],
    y: [null],
    line: { width: 3, color: '#fff' },
    name: 'Circadian Light',
    hoverinfo: 'skip',
    showlegend: true
  });

  // Cursor point marker trace (CCT-colored ball at cursor position)
  traces.push({
    x: [null],
    y: [null],
    mode: 'markers',
    marker: { size: 14, color: '#fff', line: { width: 2, color: '#fff' } },
    hoverinfo: 'skip',
    showlegend: false,
    name: 'cursor-point'
  });
  window.cursorTraceIndex = traces.length - 1;

  // Shapes and annotations
  const shapes = [];
  const annotations = [];

  // Phase shading ABOVE the curve
  const ascendSegments = spanSegments(tAscend, tDescend);
  const descendSegments = spanSegments(tDescend, tAscend + 24);

  const addCurveBand = (segments, color) => {
    const yTop = GRAPH_Y_MAX;
    const stepSize = 0.05;
    segments.forEach(seg => {
      const points = [];
      for (let x = seg.start; x <= seg.end + 1e-6; x += stepSize) {
        const clamped = Math.min(seg.end, x);
        points.push({ x: clamped, y: getBrightnessAt(clamped, brightnessPct, samplesPerHour) });
      }
      if (!points.length) return;
      const startX = points[0].x;
      const endX = points[points.length - 1].x;
      let path = `M ${startX} ${yTop} L ${endX} ${yTop}`;
      for (let i = points.length - 1; i >= 0; i--) {
        path += ` L ${points[i].x} ${points[i].y}`;
      }
      path += ' Z';
      shapes.push({
        type: 'path',
        xref: 'x',
        yref: 'y',
        path,
        fillcolor: color,
        line: { width: 0 },
        layer: 'below'
      });
    });
  };

  const ascendStart = wrap24(config.ascend_start);
  const descendStart = wrap24(config.descend_start);

  if (!simpleMode) {
    addCurveBand(ascendSegments, ASCEND_COLORS.shade);
    addCurveBand(descendSegments, DESCEND_COLORS.shade);

    // Phase boundary lines
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: ascendStart, x1: ascendStart, y0: 0, y1: 1,
      line: { color: ASCEND_COLORS.axis, width: 1.5 }
    });
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: descendStart, x1: descendStart, y0: 0, y1: 1,
      line: { color: DESCEND_COLORS.axis, width: 1.5 }
    });
  }

  // Phase name labels above the curve (at y=115)
  const phaseNameY = 115;
  const addPhaseNameLabels = (segments, label, palette) => {
    segments.forEach(seg => {
      const span = seg.end - seg.start;
      if (span < 1) return;  // Skip segments shorter than 1 hour
      const mid = seg.start + span / 2;
      annotations.push({
        x: mid,
        y: phaseNameY,
        xref: 'x',
        yref: 'y',
        text: label,
        showarrow: false,
        font: { size: 13, color: palette.text },
        opacity: 0.85,
        hoverlabel: {
          bgcolor: palette.hoverBg,
          bordercolor: palette.hoverBg,
          font: { color: readableTextColor(palette.hoverBg) }
        }
      });
    });
  };
  if (!simpleMode) {
    addPhaseNameLabels(ascendSegments, 'Ascend', ASCEND_COLORS);
    addPhaseNameLabels(descendSegments, 'Descend', DESCEND_COLORS);
  }

  // X-axis labels (from top to bottom):
  // 1. Time labels (handled by xaxis ticktext at y=0)
  // 2. Phase labels (ascend starts, wake, descend starts, bed) at y = -0.14
  // 3. Solar labels (sunrise, sunset, etc.) at y = -0.20, muted grey

  // Phase labels with vertical lines
  const allPhaseLabels = [
    { label: 'ascend starts', x: ascendStart, color: ASCEND_COLORS.text, lineColor: ASCEND_COLORS.axis, solid: true, extendUp: true },
    { label: 'wake', x: wrap24(config.wake_time), color: ASCEND_COLORS.text, lineColor: ASCEND_COLORS.axis, solid: false, extendUp: true },
    { label: 'descend starts', x: descendStart, color: DESCEND_COLORS.text, lineColor: DESCEND_COLORS.axis, solid: true, extendUp: true },
    { label: 'bed', x: wrap24(config.bed_time), color: DESCEND_COLORS.text, lineColor: DESCEND_COLORS.axis, solid: false, extendUp: true }
  ];
  const phaseLabels = simpleMode
    ? allPhaseLabels.filter(m => m.label === 'wake' || m.label === 'bed')
    : allPhaseLabels;

  phaseLabels.forEach(marker => {
    // Vertical line from label up through the graph
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: marker.x, x1: marker.x,
      y0: -0.08,
      y1: marker.extendUp ? 1 : 0,
      line: { color: marker.lineColor, width: marker.solid ? 1.6 : 1, dash: marker.solid ? 'solid' : 'dot' }
    });
    const hoverBg = marker.color === ASCEND_COLORS.text ? ASCEND_COLORS.hoverBg : DESCEND_COLORS.hoverBg;
    annotations.push({
      x: marker.x, y: -0.14, xref: 'x', yref: 'paper',
      text: marker.label,
      showarrow: false,
      font: { size: 11, color: marker.color },
      hovertext: fmtTime(marker.x),
      hoverlabel: {
        bgcolor: hoverBg,
        bordercolor: hoverBg,
        font: { color: readableTextColor(hoverBg), size: 12 }
      }
    });
  });

  // Solar labels - all same muted grey color, lower position
  const solarLabelColor = 'rgba(215,215,215,0.8)';
  const solarLineColor = 'rgba(200,200,200,0.35)';
  const allSolarLabels = [
    { label: 'sunrise', x: wrap24(sunrise), extendUp: true },
    { label: 'sunset', x: wrap24(sunset), extendUp: true },
    { label: 'solar noon', x: wrap24(solarNoon), extendUp: false },
    { label: 'solar midnight', x: wrap24(solarMid), extendUp: false }
  ];
  // In simple mode: only sunrise/sunset, lines stop at x-axis
  const solarLabels = simpleMode
    ? allSolarLabels.filter(m => m.label === 'sunrise' || m.label === 'sunset')
    : allSolarLabels;

  const solarHoverBg = '#3a3a3a';
  solarLabels.forEach(marker => {
    if (!Number.isFinite(marker.x)) return;
    // Line from label up (sunrise/sunset go all the way up, unless simple mode)
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: marker.x, x1: marker.x,
      y0: -0.135,
      y1: (simpleMode) ? 0 : (marker.extendUp ? 1 : 0),
      line: { color: solarLineColor, width: 1, dash: 'dot' }
    });
    annotations.push({
      x: marker.x, y: -0.20, xref: 'x', yref: 'paper',
      text: marker.label,
      showarrow: false,
      font: { size: 10, color: solarLabelColor },
      hovertext: fmtTime(marker.x),
      hoverlabel: {
        bgcolor: solarHoverBg,
        bordercolor: solarHoverBg,
        font: { color: '#fff', size: 12 }
      }
    });
  });

  // Store base shapes/annotations for cursor updates
  window.baseShapes = shapes.slice();
  window.baseAnnotations = annotations.slice();

  const layout = {
    paper_bgcolor: '#0a0a0a',
    plot_bgcolor: '#0a0a0a',
    margin: { t: simpleMode ? 10 : 40, r: 40, l: 50, b: 100 },
    legend: { orientation: 'h', x: 0, y: 1.1, font: { color: '#c8c8c8' } },
    showlegend: !simpleMode,
    hovermode: 'closest',
    xaxis: {
      range: [0, 24],
      dtick: 2,
      tickvals: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24],
      ticktext: ['12a', '2a', '4a', '6a', '8a', '10a', '12p', '2p', '4p', '6p', '8p', '10p', '12a'],
      gridcolor: 'rgba(80,100,130,0.22)',
      tickfont: { color: '#c8c8c8' },
      ticklen: 4,
      tickcolor: 'rgba(160,190,220,0.2)'
    },
    yaxis: {
      range: [0, GRAPH_Y_MAX],
      gridcolor: 'rgba(80,100,130,0.22)',
      tickfont: { color: '#c8c8c8' },
      ticklen: 4,
      title: 'Brightness (%)',
      titlefont: { color: '#c8c8c8' }
    },
    shapes,
    annotations
  };

  Plotly.react('chart', traces, layout, { displayModeBar: false }).then(() => {
    initChartInteractivity();
    applyCursor();
  });

  // Update date display
  const dateDisplay = document.getElementById('chart-date-display');
  if (dateDisplay) {
    const d = new Date(dateStr + 'T12:00:00');
    dateDisplay.textContent = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }

  // Update color chips (including temp ceiling/floor)
  updateColorChips();
}

// ============================================================
// Chart Interactivity
// ============================================================

function initChartInteractivity() {
  const chart = document.getElementById('chart');
  if (!chart || chart._interactivityInitialized) return;

  const chartWrapper = document.querySelector('.chart-wrapper');
  const hoverLabel = document.getElementById('time-hover-label');

  // Helper to get plot area (Plotly creates this after rendering)
  const getPlotArea = () => {
    // Try multiple selectors for Plotly's plot area
    return chart.querySelector('.cartesianlayer .plot') ||
           chart.querySelector('.plot-container .plot') ||
           chart.querySelector('.nsewdrag');
  };

  // Mouse move for time hover label at top
  chart.addEventListener('mousemove', (ev) => {
    const plotArea = getPlotArea();
    if (!plotArea) return;

    const rect = plotArea.getBoundingClientRect();
    const inside = ev.clientX >= rect.left && ev.clientX <= rect.right &&
                   ev.clientY >= rect.top && ev.clientY <= rect.bottom;

    if (!inside) {
      hoverLabel.style.opacity = '0';
      return;
    }

    const layout = chart._fullLayout;
    const xRange = layout?.xaxis?.range || [0, 24];
    const ratio = (ev.clientX - rect.left) / rect.width;
    const xVal = xRange[0] + ratio * (xRange[1] - xRange[0]);
    const wrapperRect = chartWrapper.getBoundingClientRect();

    hoverLabel.textContent = fmtTime(xVal);
    hoverLabel.style.left = `${ev.clientX - wrapperRect.left}px`;

    // Color based on phase
    const tAscend = config.ascend_start;
    let tDescend = config.descend_start;
    if (tDescend <= tAscend) tDescend += 24;
    let h = xVal;
    if (h < tAscend) h += 24;
    const inAscend = h < tDescend;
    const chipColor = inAscend ? ASCEND_COLORS.hoverBg : DESCEND_COLORS.hoverBg;

    hoverLabel.style.background = chipColor;
    hoverLabel.style.color = readableTextColor(chipColor);
    hoverLabel.style.opacity = '1';
  }, true);  // Use capture phase

  chart.addEventListener('mouseleave', () => {
    hoverLabel.style.opacity = '0';
  }, true);

  // Click for cursor placement - use capture to get events before Plotly
  chart.addEventListener('click', (ev) => {
    const plotArea = getPlotArea();
    if (!plotArea) {
      console.log('No plot area found');
      return;
    }

    const rect = plotArea.getBoundingClientRect();
    if (ev.clientX < rect.left || ev.clientX > rect.right ||
        ev.clientY < rect.top || ev.clientY > rect.bottom) {
      return;
    }

    const layout = chart._fullLayout;
    const xRange = layout?.xaxis?.range || [0, 24];
    const ratio = (ev.clientX - rect.left) / rect.width;
    const xVal = xRange[0] + ratio * (xRange[1] - xRange[0]);

    cursorHour = xVal;
    applyCursor();
  }, true);  // Use capture phase

  // Double click to clear cursor
  chart.addEventListener('dblclick', () => {
    cursorHour = null;
    applyCursor();
  }, true);

  chart._interactivityInitialized = true;
}

function applyCursor() {
  const chart = document.getElementById('chart');
  const cursorControls = document.getElementById('cursor-controls');
  const cursorCallout = document.getElementById('cursor-callout');
  const traceIdx = typeof window.cursorTraceIndex === 'number' ? window.cursorTraceIndex : null;

  if (!chart || !window.baseShapes) return;

  const shapes = window.baseShapes.slice();
  const annotations = window.baseAnnotations ? window.baseAnnotations.slice() : [];

  if (cursorHour === null) {
    Plotly.relayout(chart, { shapes, annotations });
    if (traceIdx != null) {
      Plotly.restyle(chart, { x: [[null]], y: [[null]] }, traceIdx);
    }
    cursorControls.classList.add('hidden');
    cursorCallout.style.opacity = '0';
    updateCursorButtons(null);
    return;
  }

  // Get cursor point data using core calculation functions (exact values, no interpolation)
  let cursorPoint = null;
  if (config) {
    cursorPoint = {
      x: cursorHour,
      y: calculateBrightnessAtHour(cursorHour) * 100,  // Convert 0-1 to 0-100
      cct: calculateColorAtHour(cursorHour, true),     // With solar rules
      phase: getPhaseAtHour(cursorHour)
    };

    // Reset runtime state on phase transition (ascend ↔ descend)
    if (lastCursorPhase !== null && cursorPoint.phase !== lastCursorPhase) {
      resetRuntimeState();
      // Re-render chart with reset state
      renderChart();
    }
    lastCursorPhase = cursorPoint.phase;
  }

  // Cursor line style - dotted white
  const cursorLineStyle = { color: '#fdfdfd', width: 2, dash: 'dot' };
  const cursorLabelY = -0.26;

  // Add cursor line with gap around the point
  if (cursorPoint) {
    const gap = 3;
    const lowerEnd = Math.max(0, cursorPoint.y - gap);
    const upperStart = Math.min(GRAPH_Y_MAX, cursorPoint.y + gap);

    // Lower segment
    shapes.push({
      type: 'line', xref: 'x', yref: 'y',
      x0: cursorHour, x1: cursorHour, y0: 0, y1: lowerEnd,
      line: cursorLineStyle, layer: 'above'
    });
    // Upper segment
    shapes.push({
      type: 'line', xref: 'x', yref: 'y',
      x0: cursorHour, x1: cursorHour, y0: upperStart, y1: GRAPH_Y_MAX,
      line: cursorLineStyle, layer: 'above'
    });
  } else {
    // Full line if no point
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: cursorHour, x1: cursorHour, y0: 0, y1: 1,
      line: cursorLineStyle, layer: 'above'
    });
  }

  // Cursor line extending below x-axis down to callout
  shapes.push({
    type: 'line', xref: 'x', yref: 'paper',
    x0: cursorHour, x1: cursorHour, y0: -0.26, y1: 0,
    line: cursorLineStyle, layer: 'above'
  });


  Plotly.relayout(chart, { shapes, annotations });

  // Update cursor callout and marker
  if (cursorPoint) {
    const bri = Math.round(cursorPoint.y);
    const cctVal = Math.round(cursorPoint.cct);
    const color = cctToRGB(cctVal);

    const plotArea = chart.querySelector('.cartesianlayer .plot') || chart.querySelector('.nsewdrag');
    const chartWrapper = document.querySelector('.chart-wrapper');
    if (plotArea && chartWrapper) {
      const rect = plotArea.getBoundingClientRect();
      const chartRect = chart.getBoundingClientRect();
      const wrapperRect = chartWrapper.getBoundingClientRect();
      const layout = chart._fullLayout;
      const xRange = layout?.xaxis?.range || [0, 24];
      const ratio = (cursorHour - xRange[0]) / (xRange[1] - xRange[0] || 1);
      const leftPx = rect.left + ratio * rect.width - wrapperRect.left;

      cursorCallout.textContent = `${fmtTime(cursorHour)} • ${bri}% • ${cctVal}K`;
      cursorCallout.style.left = `${leftPx}px`;
      cursorCallout.style.opacity = '1';

      // Color callout based on CCT
      cursorCallout.style.background = color;
      cursorCallout.style.color = readableTextColor(color);
      cursorCallout.style.borderColor = '#fdfdfd';
    }

    // Update cursor ball marker (CCT-colored with white border)
    if (traceIdx != null) {
      const markerUpdate = {
        x: [[cursorPoint.x]],
        y: [[cursorPoint.y]],
        marker: [{
          size: 14,
          color,
          opacity: 1,
          symbol: 'circle',
          line: { width: 2, color: '#fff' }
        }]
      };
      Plotly.restyle(chart, markerUpdate, traceIdx);
    }

    // Update cursor button styles with NEXT values
    updateCursorButtons(cursorPoint);

    // Live Design: update lights when cursor values change
    applyLiveLight();
  }

  cursorControls.classList.remove('hidden');
}

// Style cursor buttons based on NEXT values (what button WILL DO)
function updateCursorButtons(point) {
  const stepUp = document.getElementById('cursor-step-up');
  const stepDown = document.getElementById('cursor-step-down');
  const brightUp = document.getElementById('cursor-bright-up');
  const brightDown = document.getElementById('cursor-bright-down');
  const colorUp = document.getElementById('cursor-color-up');
  const colorDown = document.getElementById('cursor-color-down');
  const brightMidInfo = document.getElementById('brightness-midpoint-info');
  const colorMidInfo = document.getElementById('color-midpoint-info');

  const clearBtn = (btn) => {
    if (!btn) return;
    btn.style.removeProperty('--btn-bg');
    btn.style.removeProperty('--btn-text');
    btn.style.removeProperty('--btn-fill-opacity');
    btn.classList.remove('at-extreme');
  };

  if (!point) {
    [stepUp, stepDown, brightUp, brightDown, colorUp, colorDown].forEach(clearBtn);
    if (brightMidInfo) brightMidInfo.textContent = '';
    if (colorMidInfo) colorMidInfo.textContent = '';
    return;
  }

  // Determine phase (ascend = wake, descend = bed)
  const inAscend = point.phase === 'Ascend';

  // Get current runtime midpoints (always show, even if equal to base)
  const currentBriMid = runtimeState.brightness_mid ?? (inAscend ? config.wake_time : config.bed_time);
  const currentColorMid = runtimeState.color_mid ?? (inAscend ? config.wake_time : config.bed_time);

  // Show just the time next to the label
  if (brightMidInfo) {
    brightMidInfo.textContent = fmtTime(currentBriMid);
  }
  if (colorMidInfo) {
    colorMidInfo.textContent = fmtTime(currentColorMid);
  }

  // Config bounds (for step button extreme checks)
  const configMinPct = config.min_brightness;
  const configMaxPct = config.max_brightness;

  const currentPct = point.y;
  const currentCCT = point.cct;

  // Get preview values from shared functions (same logic as click handlers)
  const briPreview = getBrightnessPreview();
  const colorPreview = getColorPreview();
  const stepPreview = getStepPreview(point);

  // Helper to style a button
  const styleBtn = (btn, targetBri, targetColor, mode) => {
    if (!btn) return;

    // Brightness glow (for brightness and combo modes)
    if ((mode === 'brightness' || mode === 'combo') && Number.isFinite(targetBri)) {
      const frac = Math.max(0, Math.min(1, targetBri / 100));
      btn.style.setProperty('--btn-fill-opacity', frac.toFixed(3));
    } else {
      btn.style.removeProperty('--btn-fill-opacity');
    }

    // Color background
    if (Number.isFinite(targetColor)) {
      let color = cctToRGB(targetColor);
      if (Number.isFinite(targetBri)) {
        color = tintColorByBrightness(color, targetBri);
      }
      btn.style.setProperty('--btn-bg', color);
      btn.style.setProperty('--btn-text', readableTextColor(color));
    } else {
      btn.style.removeProperty('--btn-bg');
      btn.style.removeProperty('--btn-text');
    }
  };

  // Style buttons with preview values
  styleBtn(brightUp, briPreview.up.value, currentCCT, 'brightness');
  styleBtn(brightDown, briPreview.down.value, currentCCT, 'brightness');
  styleBtn(colorUp, null, colorPreview.up.value, 'color');
  styleBtn(colorDown, null, colorPreview.down.value, 'color');
  styleBtn(stepUp, stepPreview.upBri, stepPreview.upCCT, 'combo');
  styleBtn(stepDown, stepPreview.downBri, stepPreview.downCCT, 'combo');

  // For display
  const displayedCCT = currentCCT;

  // Use preview extreme states
  const briAtMax = briPreview.up.atExtreme;
  const briAtMin = briPreview.down.atExtreme;
  const cctAtMax = colorPreview.up.atExtreme;
  const cctAtMin = colorPreview.down.atExtreme;

  // Step buttons: at extreme based on brightness only
  const stepUpAtExtreme = currentPct >= configMaxPct - 0.5;
  const stepDownAtExtreme = currentPct <= configMinPct + 0.5;

  // Toggle at-extreme class for styling
  brightUp?.classList.toggle('at-extreme', briAtMax);
  brightDown?.classList.toggle('at-extreme', briAtMin);
  colorUp?.classList.toggle('at-extreme', cctAtMax);
  colorDown?.classList.toggle('at-extreme', cctAtMin);
  stepUp?.classList.toggle('at-extreme', stepUpAtExtreme);
  stepDown?.classList.toggle('at-extreme', stepDownAtExtreme);

  // Update button tooltips with detailed preview info
  if (brightUp) brightUp.title = briAtMax
    ? `Bright up: at max ${Math.round(currentPct)}%`
    : `Bright up ${Math.round(briPreview.up.value - currentPct)}% to ${Math.round(briPreview.up.value)}%`;
  if (brightDown) brightDown.title = briAtMin
    ? `Bright down: at min ${Math.round(currentPct)}%`
    : `Bright down ${Math.round(currentPct - briPreview.down.value)}% to ${Math.round(briPreview.down.value)}%`;
  if (colorUp) colorUp.title = cctAtMax
    ? `Color up: at max ${Math.round(displayedCCT)}K`
    : `Color up ${Math.round(colorPreview.up.value - displayedCCT)}K to ${Math.round(colorPreview.up.value)}K`;
  if (colorDown) colorDown.title = cctAtMin
    ? `Color down: at min ${Math.round(displayedCCT)}K`
    : `Color down ${Math.round(displayedCCT - colorPreview.down.value)}K to ${Math.round(colorPreview.down.value)}K`;
  if (stepUp) stepUp.title = stepUpAtExtreme
    ? `Step up: at max ${Math.round(currentPct)}% @ ${Math.round(displayedCCT)}K`
    : `Step up ${Math.round(stepPreview.upBri - currentPct)}% / ${Math.round(stepPreview.upCCT - displayedCCT)}K to ${Math.round(stepPreview.upBri)}% at ${Math.round(stepPreview.upCCT)}K`;
  if (stepDown) stepDown.title = stepDownAtExtreme
    ? `Step down: at min ${Math.round(currentPct)}% @ ${Math.round(displayedCCT)}K`
    : `Step down ${Math.round(currentPct - stepPreview.downBri)}% / ${Math.round(displayedCCT - stepPreview.downCCT)}K to ${Math.round(stepPreview.downBri)}% at ${Math.round(stepPreview.downCCT)}K`;

  // Style reset button with what values WILL be after reset (cleared runtime state)
  const resetBtn = document.getElementById('cursor-reset');
  if (resetBtn && config && cursorHour !== null) {
    const savedMidBri = runtimeState.brightness_mid;
    const savedMidColor = runtimeState.color_mid;
    const savedColorOverride = runtimeState.color_override;
    runtimeState.brightness_mid = null;
    runtimeState.color_mid = null;
    runtimeState.color_override = null;
    const h = ((cursorHour % 24) + 24) % 24;
    const resetBri = Math.round(calculateBrightnessAtHour(h) * 100);
    const resetCct = Math.round(calculateColorAtHour(h, true));
    runtimeState.brightness_mid = savedMidBri;
    runtimeState.color_mid = savedMidColor;
    runtimeState.color_override = savedColorOverride;
    styleBtn(resetBtn, resetBri, resetCct, 'combo');
    resetBtn.title = `Reset to curve: ${resetBri}% at ${resetCct}K`;
  }

  // Update time navigation button tooltips
  const timeMinusBtn = document.getElementById('cursor-time-minus');
  const timePlusBtn = document.getElementById('cursor-time-plus');

  // Helper to format hour as H:MMa/p
  const formatTime = (hour) => {
    const h = ((hour % 24) + 24) % 24;
    let hours24 = Math.floor(h);
    let mins = Math.round((h - hours24) * 60);
    if (mins === 60) { mins = 0; hours24 = (hours24 + 1) % 24; }
    const isPM = hours24 >= 12;
    let hours12 = hours24 % 12;
    if (hours12 === 0) hours12 = 12;
    return `${hours12}:${mins.toString().padStart(2, '0')}${isPM ? 'p' : 'a'}`;
  };

  if (config && cursorHour !== null) {
    const getValuesAtHour = (hour) => {
      const h = ((hour % 24) + 24) % 24;
      return {
        bri: Math.round(calculateBrightnessAtHour(h) * 100),
        cct: Math.round(calculateColorAtHour(h, true))
      };
    };

    const displayedBri = Math.round(currentPct);
    const displayedCct = Math.round(displayedCCT);

    const minusHour = cursorHour - 5/60;
    const minusVals = getValuesAtHour(minusHour);
    const minusBriDelta = minusVals.bri - displayedBri;
    const minusCctDelta = minusVals.cct - displayedCct;
    if (timeMinusBtn) {
      const briStr = minusBriDelta >= 0 ? `+${minusBriDelta}%` : `${minusBriDelta}%`;
      const cctStr = minusCctDelta >= 0 ? `+${minusCctDelta}K` : `${minusCctDelta}K`;
      timeMinusBtn.title = `5 minutes earlier, ${briStr} / ${cctStr} to ${minusVals.bri}% at ${minusVals.cct}K`;
      styleBtn(timeMinusBtn, minusVals.bri, minusVals.cct, 'combo');
    }

    const plusHour = cursorHour + 5/60;
    const plusVals = getValuesAtHour(plusHour);
    const plusBriDelta = plusVals.bri - displayedBri;
    const plusCctDelta = plusVals.cct - displayedCct;
    if (timePlusBtn) {
      const briStr = plusBriDelta >= 0 ? `+${plusBriDelta}%` : `${plusBriDelta}%`;
      const cctStr = plusCctDelta >= 0 ? `+${plusCctDelta}K` : `${plusCctDelta}K`;
      timePlusBtn.title = `5 minutes later, ${briStr} / ${cctStr} to ${plusVals.bri}% at ${plusVals.cct}K`;
      styleBtn(timePlusBtn, plusVals.bri, plusVals.cct, 'combo');
    }

    // Style Now button with current-time curve values
    const timeNowBtn = document.getElementById('cursor-time-now');
    if (timeNowBtn) {
      const now = new Date();
      const nowHour = now.getHours() + now.getMinutes() / 60;
      const nowVals = getValuesAtHour(nowHour);
      styleBtn(timeNowBtn, nowVals.bri, nowVals.cct, 'combo');
      timeNowBtn.title = `Now: ${nowVals.bri}% at ${nowVals.cct}K`;
    }
  }
}

// ============================================================
// UI Updates
// ============================================================

function updateDisplay(id, value) {
  const el = document.getElementById(id);
  if (el) el.textContent = value;
}

function positionTimelineBadges() {
  const ascendBadge = document.getElementById('ascend-start-badge');
  const descendBadge = document.getElementById('descend-start-badge');

  if (ascendBadge) {
    const pct = (config.ascend_start / 24) * 100;
    ascendBadge.style.left = `${pct}%`;
  }
  if (descendBadge) {
    const pct = (config.descend_start / 24) * 100;
    descendBadge.style.left = `${pct}%`;
  }
}

function updateSliderValue(sliderId, displayId, formatter) {
  const slider = document.getElementById(sliderId);
  if (!slider) return;
  slider.addEventListener('input', () => {
    const val = parseFloat(slider.value);
    updateDisplay(displayId, formatter(val));
    syncConfigFromUI();
    renderChart();
  });
}

// Day bubble helpers
function getSelectedDays(containerId) {
  const container = document.getElementById(containerId);
  if (!container) return [];
  return Array.from(container.querySelectorAll('.day-bubble.active'))
    .map(btn => parseInt(btn.dataset.day));
}

function setSelectedDays(containerId, days) {
  const container = document.getElementById(containerId);
  if (!container) return;
  container.querySelectorAll('.day-bubble').forEach(btn => {
    const day = parseInt(btn.dataset.day);
    btn.classList.toggle('active', days.includes(day));
  });
}

function initDayBubbles(containerId, altTimeRowId) {
  const container = document.getElementById(containerId);
  if (!container) return;
  container.querySelectorAll('.day-bubble').forEach(btn => {
    btn.addEventListener('click', () => {
      btn.classList.toggle('active');
      const row = document.getElementById(altTimeRowId);
      const anyActive = container.querySelector('.day-bubble.active');
      if (row) {
        row.classList.toggle('collapsed', !anyActive);
      }
      syncConfigFromUI();
      renderChart();
    });
  });
}

function syncConfigFromUI() {
  config.ascend_start = parseFloat(document.getElementById('ascend-start').value);
  config.descend_start = parseFloat(document.getElementById('descend-start').value) % 24;
  config.wake_time = parseFloat(document.getElementById('wake-time').value);
  config.bed_time = parseFloat(document.getElementById('bed-time').value) % 24;
  config.wake_speed = parseInt(document.getElementById('wake-speed').value);
  config.bed_speed = parseInt(document.getElementById('bed-speed').value);

  // Alt timing
  config.wake_alt_days = getSelectedDays('wake-alt-days');
  config.wake_alt_time = config.wake_alt_days.length > 0
    ? parseFloat(document.getElementById('wake-alt-time').value) % 24
    : null;
  config.bed_alt_days = getSelectedDays('bed-alt-days');
  config.bed_alt_time = config.bed_alt_days.length > 0
    ? parseFloat(document.getElementById('bed-alt-time').value) % 24
    : null;
  config.wake_brightness = parseInt(document.getElementById('wake-brightness').value);
  config.bed_brightness = parseInt(document.getElementById('bed-brightness').value);

  config.min_color_temp = parseInt(document.getElementById('color-min').value);
  config.max_color_temp = parseInt(document.getElementById('color-max').value);
  config.min_brightness = parseInt(document.getElementById('brightness-min').value);
  config.max_brightness = parseInt(document.getElementById('brightness-max').value);
  config.max_dim_steps = parseInt(document.getElementById('step-count').value);

  // Read individual increment inputs (null if empty or same as master)
  const stepInc = document.getElementById('step-increments')?.value;
  const briInc = document.getElementById('brightness-increments')?.value;
  const colorInc = document.getElementById('color-increments')?.value;
  config.step_increments = stepInc ? parseInt(stepInc) : null;
  config.brightness_increments = briInc ? parseInt(briInc) : null;
  config.color_increments = colorInc ? parseInt(colorInc) : null;

  // Constrain solar target sliders to color range (clamps values if needed)
  updateSolarTargetSliderConstraints();

  config.warm_night_enabled = document.getElementById('warm-night-enabled').checked;
  config.warm_night_mode = document.getElementById('warm-night-mode').value;
  config.warm_night_target = parseInt(document.getElementById('warm-night-target').value);
  config.warm_night_start = parseInt(document.getElementById('warm-night-start')?.value || -60);
  config.warm_night_end = parseInt(document.getElementById('warm-night-end')?.value || 60);
  config.warm_night_fade = parseInt(document.getElementById('warm-night-fade')?.value || 60);

  config.daylight_cct = parseInt(document.getElementById('daylight-cct').value);
  config.daylight_fade = parseInt(document.getElementById('daylight-fade')?.value || '60');
  config.color_sensitivity = SENSITIVITY_STEPS[parseInt(document.getElementById('color-sensitivity').value)].multiplier;
  config.brightness_sensitivity = SENSITIVITY_STEPS[parseInt(document.getElementById('brightness-sensitivity').value)].multiplier;

  resetRuntimeState();
  updateColorGradients();
  constrainWakeBedSliders();
}

function syncUIFromConfig() {
  document.getElementById('ascend-start').value = config.ascend_start;
  document.getElementById('descend-start').value = config.descend_start;

  // Update wake/bed slider constraints BEFORE setting values
  // (prevents clamping by old constraints when switching presets)
  updateWakeBedSliderConstraints();

  // Handle wake_time slider - if it's before ascend_start, add 24 for slider
  let wakeSliderVal = config.wake_time;
  if (config.wake_time < config.ascend_start) {
    wakeSliderVal = config.wake_time + 24;
  }
  document.getElementById('wake-time').value = wakeSliderVal;

  // Handle bed_time slider - if it's before descend_start, add 24 for slider
  let bedSliderVal = config.bed_time;
  if (config.bed_time < config.descend_start) {
    bedSliderVal = config.bed_time + 24;
  }
  document.getElementById('bed-time').value = bedSliderVal;

  document.getElementById('wake-speed').value = config.wake_speed;
  document.getElementById('bed-speed').value = config.bed_speed;

  // Alt timing
  setSelectedDays('wake-alt-days', config.wake_alt_days || []);
  const wakeAltDays = config.wake_alt_days || [];
  if (wakeAltDays.length > 0 && config.wake_alt_time != null) {
    let wakeAltSlider = config.wake_alt_time;
    if (config.wake_alt_time < config.ascend_start) wakeAltSlider += 24;
    document.getElementById('wake-alt-time').value = wakeAltSlider;
    document.getElementById('wake-alt-time-row').classList.remove('collapsed');
  } else {
    document.getElementById('wake-alt-time-row').classList.add('collapsed');
  }
  setSelectedDays('bed-alt-days', config.bed_alt_days || []);
  const bedAltDays = config.bed_alt_days || [];
  if (bedAltDays.length > 0 && config.bed_alt_time != null) {
    let bedAltSlider = config.bed_alt_time;
    if (config.bed_alt_time < config.descend_start) bedAltSlider += 24;
    document.getElementById('bed-alt-time').value = bedAltSlider;
    document.getElementById('bed-alt-time-row').classList.remove('collapsed');
  } else {
    document.getElementById('bed-alt-time-row').classList.add('collapsed');
  }
  document.getElementById('wake-brightness').value = config.wake_brightness || 50;
  document.getElementById('bed-brightness').value = config.bed_brightness || 50;

  document.getElementById('color-min').value = config.min_color_temp;
  document.getElementById('color-max').value = config.max_color_temp;
  document.getElementById('brightness-min').value = config.min_brightness;
  document.getElementById('brightness-max').value = config.max_brightness;
  document.getElementById('step-count').value = config.max_dim_steps;

  // Sync all increment inputs to the master Increments slider value
  const masterInc = config.max_dim_steps;
  document.getElementById('step-increments').value = masterInc;
  document.getElementById('brightness-increments').value = masterInc;
  document.getElementById('color-increments').value = masterInc;

  // Set warm night slider values FROM CONFIG BEFORE calling updateSolarTargetSliderConstraints
  document.getElementById('warm-night-enabled').checked = config.warm_night_enabled;
  document.getElementById('warm-night-mode').value = config.warm_night_mode;
  document.getElementById('warm-night-target').value = config.warm_night_target;
  const warmStart = document.getElementById('warm-night-start');
  const warmEnd = document.getElementById('warm-night-end');
  const warmFade = document.getElementById('warm-night-fade');
  if (warmStart) warmStart.value = config.warm_night_start;
  if (warmEnd) warmEnd.value = config.warm_night_end;
  if (warmFade) warmFade.value = config.warm_night_fade;

  document.getElementById('daylight-cct').value = config.daylight_cct;
  document.getElementById('color-sensitivity').value = findClosestSensitivityStep(config.color_sensitivity);
  document.getElementById('brightness-sensitivity').value = findClosestSensitivityStep(config.brightness_sensitivity);
  const daylightFade = document.getElementById('daylight-fade');
  if (daylightFade) daylightFade.value = config.daylight_fade;

  // Now update constraints (reads slider values, clamps to color range)
  updateSolarTargetSliderConstraints();

  document.getElementById('activity-preset').value = config.activity_preset || 'adult';

  updateDisplay('ascend-start-display', formatHour(config.ascend_start));
  updateDisplay('descend-start-display', formatHour(config.descend_start));
  updateDisplay('ascend-start-badge', formatHour(config.ascend_start));
  updateDisplay('descend-start-badge', formatHour(config.descend_start));
  positionTimelineBadges();
  updateDisplay('wake-time-display', formatHour(config.wake_time));
  updateDisplay('bed-time-display', formatHour(config.bed_time));
  updateDisplay('wake-alt-time-display', config.wake_alt_time != null ? formatHour(config.wake_alt_time) : '--');
  updateDisplay('bed-alt-time-display', config.bed_alt_time != null ? formatHour(config.bed_alt_time) : '--');
  const wb = config.wake_brightness || 50;
  updateDisplay('wake-brightness-display', wb === 50 ? '50% (default)' : wb + '%');
  const bb = config.bed_brightness || 50;
  updateDisplay('bed-brightness-display', bb === 50 ? '50% (default)' : bb + '%');
  updateDisplay('wake-speed-display', `${SPEED_LABELS[config.wake_speed]} (${config.wake_speed})`);
  updateDisplay('bed-speed-display', `${SPEED_LABELS[config.bed_speed]} (${config.bed_speed})`);
  updateRangeDisplays();
  updateDisplay('step-count-display', `${config.max_dim_steps} steps`);

  updateDualFills();
  updateColorGradients();
  updateOffsetDisplays();
  syncColorRuleRows();
  constrainWakeBedSliders();
}

// Update combined range displays (color temp + brightness)
function updateRangeDisplays() {
  updateDisplay('color-range-display', `${config.min_color_temp} – ${config.max_color_temp} K`);
  updateDisplay('brightness-range-display', `${config.min_brightness} – ${config.max_brightness}%`);
}

// Update offset text displays
function updateOffsetDisplays() {
  const fmtHrs = (min) => {
    const hrs = Math.abs(min) / 60;
    return hrs === 1 ? '1 hr' : `${hrs} hrs`;
  };
  const formatOffset = (val, baseEvent) => {
    if (val === 0) return `at ${baseEvent}`;
    const direction = val < 0 ? 'before' : 'after';
    return `${fmtHrs(val)} ${direction} ${baseEvent}`;
  };

  updateDisplay('warm-night-start-text', formatOffset(config.warm_night_start, 'sunset'));
  updateDisplay('warm-night-end-text', formatOffset(config.warm_night_end, 'sunrise'));
  updateDisplay('warm-night-fade-text', fmtHrs(config.warm_night_fade));
  updateDisplay('color-sensitivity-text', SENSITIVITY_STEPS[findClosestSensitivityStep(config.color_sensitivity)].label);
  updateDisplay('brightness-sensitivity-text', SENSITIVITY_STEPS[findClosestSensitivityStep(config.brightness_sensitivity)].label);
  updateDisplay('daylight-fade-text', fmtHrs(config.daylight_fade));
}

// Sync color rule rows - toggle is-disabled based on checkbox + mode state
function syncColorRuleRows() {
  const warmEnabled = config.warm_night_enabled;

  // Warm night body
  const warmBody = document.getElementById('warm-night-body');
  if (warmBody) {
    warmBody.classList.toggle('is-disabled', !warmEnabled);
    warmBody.querySelectorAll('select, input[type="range"]').forEach(el => {
      el.disabled = !warmEnabled;
    });
  }

  // Mode-based slider disabling
  // Warm night: "sunrise" → lock Start (sunset side unused), "sunset" → lock End (sunrise side unused)
  document.querySelectorAll('[data-color-row="night"] .color-rule-slider-row').forEach(row => {
    const win = row.dataset.ruleWindow;
    if (win === 'any') return;
    const mode = config.warm_night_mode;
    const locked = (mode === 'sunrise' && win === 'sunset') || (mode === 'sunset' && win === 'sunrise');
    row.classList.toggle('is-disabled', locked);
    row.querySelectorAll('input[type="range"]').forEach(el => el.disabled = !warmEnabled || locked);
  });
}

// Update wake/bed slider min/max constraints only (no value clamping)
// Called before setting slider values to prevent clamping by old constraints
function updateWakeBedSliderConstraints() {
  const wakeSlider = document.getElementById('wake-time');
  const bedSlider = document.getElementById('bed-time');
  if (!wakeSlider || !bedSlider) return;

  const ascendStart = config.ascend_start;
  let descendStart = config.descend_start;
  if (descendStart <= ascendStart) descendStart += 24;

  // Wake slider: ascend_start to descend_start
  wakeSlider.min = ascendStart;
  wakeSlider.max = descendStart;

  // Bed slider: descend_start to (descend_start + descend phase length)
  bedSlider.min = config.descend_start;
  bedSlider.max = config.descend_start + 24 - (descendStart - ascendStart);
}

// Constrain warm_night_target slider to color range
function updateSolarTargetSliderConstraints() {
  const warmSlider = document.getElementById('warm-night-target');
  if (!warmSlider) return;

  const minTemp = config.min_color_temp;
  const maxTemp = config.max_color_temp;

  warmSlider.min = minTemp;
  warmSlider.max = maxTemp;

  let warmVal = Math.max(minTemp, Math.min(maxTemp, parseInt(warmSlider.value)));
  warmSlider.value = warmVal;
  config.warm_night_target = warmVal;

  // Update track gradients to match new bounds
  updateColorGradients();
}

// Constrain wake slider to between ascend_start and descend_start
// Constrain bed slider to between descend_start and ascend_start (wrapping)
function constrainWakeBedSliders() {
  const wakeSlider = document.getElementById('wake-time');
  const bedSlider = document.getElementById('bed-time');
  if (!wakeSlider || !bedSlider) return;

  // Update constraints first
  updateWakeBedSliderConstraints();

  // Wake must be between ascend_start and descend_start
  const ascendStart = config.ascend_start;
  let descendStart = config.descend_start;
  if (descendStart <= ascendStart) descendStart += 24;

  // Clamp current value
  let wakeVal = parseFloat(wakeSlider.value);
  if (wakeVal < ascendStart) wakeVal = ascendStart;
  if (wakeVal > descendStart) wakeVal = descendStart;
  wakeSlider.value = wakeVal;
  config.wake_time = wakeVal % 24;
  updateDisplay('wake-time-display', formatHour(config.wake_time));

  // Bed: clamp to new constraints
  let bedVal = parseFloat(bedSlider.value);
  const bedMin = parseFloat(bedSlider.min);
  const bedMax = parseFloat(bedSlider.max);
  if (bedVal < bedMin) bedVal = bedMin;
  if (bedVal > bedMax) bedVal = bedMax;
  bedSlider.value = bedVal;
  config.bed_time = bedVal % 24;
  updateDisplay('bed-time-display', formatHour(config.bed_time));
}

function updateDualFills() {
  const colorMin = parseInt(document.getElementById('color-min').value);
  const colorMax = parseInt(document.getElementById('color-max').value);
  const colorFill = document.getElementById('color-fill');
  if (colorFill) {
    const left = ((colorMin - 500) / 6000) * 100;
    const right = ((colorMax - 500) / 6000) * 100;
    colorFill.style.left = `${left}%`;
    colorFill.style.width = `${right - left}%`;
  }

  const briMin = parseInt(document.getElementById('brightness-min').value);
  const briMax = parseInt(document.getElementById('brightness-max').value);
  const briMaskLeft = document.getElementById('brightness-mask-left');
  const briMaskRight = document.getElementById('brightness-mask-right');
  if (briMaskLeft && briMaskRight) {
    const leftPct = ((briMin - 1) / 99) * 100;
    const rightPct = ((briMax - 1) / 99) * 100;
    briMaskLeft.style.left = '0%';
    briMaskLeft.style.width = `${leftPct}%`;
    briMaskRight.style.left = `${rightPct}%`;
    briMaskRight.style.width = `${100 - rightPct}%`;
  }
}

function resetRuntimeState() {
  // Reset turns on circadian lighting and resets to default curve
  runtimeState.enabled = true;
  runtimeState.frozen = false;
  // Reset midpoints to follow config
  runtimeState.brightness_mid = null;
  runtimeState.color_mid = null;
  runtimeState.color_override = null;
}

// ============================================================
// Event Handlers
// ============================================================

function setupEventListeners() {
  updateSliderValue('ascend-start', 'ascend-start-display', formatHour);
  updateSliderValue('descend-start', 'descend-start-display', formatHour);
  updateSliderValue('wake-time', 'wake-time-display', formatHour);
  updateSliderValue('bed-time', 'bed-time-display', formatHour);
  updateSliderValue('wake-speed', 'wake-speed-display', v => `${SPEED_LABELS[v]} (${v})`);
  updateSliderValue('bed-speed', 'bed-speed-display', v => `${SPEED_LABELS[v]} (${v})`);

  // Alt time sliders
  updateSliderValue('wake-alt-time', 'wake-alt-time-display', formatHour);
  updateSliderValue('bed-alt-time', 'bed-alt-time-display', formatHour);

  // Brightness target sliders
  updateSliderValue('wake-brightness', 'wake-brightness-display', v => v == 50 ? '50% (default)' : v + '%');
  updateSliderValue('bed-brightness', 'bed-brightness-display', v => v == 50 ? '50% (default)' : v + '%');

  // Day bubble toggles
  initDayBubbles('wake-alt-days', 'wake-alt-time-row');
  initDayBubbles('bed-alt-days', 'bed-alt-time-row');

  // Dual-range sliders update combined display
  ['color-min', 'color-max'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('input', () => { syncConfigFromUI(); updateRangeDisplays(); renderChart(); });
  });
  ['brightness-min', 'brightness-max'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('input', () => { syncConfigFromUI(); updateRangeDisplays(); renderChart(); });
  });
  updateSliderValue('step-count', 'step-count-display', v => `${v} steps`);

  // Master increments slider syncs all hidden increment inputs
  document.getElementById('step-count')?.addEventListener('input', () => {
    const masterVal = parseInt(document.getElementById('step-count').value);
    document.getElementById('step-increments').value = masterVal;
    document.getElementById('brightness-increments').value = masterVal;
    document.getElementById('color-increments').value = masterVal;
    config.step_increments = null;
    config.brightness_increments = null;
    config.color_increments = null;
  });

  // Warm night target slider (inside popup)
  document.getElementById('warm-night-target')?.addEventListener('input', () => {
    config.warm_night_target = parseInt(document.getElementById('warm-night-target').value);
    updateSolarTargetSliderConstraints();
    renderChart();
  });
  document.getElementById('daylight-cct')?.addEventListener('input', () => {
    config.daylight_cct = parseInt(document.getElementById('daylight-cct').value);
    updateColorGradients();
    renderChart();
  });

  // Daylight sensitivity sliders + fade
  ['color-sensitivity', 'brightness-sensitivity', 'daylight-fade'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('input', () => {
        syncConfigFromUI();
        updateOffsetDisplays();
        renderChart();
      });
    }
  });

  // Warm night offset sliders
  ['warm-night-start', 'warm-night-end', 'warm-night-fade'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('input', () => {
        syncConfigFromUI();
        updateOffsetDisplays();
        renderChart();
      });
    }
  });

  ['warm-night-enabled', 'warm-night-mode'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('change', () => {
      config.warm_night_enabled = document.getElementById('warm-night-enabled').checked;
      config.warm_night_mode = document.getElementById('warm-night-mode').value;
      syncColorRuleRows();
      renderChart();
    });
  });

  // Color chip buttons - toggle popups
  document.getElementById('warm-night-target-chip')?.addEventListener('click', (e) => {
    e.stopPropagation();
    const popup = document.getElementById('warm-night-popup');
    const other = document.getElementById('daylight-cct-popup');
    if (other) other.classList.remove('is-open');
    popup?.classList.toggle('is-open');
  });
  document.getElementById('daylight-cct-chip')?.addEventListener('click', (e) => {
    e.stopPropagation();
    const popup = document.getElementById('daylight-cct-popup');
    const other = document.getElementById('warm-night-popup');
    if (other) other.classList.remove('is-open');
    popup?.classList.toggle('is-open');
  });

  // Close popups when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.color-controls-wrap')) {
      document.querySelectorAll('.color-slider-popup').forEach(p => p.classList.remove('is-open'));
    }
    // Close info tooltips when clicking outside
    if (!e.target.closest('.info-icon') && !e.target.closest('.info-tooltip')) {
      document.querySelectorAll('.info-tooltip').forEach(t => t.classList.remove('is-open'));
    }
  });

  // Info icon click handlers - toggle tooltip visibility
  document.querySelectorAll('.info-icon').forEach(icon => {
    icon.addEventListener('click', (e) => {
      e.stopPropagation();
      const tooltipId = icon.getAttribute('data-tooltip');
      const tooltip = document.getElementById(tooltipId);
      // Close other tooltips
      document.querySelectorAll('.info-tooltip').forEach(t => {
        if (t.id !== tooltipId) t.classList.remove('is-open');
      });
      tooltip?.classList.toggle('is-open');
    });
  });

  document.getElementById('activity-preset').addEventListener('change', (e) => {
    const preset = ACTIVITY_PRESETS[e.target.value];
    if (preset) {
      config.activity_preset = e.target.value;
      config.wake_time = preset.wake_time;
      config.bed_time = preset.bed_time;
      config.warm_night_enabled = preset.warm_night_enabled;
      config.daylight_cct = preset.daylight_cct;

      // Get current sun times for solar-based presets
      const { solarNoon, solarMid } = getSunTimes(config.latitude, config.longitude, getSelectedDateISO());
      const solarNoonRounded = Math.round(solarNoon);
      const solarMidRounded = Math.round(solarMid);

      // Young Child: ascend=solar midnight, descend=solar noon
      // Adult: descend=solar noon (ascend stays fixed)
      if (e.target.value === 'young') {
        config.ascend_start = solarMidRounded % 24;
        config.descend_start = solarNoonRounded % 24;
      } else if (e.target.value === 'adult') {
        config.ascend_start = preset.ascend_start;
        config.descend_start = solarNoonRounded % 24;
      } else {
        config.ascend_start = preset.ascend_start;
        config.descend_start = preset.descend_start;
      }

      resetRuntimeState();
      syncUIFromConfig();
      renderChart();
    }
  });

  document.getElementById('chart-date-slider').addEventListener('input', () => {
    renderChart();
  });

  document.getElementById('modeled-conditions').addEventListener('change', () => {
    renderChart();
  });

  // Simple mode toggle
  document.getElementById('simple-mode').addEventListener('change', (e) => {
    simpleMode = e.target.checked;
    document.querySelector('.chart-date-control').style.display = simpleMode ? 'none' : 'flex';
    document.querySelector('.time-nav-group').style.display = simpleMode ? 'none' : 'flex';
    renderChart();
  });
  // Apply initial simple mode state
  document.querySelector('.chart-date-control').style.display = simpleMode ? 'none' : 'flex';
  document.querySelector('.time-nav-group').style.display = simpleMode ? 'none' : 'flex';

  document.getElementById('cursor-step-up')?.addEventListener('click', () => stepCursor('up', true, true));
  document.getElementById('cursor-step-down')?.addEventListener('click', () => stepCursor('down', true, true));
  document.getElementById('cursor-bright-up')?.addEventListener('click', () => stepCursor('up', true, false));
  document.getElementById('cursor-bright-down')?.addEventListener('click', () => stepCursor('down', true, false));
  document.getElementById('cursor-color-up')?.addEventListener('click', () => stepCursor('up', false, true));
  document.getElementById('cursor-color-down')?.addEventListener('click', () => stepCursor('down', false, true));
  document.getElementById('cursor-reset')?.addEventListener('click', () => {
    // Reset runtime state but keep cursor position
    resetRuntimeState();
    renderChart();
    applyCursor();
  });

  // Time navigation buttons
  document.getElementById('cursor-time-now')?.addEventListener('click', () => {
    const now = new Date();
    cursorHour = now.getHours() + now.getMinutes() / 60;
    renderChart();
    applyCursor();
  });
  document.getElementById('cursor-time-plus')?.addEventListener('click', () => {
    cursorHour = (cursorHour + 5/60) % 24;  // +5 minutes, wrap at 24
    renderChart();
    applyCursor();
  });
  document.getElementById('cursor-time-minus')?.addEventListener('click', () => {
    cursorHour = (cursorHour - 5/60 + 24) % 24;  // -5 minutes, wrap at 0
    renderChart();
    applyCursor();
  });

  ['color-min', 'color-max', 'brightness-min', 'brightness-max'].forEach(id => {
    document.getElementById(id)?.addEventListener('input', updateDualFills);
  });

}

// Inverse logistic: find midpoint that gives target value at time x
function inverseMidpoint(x, targetValue, slope, y0, y1) {
  // Clamp target to avoid division issues
  const epsilon = 0.001;
  const clampedTarget = Math.max(y0 + epsilon, Math.min(y1 - epsilon, targetValue));
  const ratio = (clampedTarget - y0) / (y1 - y0);
  // midpoint = x + ln((1 - ratio) / ratio) / slope
  return x + Math.log((1 - ratio) / ratio) / slope;
}

// Get current brightness at cursor (0-100 scale) using core calculation
function getBrightnessAtCursor() {
  if (cursorHour === null || !config) return null;
  return calculateBrightnessAtHour(cursorHour) * 100;  // Convert 0-1 to 0-100
}

// Get displayed CCT at cursor (AFTER solar rules are applied) using core calculation
function getDisplayedCCTAtCursor() {
  if (cursorHour === null || !config) return null;
  return calculateColorAtHour(cursorHour, true);  // With solar rules
}

// Get current CCT value at cursor (before solar rules, from base curve) using core calculation
function getBaseCCTAtCursor() {
  if (cursorHour === null || !config) return null;
  return calculateColorAtHour(cursorHour, false);  // Without solar rules
}

function stepCursor(direction, adjustBrightness, adjustColor) {
  if (cursorHour === null) return;

  const sign = direction === 'up' ? 1 : -1;
  // Select increment based on mode
  let steps;
  if (adjustBrightness && adjustColor) {
    steps = config.step_increments ?? config.max_dim_steps ?? 10;
  } else if (adjustBrightness) {
    steps = config.brightness_increments ?? config.max_dim_steps ?? 10;
  } else {
    steps = config.color_increments ?? config.max_dim_steps ?? 10;
  }

  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;
  let h48 = cursorHour < tAscend ? cursorHour + 24 : cursorHour;
  const inAscend = h48 >= tAscend && h48 < tDescend;

  // Clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];
  const slope = inAscend ? kAscend : -kDescend;

  // For Step Up/Down: brightness-primary, traverse diverged curve
  if (adjustBrightness && adjustColor) {
    // Config bounds (only use these, no runtime overrides)
    const bMin = config.min_brightness;
    const bMax = config.max_brightness;
    const cMin = config.min_color_temp;
    const cMax = config.max_color_temp;

    // Step sizes based on config range
    const briStep = (bMax - bMin) / steps;
    const cctStep = (cMax - cMin) / steps;

    // Current values
    const currentBri = getBrightnessAtCursor();
    const currentCCT = getDisplayedCCTAtCursor();
    if (currentBri === null || currentCCT === null) return;

    const briMargin = Math.max(1.0, (bMax - bMin) * 0.01);
    const cctMargin = Math.max(10, (cMax - cMin) * 0.01);

    // Check limits per dimension
    const briAtLimit = (direction === 'up' && currentBri >= bMax - briMargin) ||
                       (direction === 'down' && currentBri <= bMin + briMargin);
    const cctAtLimit = (direction === 'up' && currentCCT >= cMax - cctMargin) ||
                       (direction === 'down' && currentCCT <= cMin + cctMargin);

    if (briAtLimit && cctAtLimit) return; // Both at limit

    // Step each dimension independently, skip ones at limit
    let targetBri = briAtLimit ? currentBri : currentBri + sign * briStep;
    let targetCCT = cctAtLimit ? currentCCT : currentCCT + sign * cctStep;

    // Clamp
    targetBri = Math.max(bMin, Math.min(bMax, targetBri));
    targetCCT = Math.max(cMin, Math.min(cMax, targetCCT));

    // Calculate midpoints (only for dimensions that moved)
    const bMinNorm = bMin / 100;
    const bMaxNorm = bMax / 100;
    const targetBriNorm = Math.max(bMinNorm + 0.001, Math.min(bMaxNorm - 0.001, targetBri / 100));
    const targetCCTNorm = Math.max(0.001, Math.min(0.999, (targetCCT - cMin) / (cMax - cMin)));

    let calcTime = h48;
    if (!inAscend && h48 < tDescend) calcTime = h48 + 24;

    if (!briAtLimit) {
      runtimeState.brightness_mid = inverseMidpoint(calcTime, targetBriNorm, slope, bMinNorm, bMaxNorm);
    }
    if (!cctAtLimit) {
      runtimeState.color_mid = inverseMidpoint(calcTime, targetCCTNorm, slope, 0, 1);
    }

    renderChart();
    applyCursor();
    return;
  }

  // Brightness only: fixed value increments
  if (adjustBrightness && !adjustColor) {
    // Config bounds (only use these, no runtime overrides)
    const bMin = config.min_brightness;
    const bMax = config.max_brightness;
    const briStep = (bMax - bMin) / steps;

    const currentBri = getBrightnessAtCursor();
    if (currentBri === null) return;

    // Check if at config bounds
    const atMax = direction === 'up' && currentBri >= bMax - 0.5;
    const atMin = direction === 'down' && currentBri <= bMin + 0.5;

    if (atMax || atMin) {
      return; // At config bound, can't go further
    }

    // Calculate target
    let targetBri = currentBri + sign * briStep;

    // Clamp to config bounds
    targetBri = Math.max(bMin, Math.min(bMax, targetBri));

    // Reverse-solve midpoint
    const targetNorm = targetBri / 100;
    const bMinNorm = bMin / 100;
    const bMaxNorm = bMax / 100;

    let calcTime = h48;
    if (!inAscend && h48 < tDescend) calcTime = h48 + 24;

    const newMid = inverseMidpoint(calcTime, targetNorm, slope, bMinNorm, bMaxNorm);

    runtimeState.brightness_mid = newMid;
  }

  // Color only: step NATURAL curve, set color_override when solar rules clamp
  if (adjustColor && !adjustBrightness) {
    // Config bounds (only use these, no runtime overrides)
    const cMin = config.min_color_temp;
    const cMax = config.max_color_temp;
    const cctStep = (cMax - cMin) / steps;
    const safeMargin = Math.max(10, (cMax - cMin) * 0.01);

    // Get NATURAL CCT (before solar rules) for stepping/midpoint
    const naturalCCT = getBaseCCTAtCursor();
    // Get RENDERED CCT (after solar rules) for clamping detection
    const renderedCCT = getDisplayedCCTAtCursor();
    if (naturalCCT === null || renderedCCT === null) return;

    // Check if NATURAL curve is at config bounds
    const atMax = direction === 'up' && naturalCCT >= cMax - safeMargin;
    const atMin = direction === 'down' && naturalCCT <= cMin + safeMargin;

    if (atMax || atMin) return;

    // Step the NATURAL curve
    let targetNaturalCCT = naturalCCT + sign * cctStep;
    targetNaturalCCT = Math.max(cMin + safeMargin, Math.min(cMax - safeMargin, targetNaturalCCT));

    if (Math.abs(targetNaturalCCT - naturalCCT) < safeMargin) return;

    // Detect solar rule clamping and accumulate color_override
    const isClamped = Math.abs(renderedCCT - naturalCCT) > 1.0;
    if (isClamped) {
      // WarmNight: rendered < natural (ceiling), user stepping up (cooler)
      if (renderedCCT < naturalCCT && direction === 'up') {
        runtimeState.color_override = (runtimeState.color_override || 0) + cctStep;
      }
      // CoolDay: rendered > natural (floor), user stepping down (warmer)
      else if (renderedCCT > naturalCCT && direction === 'down') {
        runtimeState.color_override = (runtimeState.color_override || 0) - cctStep;
      }
    }

    // Calculate new midpoint from NATURAL target
    const targetNorm = Math.max(0.001, Math.min(0.999, (targetNaturalCCT - cMin) / (cMax - cMin)));

    let calcTime = h48;
    if (!inAscend && h48 < tDescend) calcTime = h48 + 24;

    runtimeState.color_mid = inverseMidpoint(calcTime, targetNorm, slope, 0, 1);
  }

  renderChart();
  applyCursor();
}

// ============================================================
// API Communication
// ============================================================

async function loadConfig() {
  try {
    const resp = await fetch('./api/config');
    if (resp.ok) {
      const data = await resp.json();
      Object.assign(config, data);
      resetRuntimeState();
      syncUIFromConfig();
      renderChart();
    }
  } catch (err) {
    console.error('Error loading config:', err);
  }
}

async function saveConfig() {
  const statusEl = document.getElementById('save-status');
  try {
    // Build structured save data: rhythm settings go inside circadian_rhythms[selectedRhythmName]
    // so the server saves them to the correct rhythm (not always the first one).
    const RHYTHM_KEYS = new Set([
      'color_mode', 'min_color_temp', 'max_color_temp',
      'min_brightness', 'max_brightness',
      'ascend_start', 'descend_start', 'wake_time', 'bed_time',
      'wake_speed', 'bed_speed',
      'warm_night_enabled', 'warm_night_mode', 'warm_night_target',
      'warm_night_start', 'warm_night_end', 'warm_night_fade',
      'daylight_cct', 'daylight_fade', 'color_sensitivity', 'brightness_sensitivity',
      'activity_preset', 'max_dim_steps',
    ]);
    const rhythmSettings = {};
    const globalSettings = {};
    for (const [key, value] of Object.entries(config)) {
      if (key === 'circadian_rhythms' || key === 'glozones') continue;
      if (RHYTHM_KEYS.has(key)) {
        rhythmSettings[key] = value;
      } else {
        globalSettings[key] = value;
      }
    }
    const saveData = {
      ...globalSettings,
      circadian_rhythms: { [selectedRhythmName]: rhythmSettings },
    };
    const resp = await fetch('./api/config', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(saveData)
    });

    if (resp.ok) {
      const result = await resp.json();
      if (result.refreshed) {
        statusEl.innerHTML = '<div class="success">Saved and refreshing lights...</div>';
      } else {
        statusEl.innerHTML = '<div class="success">Configuration saved!</div>';
      }
    } else {
      statusEl.innerHTML = '<div class="error">Failed to save configuration</div>';
    }
  } catch (err) {
    statusEl.innerHTML = '<div class="error">Error saving configuration: ' + err.message + '</div>';
  }

  setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
}

// ============================================================
// Live Design Functions
// ============================================================

/**
 * Load areas from Home Assistant and populate the dropdown.
 */
async function loadLiveDesignAreas() {
  const select = document.getElementById('live-area-select');
  if (!select) return;

  console.log('[Live Design] Loading areas...');

  try {
    const response = await fetch('./api/areas');
    console.log('[Live Design] API response status:', response.status);

    if (!response.ok) {
      const text = await response.text();
      console.warn('[Live Design] Failed to load areas:', response.status, text);
      return;
    }
    const areas = await response.json();
    console.log('[Live Design] Received areas:', areas);

    if (!Array.isArray(areas) || areas.length === 0) {
      console.warn('[Live Design] No areas returned or invalid response');
      return;
    }

    // Clear existing options except the placeholder
    while (select.options.length > 1) {
      select.remove(1);
    }

    // Add area options
    areas.forEach(area => {
      const option = document.createElement('option');
      option.value = area.area_id;
      option.textContent = area.name;
      select.appendChild(option);
    });
    console.log('[Live Design] Added', areas.length, 'areas to dropdown');
  } catch (err) {
    console.error('[Live Design] Error loading areas:', err);
  }
}

/**
 * Get the brightness and color temperature at the current cursor position.
 * @returns {Object|null} {brightness, colorTemp} or null if cursor not set
 */
function getCursorLightValues() {
  if (cursorHour === null || !config) return null;

  // Use core calculation functions for exact values (consistent with brain.py)
  return {
    brightness: calculateBrightnessAtHour(cursorHour) * 100,  // Convert 0-1 to 0-100
    colorTemp: calculateColorAtHour(cursorHour, true)         // With solar rules
  };
}

/**
 * Apply the current cursor lighting values to the selected area.
 */
async function applyLiveLight() {
  console.log('[Live Design] applyLiveLight called, enabled=', liveDesignEnabled, 'areaId=', liveDesignAreaId);
  if (!liveDesignEnabled || !liveDesignAreaId) {
    console.log('[Live Design] Skipping - not enabled or no area selected');
    return;
  }

  const values = getCursorLightValues();
  console.log('[Live Design] Cursor values:', values);
  if (!values) {
    console.log('[Live Design] No cursor values available');
    return;
  }

  const statusEl = document.getElementById('live-design-status');

  // Use 2-second transition on first apply after entering, then default 0.3s
  const transition = liveDesignFirstApply ? 2 : 0.3;
  if (liveDesignFirstApply) {
    liveDesignFirstApply = false;
    console.log('[Live Design] First apply - using 2s transition');
  }

  console.log('[Live Design] Sending to API:', {
    area_id: liveDesignAreaId,
    brightness: Math.round(values.brightness),
    color_temp: Math.round(values.colorTemp),
    transition
  });

  try {
    const response = await fetch('./api/apply-light', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        area_id: liveDesignAreaId,
        brightness: Math.round(values.brightness),
        color_temp: Math.round(values.colorTemp),
        transition
      })
    });

    if (response.ok) {
      if (statusEl) {
        statusEl.textContent = 'Live!';
        statusEl.classList.add('active', 'live-blink');
      }
    } else {
      console.warn('Failed to apply light:', response.status);
      if (statusEl) {
        statusEl.textContent = 'Error';
        statusEl.classList.remove('active', 'live-blink');
      }
    }
  } catch (err) {
    console.error('Error applying live light:', err);
    if (statusEl) {
      statusEl.textContent = 'Error';
      statusEl.classList.remove('active', 'live-blink');
    }
  }
}

/**
 * Enable or disable Circadian mode for an area via API.
 */
async function setCircadianMode(areaId, enabled) {
  if (!areaId) return;

  try {
    const response = await fetch('./api/circadian-mode', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ area_id: areaId, enabled })
    });

    if (response.ok) {
      console.log(`[Live Design] Circadian mode ${enabled ? 'enabled' : 'disabled'} for ${areaId}`);
    } else {
      console.warn('[Live Design] Failed to set circadian mode:', response.status);
    }
  } catch (err) {
    console.error('[Live Design] Error setting circadian mode:', err);
  }
}

/**
 * Set up Live Design event listeners.
 * - Selecting an area auto-enables Live Design
 * - Pause button pauses/resumes (restoring lights on pause)
 */
function setupLiveDesign() {
  const toggleBtn = document.getElementById('live-design-toggle');
  const areaSelect = document.getElementById('live-area-select');
  const statusEl = document.getElementById('live-design-status');

  if (toggleBtn) {
    toggleBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      if (!liveDesignAreaId) return;

      liveDesignEnabled = !liveDesignEnabled;
      toggleBtn.textContent = liveDesignEnabled ? 'Pause' : 'Resume';

      // Disable/enable Circadian mode for the area
      if (liveDesignEnabled) {
        // Disable Circadian so periodic updates don't override Live Design
        await setCircadianMode(liveDesignAreaId, false);
        if (statusEl) {
          statusEl.textContent = 'starting Live Design';
          statusEl.classList.remove('live-blink');
          statusEl.classList.add('active');
        }
        // Apply current cursor position with 3s transition
        liveDesignFirstApply = true;
        if (cursorHour !== null) {
          applyLiveLight();
        }
        // Update status after transition
        setTimeout(() => {
          if (liveDesignEnabled && statusEl) {
            statusEl.textContent = 'Live!';
            statusEl.classList.add('live-blink');
          }
        }, 2500);
      } else {
        // Re-enable Circadian when pausing (this restores lights via backend)
        if (statusEl) {
          statusEl.textContent = 'Paused';
          statusEl.classList.remove('active', 'live-blink');
        }
        await setCircadianMode(liveDesignAreaId, true);
      }
    });
  }

  if (areaSelect) {
    areaSelect.addEventListener('change', async (e) => {
      const oldAreaId = liveDesignAreaId;
      const newAreaId = e.target.value || null;

      // If we had an active Live Design, end it for the old area
      if (liveDesignEnabled && oldAreaId) {
        if (statusEl) {
          statusEl.textContent = 'Exiting...';
        }
        await setCircadianMode(oldAreaId, true);
      }

      liveDesignAreaId = newAreaId;

      if (newAreaId) {
        // Auto-enable Live Design when area is selected
        liveDesignEnabled = true;
        toggleBtn.style.display = '';
        toggleBtn.textContent = 'Pause';
        if (statusEl) {
          statusEl.textContent = 'starting Live Design';
          statusEl.classList.remove('live-blink');
          statusEl.classList.add('active');
        }
        await setCircadianMode(newAreaId, false);
        // Apply current cursor position if set with 3s transition
        liveDesignFirstApply = true;
        if (cursorHour !== null) {
          applyLiveLight();
        }
        // Update status after transition
        setTimeout(() => {
          if (liveDesignEnabled && statusEl) {
            statusEl.textContent = 'Live!';
            statusEl.classList.add('live-blink');
          }
        }, 2500);
      } else {
        // No area selected - hide button and reset state
        liveDesignEnabled = false;
        toggleBtn.style.display = 'none';
        if (statusEl) {
          statusEl.textContent = '';
          statusEl.classList.remove('active', 'live-blink');
        }
      }
    });
  }

  // Load areas from HA
  loadLiveDesignAreas();
}

// ============================================================
// Initialize
// ============================================================
// GloZone Management
// ============================================================

let glozonesData = {};
let rhythmsData = {};
let selectedZone = null;
let allAreas = [];
let modalMode = null; // 'create-zone', 'create-rhythm', 'edit-zone', 'edit-rhythm'
let modalTarget = null;

/**
 * Fetch GloZones from API
 */
async function fetchGlozones() {
  try {
    const response = await fetch('./api/glozones');
    if (response.ok) {
      const data = await response.json();
      glozonesData = data.zones || {};
      renderZonesList();
    }
  } catch (err) {
    console.error('Error fetching glozones:', err);
  }
}

/**
 * Fetch Circadian Presets from API
 */
async function fetchPresets() {
  try {
    const response = await fetch('./api/circadian-rhythms');
    if (response.ok) {
      const data = await response.json();
      rhythmsData = data.rhythms || {};
      renderPresetsList();
      populatePresetSelects();
    }
  } catch (err) {
    console.error('Error fetching rhythms:', err);
  }
}

/**
 * Fetch all areas from API
 */
async function fetchAllAreas() {
  try {
    const response = await fetch('./api/areas');
    if (response.ok) {
      allAreas = await response.json();
      console.log('[GloZone] Loaded', allAreas.length, 'areas');
    }
  } catch (err) {
    console.error('Error fetching areas:', err);
  }
}

/**
 * Render zones list
 */
function renderZonesList() {
  const container = document.getElementById('zones-list');
  if (!container) return;

  const zoneNames = Object.keys(glozonesData);
  if (zoneNames.length === 0) {
    container.innerHTML = '<div class="glozone-empty">No Glo Zones configured. Add a Glo Zone to get started.</div>';
    return;
  }

  container.innerHTML = zoneNames.map(zoneName => {
    const zone = glozonesData[zoneName];
    const areaCount = (zone.areas || []).length;
    const isDefault = zone.is_default === true;
    const isLastZone = zoneNames.length === 1;
    return `
      <div class="glozone-item ${selectedZone === zoneName ? 'selected' : ''}" data-zone="${zoneName}">
        <div class="glozone-item-info">
          <span class="glozone-item-name">${zoneName}${isDefault ? ' ⭐' : ''}</span>
          <span class="glozone-item-meta">${zone.rhythm || 'Daily Rhythm 1'} &bull; ${areaCount} area${areaCount !== 1 ? 's' : ''}</span>
        </div>
        <div class="glozone-item-actions">
          <button class="edit" data-zone="${zoneName}">Edit</button>
          ${!isLastZone ? `<button class="delete" data-zone="${zoneName}">Delete</button>` : ''}
        </div>
      </div>
    `;
  }).join('');

  // Event listeners for zone items
  container.querySelectorAll('.glozone-item').forEach(item => {
    item.addEventListener('click', (e) => {
      if (e.target.tagName === 'BUTTON') return;
      selectZone(item.dataset.zone);
    });
  });

  container.querySelectorAll('.edit').forEach(btn => {
    btn.addEventListener('click', () => selectZone(btn.dataset.zone));
  });

  container.querySelectorAll('.delete').forEach(btn => {
    btn.addEventListener('click', () => deleteZone(btn.dataset.zone));
  });
}

/**
 * Render rhythms list
 */
function renderPresetsList() {
  const container = document.getElementById('rhythms-list');
  if (!container) return;

  const rhythmNames = Object.keys(rhythmsData);
  if (rhythmNames.length === 0) {
    container.innerHTML = '<div class="glozone-empty">No Glos configured.</div>';
    return;
  }

  container.innerHTML = rhythmNames.map(rhythmName => {
    const isDefault = rhythmName === 'Daily Rhythm 1';
    // Count zones using this rhythm
    const zonesUsing = Object.entries(glozonesData).filter(([_, z]) => z.rhythm === rhythmName).length;
    return `
      <div class="glozone-item" data-rhythm="${rhythmName}">
        <div class="glozone-item-info">
          <span class="glozone-item-name">${rhythmName}</span>
          <span class="glozone-item-meta">Used by ${zonesUsing} Glo Zone${zonesUsing !== 1 ? 's' : ''}</span>
        </div>
        <div class="glozone-item-actions">
          ${!isDefault ? `<button class="rename" data-rhythm="${rhythmName}">Rename</button>` : ''}
          ${!isDefault ? `<button class="delete" data-rhythm="${rhythmName}">Delete</button>` : ''}
        </div>
      </div>
    `;
  }).join('');

  container.querySelectorAll('.rename').forEach(btn => {
    btn.addEventListener('click', () => showModal('rename-rhythm', btn.dataset.rhythm));
  });

  container.querySelectorAll('.delete').forEach(btn => {
    btn.addEventListener('click', () => deleteRhythm(btn.dataset.rhythm));
  });
}

/**
 * Populate rhythm select dropdowns
 */
function populatePresetSelects() {
  const selects = [
    document.getElementById('zone-rhythm-select'),
    document.getElementById('modal-rhythm-select')
  ];

  const rhythmNames = Object.keys(rhythmsData);
  const options = rhythmNames.map(name => `<option value="${name}">${name}</option>`).join('');

  selects.forEach(select => {
    if (select) select.innerHTML = options;
  });
}

/**
 * Select a zone and show details
 */
function selectZone(zoneName) {
  selectedZone = zoneName;
  renderZonesList();
  showZoneDetail(zoneName);
}

/**
 * Setup drag and drop for area management
 */
function setupDragAndDrop(container, zoneName, dropType) {
  // Drag start
  container.addEventListener('dragstart', (e) => {
    const chip = e.target.closest('.area-chip');
    if (chip) {
      chip.classList.add('dragging');
      e.dataTransfer.setData('text/plain', JSON.stringify({
        areaId: chip.dataset.area,
        sourceZone: chip.dataset.zone || null
      }));
      e.dataTransfer.effectAllowed = 'move';
    }
  });

  // Drag end
  container.addEventListener('dragend', (e) => {
    const chip = e.target.closest('.area-chip');
    if (chip) {
      chip.classList.remove('dragging');
    }
  });

  // Drag over (allow drop)
  container.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    container.classList.add('drag-over');
  });

  // Drag leave
  container.addEventListener('dragleave', (e) => {
    if (!container.contains(e.relatedTarget)) {
      container.classList.remove('drag-over');
    }
  });

  // Drop
  container.addEventListener('drop', async (e) => {
    e.preventDefault();
    container.classList.remove('drag-over');

    try {
      const data = JSON.parse(e.dataTransfer.getData('text/plain'));
      const { areaId, sourceZone } = data;

      if (dropType === 'zone') {
        // Dropping into the zone's area list - add to zone
        if (sourceZone !== zoneName) {
          console.log('[GloZone] Drag: Adding area', areaId, 'to zone', zoneName);
          await addAreaToZone(zoneName, areaId);
        }
      } else if (dropType === 'available') {
        // Dropping into available areas - remove from zone
        if (sourceZone === zoneName) {
          console.log('[GloZone] Drag: Removing area', areaId, 'from zone', zoneName);
          await removeAreaFromZone(zoneName, areaId);
        }
      }
    } catch (err) {
      console.error('[GloZone] Drop error:', err);
    }
  });
}

/**
 * Show zone detail panel
 */
function showZoneDetail(zoneName) {
  const detail = document.getElementById('zone-detail');
  const title = document.getElementById('zone-detail-title');
  const rhythmSelect = document.getElementById('zone-rhythm-select');
  const zoneAreas = document.getElementById('zone-areas');
  const availableAreas = document.getElementById('available-areas');
  const setDefaultBtn = document.getElementById('zone-set-default-btn');

  if (!detail || !zoneName) {
    if (detail) detail.style.display = 'none';
    return;
  }

  const zone = glozonesData[zoneName];
  if (!zone) return;

  detail.style.display = 'block';
  title.textContent = zoneName + (zone.is_default ? ' ⭐' : '');
  rhythmSelect.value = zone.rhythm || 'Daily Rhythm 1';

  // Show/hide "Set as Default" button
  if (setDefaultBtn) {
    setDefaultBtn.style.display = zone.is_default ? 'none' : 'block';
    setDefaultBtn.onclick = () => setZoneAsDefault(zoneName);
  }

  // Render areas in this zone (draggable)
  const zoneAreaIds = (zone.areas || []).map(a => typeof a === 'string' ? a : a.id);
  zoneAreas.innerHTML = zoneAreaIds.length === 0
    ? '<span class="glozone-item-meta">No areas assigned - drag areas here</span>'
    : zoneAreaIds.map(areaId => {
        const areaInfo = (zone.areas || []).find(a => (typeof a === 'string' ? a : a.id) === areaId);
        const areaName = typeof areaInfo === 'object' ? areaInfo.name : areaId;
        return `<span class="area-chip" draggable="true" data-area="${areaId}" data-zone="${zoneName}">${areaName}<span class="remove" data-area="${areaId}">&times;</span></span>`;
      }).join('');
  zoneAreas.classList.add('drop-zone');

  // Render available areas (draggable, not in this zone)
  const availableForZone = allAreas.filter(a => !zoneAreaIds.includes(a.area_id));

  availableAreas.innerHTML = availableForZone.length === 0
    ? '<span class="glozone-item-meta">All areas assigned to this zone</span>'
    : availableForZone.map(area => `<span class="area-chip unassigned" draggable="true" data-area="${area.area_id}">${area.name || area.area_id}</span>`).join('');
  availableAreas.classList.add('drop-zone');

  // Event delegation for remove buttons (using event delegation for reliability)
  zoneAreas.onclick = (e) => {
    const removeBtn = e.target.closest('.remove');
    if (removeBtn) {
      e.preventDefault();
      e.stopPropagation();
      const areaId = removeBtn.dataset.area;
      console.log('[GloZone] Remove button clicked for area:', areaId);
      removeAreaFromZone(zoneName, areaId);
    }
  };

  // Click to add available areas
  availableAreas.onclick = (e) => {
    const chip = e.target.closest('.area-chip.unassigned');
    if (chip) {
      addAreaToZone(zoneName, chip.dataset.area);
    }
  };

  // Drag and drop handlers for zone areas
  setupDragAndDrop(zoneAreas, zoneName, 'zone');
  setupDragAndDrop(availableAreas, zoneName, 'available');

  // Preset change listener
  rhythmSelect.onchange = () => updateZoneRhythm(zoneName, rhythmSelect.value);
}

/**
 * Add area to zone via API
 */
async function addAreaToZone(zoneName, areaId) {
  const area = allAreas.find(a => a.area_id === areaId);
  try {
    const response = await fetch(`./api/glozones/${encodeURIComponent(zoneName)}/areas`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ area_id: areaId, area_name: area?.name || areaId })
    });
    if (response.ok) {
      await fetchGlozones();
      showZoneDetail(zoneName);
    }
  } catch (err) {
    console.error('Error adding area to zone:', err);
  }
}

/**
 * Remove area from zone via API
 */
async function removeAreaFromZone(zoneName, areaId) {
  console.log('[GloZone] Removing area:', areaId, 'from zone:', zoneName);
  try {
    const response = await fetch(`./api/glozones/${encodeURIComponent(zoneName)}/areas/${encodeURIComponent(areaId)}`, {
      method: 'DELETE'
    });
    if (response.ok) {
      console.log('[GloZone] Area removed successfully');
      await fetchGlozones();
      showZoneDetail(zoneName);
    } else {
      const data = await response.json();
      console.error('[GloZone] Failed to remove area:', data.error);
      alert(data.error || 'Failed to remove area from zone');
    }
  } catch (err) {
    console.error('Error removing area from zone:', err);
  }
}

/**
 * Update zone rhythm via API
 */
async function updateZoneRhythm(zoneName, rhythm) {
  try {
    const response = await fetch(`./api/glozones/${encodeURIComponent(zoneName)}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ rhythm })
    });
    if (response.ok) {
      await fetchGlozones();
    }
  } catch (err) {
    console.error('Error updating zone rhythm:', err);
  }
}

/**
 * Delete a zone via API
 */
async function deleteZone(zoneName) {
  if (!confirm(`Delete Glo Zone "${zoneName}"? Areas will be moved to the default zone.`)) return;

  try {
    const response = await fetch(`./api/glozones/${encodeURIComponent(zoneName)}`, {
      method: 'DELETE'
    });
    if (response.ok) {
      if (selectedZone === zoneName) {
        selectedZone = null;
        document.getElementById('zone-detail').style.display = 'none';
      }
      await fetchGlozones();
    }
  } catch (err) {
    console.error('Error deleting zone:', err);
  }
}

/**
 * Set a zone as the default zone via API
 */
async function setZoneAsDefault(zoneName) {
  try {
    const response = await fetch(`./api/glozones/${encodeURIComponent(zoneName)}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ is_default: true })
    });
    if (response.ok) {
      await fetchGlozones();
      // Re-select the zone to update the detail view
      if (selectedZone === zoneName) {
        showZoneDetail(zoneName);
      }
    }
  } catch (err) {
    console.error('Error setting default zone:', err);
  }
}

/**
 * Delete a preset via API
 */
async function deleteRhythm(rhythmName) {
  if (!confirm(`Delete rhythm "${rhythmName}"? Zones using it will need reassignment.`)) return;

  try {
    const response = await fetch(`./api/circadian-rhythms/${encodeURIComponent(rhythmName)}`, {
      method: 'DELETE'
    });
    if (response.ok) {
      await fetchPresets();
      await fetchGlozones();
    }
  } catch (err) {
    console.error('Error deleting rhythm:', err);
  }
}

/**
 * Show modal for creating or renaming zone/preset
 */
function showModal(mode, target = null) {
  modalMode = mode;
  modalTarget = target;

  const overlay = document.getElementById('glozone-modal');
  const title = document.getElementById('modal-title');
  const nameInput = document.getElementById('modal-name-input');
  const rhythmRow = document.getElementById('modal-rhythm-row');
  const confirmBtn = document.getElementById('modal-confirm');

  nameInput.value = '';

  if (mode === 'create-zone') {
    title.textContent = 'Create Glo Zone';
    rhythmRow.style.display = 'flex';
    confirmBtn.textContent = 'Create';
  } else if (mode === 'create-rhythm') {
    title.textContent = 'Create Glo';
    rhythmRow.style.display = 'none';
    confirmBtn.textContent = 'Create';
  } else if (mode === 'rename-zone') {
    title.textContent = 'Rename Glo Zone';
    nameInput.value = target || '';
    rhythmRow.style.display = 'none';
    confirmBtn.textContent = 'Rename';
  } else if (mode === 'rename-rhythm') {
    title.textContent = 'Rename Glo';
    nameInput.value = target || '';
    rhythmRow.style.display = 'none';
    confirmBtn.textContent = 'Rename';
  }

  overlay.classList.add('visible');
  nameInput.focus();
}

/**
 * Hide modal
 */
function hideModal() {
  document.getElementById('glozone-modal').classList.remove('visible');
  modalMode = null;
  modalTarget = null;
}

/**
 * Handle modal confirm
 */
async function handleModalConfirm() {
  const nameInput = document.getElementById('modal-name-input');
  const rhythmSelect = document.getElementById('modal-rhythm-select');
  const name = nameInput.value.trim();

  if (!name) {
    alert('Please enter a name');
    return;
  }

  if (modalMode === 'create-zone') {
    try {
      const response = await fetch('./api/glozones', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, rhythm: rhythmSelect.value })
      });
      if (response.ok) {
        hideModal();
        await fetchGlozones();
        selectZone(name);
      } else {
        const data = await response.json();
        alert(data.error || 'Failed to create Glo Zone');
      }
    } catch (err) {
      console.error('Error creating Glo Zone:', err);
    }
  } else if (modalMode === 'create-rhythm') {
    try {
      const response = await fetch('./api/circadian-rhythms', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name, settings: {} })
      });
      if (response.ok) {
        hideModal();
        await fetchPresets();
      } else {
        const data = await response.json();
        alert(data.error || 'Failed to create Glo');
      }
    } catch (err) {
      console.error('Error creating Glo:', err);
    }
  } else if (modalMode === 'rename-zone') {
    if (name === modalTarget) {
      hideModal();
      return;
    }
    try {
      const response = await fetch(`./api/glozones/${encodeURIComponent(modalTarget)}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name })
      });
      if (response.ok) {
        hideModal();
        await fetchGlozones();
        selectZone(name);
      } else {
        const data = await response.json();
        alert(data.error || 'Failed to rename Glo Zone');
      }
    } catch (err) {
      console.error('Error renaming Glo Zone:', err);
    }
  } else if (modalMode === 'rename-rhythm') {
    if (name === modalTarget) {
      hideModal();
      return;
    }
    try {
      const response = await fetch(`./api/circadian-rhythms/${encodeURIComponent(modalTarget)}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name })
      });
      if (response.ok) {
        hideModal();
        await fetchPresets();
        await fetchGlozones(); // Refresh zones to show updated rhythm names
      } else {
        const data = await response.json();
        alert(data.error || 'Failed to rename Glo');
      }
    } catch (err) {
      console.error('Error renaming Glo:', err);
    }
  }
}

/**
 * Setup GloZone UI event listeners
 */
function setupGlozoneUI() {
  // Tab switching
  document.querySelectorAll('.glozone-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.glozone-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.glozone-content').forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      document.getElementById(`${tab.dataset.tab}-content`).classList.add('active');

      // Hide zone detail when switching tabs
      if (tab.dataset.tab === 'rhythms') {
        document.getElementById('zone-detail').style.display = 'none';
      }
    });
  });

  // Add buttons
  document.getElementById('add-zone-btn')?.addEventListener('click', () => showModal('create-zone'));
  document.getElementById('add-rhythm-btn')?.addEventListener('click', () => showModal('create-rhythm'));

  // Zone rename button
  document.getElementById('zone-rename-btn')?.addEventListener('click', () => {
    if (selectedZone) showModal('rename-zone', selectedZone);
  });

  // Modal buttons
  document.getElementById('modal-cancel')?.addEventListener('click', hideModal);
  document.getElementById('modal-confirm')?.addEventListener('click', handleModalConfirm);

  // Close modal on overlay click
  document.getElementById('glozone-modal')?.addEventListener('click', (e) => {
    if (e.target.classList.contains('glozone-modal-overlay')) hideModal();
  });

  // Load data
  fetchAllAreas();
  fetchPresets();
  fetchGlozones();
}

// ============================================================
// Rhythm Loading & Saving
// ============================================================

let selectedRhythmName = 'Daily Rhythm 1';

/**
 * Get rhythm name from URL path (e.g., /rhythm/MyRhythm)
 */
function getRhythmNameFromUrl() {
  const path = window.location.pathname;
  const match = path.match(/\/rhythm\/([^/]+)$/);
  if (match) {
    return decodeURIComponent(match[1]);
  }
  return null;
}

/**
 * Load rhythm settings from URL
 */
async function loadRhythmFromUrl() {
  const rhythmName = getRhythmNameFromUrl();
  if (!rhythmName) {
    // No rhythm in URL - redirect to list page
    const path = window.location.pathname;
    const base = path.replace(/\/rhythm\/[^/]*\/?$/, '').replace(/\/rhythm\/?$/, '');
    window.location.href = (base || '.') + '/rhythm';
    return;
  }

  selectedRhythmName = rhythmName;

  // Set name input
  const nameInput = document.getElementById('rhythm-name');
  if (nameInput) nameInput.value = rhythmName;

  try {
    const response = await fetch('./api/circadian-rhythms');
    if (response.ok) {
      const data = await response.json();
      const rhythms = data.rhythms || {};
      const settings = rhythms[rhythmName] || {};

      // Merge rhythm settings into config object
      Object.assign(config, settings);

      resetRuntimeState();
      syncUIFromConfig();
      renderChart();
    }
  } catch (err) {
    console.error('Error loading rhythm:', err);
  }
}

/**
 * Save current settings to the selected rhythm
 */
async function saveRhythmSettings() {
  const statusEl = document.getElementById('save-status');
  const newName = document.getElementById('rhythm-name')?.value.trim();

  if (!newName) {
    statusEl.innerHTML = '<div class="error">Name cannot be empty</div>';
    setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
    return;
  }

  const rhythmSettings = {
    wake_time: config.wake_time,
    bed_time: config.bed_time,
    wake_speed: config.wake_speed,
    bed_speed: config.bed_speed,
    ascend_start: config.ascend_start,
    descend_start: config.descend_start,
    min_brightness: config.min_brightness,
    max_brightness: config.max_brightness,
    min_color_temp: config.min_color_temp,
    max_color_temp: config.max_color_temp,
    color_mode: config.color_mode,
    warm_night_enabled: config.warm_night_enabled,
    warm_night_mode: config.warm_night_mode,
    warm_night_target: config.warm_night_target,
    warm_night_start: config.warm_night_start,
    warm_night_end: config.warm_night_end,
    warm_night_fade: config.warm_night_fade,
    daylight_cct: config.daylight_cct,
    daylight_fade: config.daylight_fade,
    color_sensitivity: config.color_sensitivity,
    brightness_sensitivity: config.brightness_sensitivity,
    activity_preset: config.activity_preset,
    max_dim_steps: config.max_dim_steps,
  };

  // Include name for rename support
  if (newName !== selectedRhythmName) {
    rhythmSettings.name = newName;
  }

  try {
    const response = await fetch(`./api/circadian-rhythms/${encodeURIComponent(selectedRhythmName)}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(rhythmSettings)
    });

    const saveBtn = document.getElementById('save-config');
    if (response.ok) {
      if (newName !== selectedRhythmName) {
        // Update URL to reflect new name
        selectedRhythmName = newName;
        const basePath = window.location.pathname.replace(/\/rhythm\/[^/]+\/?$/, '');
        window.history.replaceState(null, '', basePath + '/rhythm/' + encodeURIComponent(newName) + window.location.search);
      }
      // Brief feedback then navigate back
      if (saveBtn) {
        saveBtn.textContent = 'Saved';
        saveBtn.classList.add('saved');
      }
      if (typeof _saveCallback === 'function') {
        setTimeout(_saveCallback, 600);
      }
    } else {
      const data = await response.json();
      statusEl.innerHTML = '<div class="error">' + (data.error || 'Failed to save') + '</div>';
      setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
    }
  } catch (err) {
    statusEl.innerHTML = '<div class="error">Error: ' + err.message + '</div>';
    setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
  }
}

/**
 * Navigation
 */
const _basePath = window.location.pathname.replace(/\/rhythm\/[^/]*\/?$/, '').replace(/\/rhythm\/?$/, '');
const _backParam = new URLSearchParams(window.location.search).get('back');
const _backUrl = _backParam && _backParam !== 'home'
  ? (_basePath || '.') + '/' + _backParam
  : _backParam === 'home'
    ? (_basePath || '.') + '/'
    : (_basePath || '.') + '/rhythm';

function goBack() {
  if (window.history.length > 1 && document.referrer) {
    window.history.back();
  } else {
    window.location.href = _backUrl;
  }
}

let _saveCallback = goBack;

/**
 * Setup save and cancel buttons
 */
function setupSaveButton() {
  document.getElementById('save-config')?.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopImmediatePropagation();
    saveRhythmSettings();
  });
  document.getElementById('cancel-btn')?.addEventListener('click', goBack);
}

// ============================================================

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('chart-date-slider');
  if (slider) {
    const now = new Date();
    const start = new Date(now.getFullYear(), 0, 1);
    const diff = now - start;
    const dayOfYear = Math.floor(diff / 86400000);
    slider.value = dayOfYear;
  }

  resetRuntimeState();
  setupEventListeners();
  setupLiveDesign();
  setupSaveButton();
  syncUIFromConfig();

  // Set cursor to current time on page load
  const now = new Date();
  cursorHour = now.getHours() + now.getMinutes() / 60;

  renderChart();
  applyCursor();

  // Load rhythm from URL
  loadRhythmFromUrl();
});
</script>
</body>
</html>
