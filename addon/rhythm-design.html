<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Circadian Light - Rhythm Zone</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<style>
:root {
  --bg: #000;
  --panel: #111;
  --panel2: #252525;
  --card: #1a1a1a;
  --text: #e2e8f0;
  --muted: #94a3b8;
  --muted2: #64748b;
  --line: #334155;
  --line2: #2c2c2c;
  --grid: #202020;
  --accent: #feac60;
  --accent-hover: #ffc078;
  --ascend: rgba(120, 190, 255, 0.32);
  --ascend-border: rgba(120, 185, 245, 0.5);
  --descend: rgba(255, 220, 100, 0.12);
  --descend-border: rgba(255, 230, 128, 0.45);
}
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; }
body { padding: 0; }
h1 { margin: 0 0 18px; font-size: 28px; font-weight: 600; }
h2 { margin: 0 0 12px; font-size: 1.1rem; font-weight: 600; }

/* Rhythm tune-cards (collapsible settings sections) */
.rhythm-card { background: var(--card); border: 1px solid var(--line); border-radius: 10px; margin-bottom: 16px; overflow: hidden; font-size: 13px; }
.rhythm-card-header { display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px 14px; user-select: none; }
.rhythm-card-chevron { display: inline-block; font-size: 1.1rem; line-height: 1; transition: transform 0.25s; color: var(--muted2); flex-shrink: 0; }
.rhythm-card.is-open .rhythm-card-chevron { transform: rotate(90deg); }
.rhythm-card-title { font-size: 1.0rem; font-weight: 600; color: var(--text); }
.rhythm-card-val { margin-left: auto; font-size: 0.85rem; color: var(--muted); white-space: nowrap; text-align: right; font-variant-numeric: tabular-nums; }
.rhythm-card-val b { font-weight: 700; font-size: 0.95rem; color: var(--text); }
.rhythm-card-body { max-height: 0; opacity: 0; overflow: hidden; transition: max-height 0.35s ease, opacity 0.25s ease; padding: 0 14px; }
.rhythm-card.is-open .rhythm-card-body { max-height: 1200px; opacity: 1; padding-bottom: 14px; }

/* Sleep card header summary (two-line stack) */
.rhythm-sleep-summary { margin-left: auto; display: flex; flex-direction: column; align-items: flex-end; gap: 1px; }
.rhythm-sleep-summary-row { display: flex; align-items: baseline; gap: 6px; font-variant-numeric: tabular-nums; }
.rhythm-sleep-summary-label { font-size: 0.7rem; color: var(--muted2); text-transform: uppercase; letter-spacing: 0.05em; }
.rhythm-sleep-summary-time { font-size: 0.95rem; font-weight: 700; color: var(--text); }
.rhythm-sleep-summary-bri { font-size: 0.75rem; color: var(--muted); }

/* Color temp header rule labels */
.rhythm-ct-rules { font-size: 0.7rem; color: var(--muted2); margin-left: 8px; }

/* Tune-control-row pattern (label + reset + impact, then indented slider + word) */
.tune-control-row { display: grid; grid-template-columns: 1fr auto; align-items: baseline; padding: 4px 14px 2px 16px; gap: 0 12px; }
.tune-control-left { display: flex; align-items: center; gap: 6px; }
.tune-control-label { font-size: 0.82rem; color: var(--muted); }
.tune-control-reset { font-size: 0.7rem; color: var(--muted2); cursor: pointer; opacity: 0; transition: opacity 0.15s; text-transform: uppercase; letter-spacing: 0.03em; pointer-events: none; }
.tune-control-reset.is-dirty { pointer-events: auto; }
.tune-control-row:hover .tune-control-reset.is-dirty { opacity: 1; }
.tune-control-reset:hover { color: var(--accent); }
.tune-control-impact { font-size: 0.82rem; color: var(--text); text-align: right; white-space: nowrap; font-variant-numeric: tabular-nums; min-width: 3em; }
.tune-slider-row { padding: 0px 14px 2px 44px; max-width: 75%; }
.tune-slider-row input[type=range] { height: 14px; }
.tune-slider-word { font-size: 0.75rem; color: var(--muted2); margin-top: 0; }
.tune-group-label { font-size: 0.75rem; font-weight: 500; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; padding: 8px 0 4px 0; }
.rhythm-select { background: var(--panel2); border: 1px solid var(--line); border-radius: 6px; color: var(--text); font-size: 0.82rem; padding: 4px 8px; outline: none; }
.rhythm-select:focus { border-color: var(--muted2); }

.container { max-width: 1200px; margin: 0 auto; padding: 20px; }

/* Page Header */
.page-header {
  background: var(--panel);
  border-bottom: 1px solid var(--line);
  padding: 12px 16px;
  display: flex;
  align-items: center;
  gap: 12px;
  position: sticky;
  top: 0;
  z-index: 100;
}
.rhythm-name-input {
  font-size: 1.2rem;
  font-weight: 600;
  background: transparent;
  border: none;
  color: var(--text);
  padding: 4px 0;
  width: auto;
  min-width: 120px;
  max-width: 300px;
}
.rhythm-name-input:focus {
  outline: none;
}
.header-actions {
  display: flex;
  gap: 12px;
  align-items: center;
  margin-left: auto;
}

/* Rhythm group labels */
.rhythm-group-label {
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--muted);
  margin: 10px 0 2px;
}
.rhythm-group-label.bed {
  border-top: 1px solid var(--line);
  padding-top: 10px;
  margin-top: 12px;
}

/* Alt time day bubbles */
.day-bubbles {
  display: flex;
  gap: 4px;
  align-items: center;
}
.day-bubble {
  width: 28px;
  height: 28px;
  border-radius: 50%;
  border: 1px solid var(--line);
  background: transparent;
  color: var(--muted);
  font-size: 0.65rem;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  padding: 0;
  line-height: 1;
}
.day-bubble:hover {
  border-color: var(--accent);
  color: var(--text);
}
.day-bubble.active {
  background: #eef1f5;
  border-color: #eef1f5;
  color: #000;
}

/* Alt time row collapse */
.alt-time-row {
  transition: opacity 0.2s, max-height 0.2s;
  overflow: hidden;
}
.alt-time-row.collapsed {
  max-height: 0;
  opacity: 0;
  margin: 0;
  padding: 0;
}
.alt-time-row:not(.collapsed) {
  max-height: 60px;
  opacity: 1;
}

/* Hidden day-bubbles (source of truth, not visible) */
.day-bubbles {
  display: none;
}
/* Sleep time group (tune-control-row pattern) */
.sleep-time-group .day-indicators {
  display: flex;
  gap: 3px;
  margin-top: 2px;
}
.sleep-time-group .day-indicator {
  width: 24px;
  height: 24px;
  border-radius: 50%;
  border: 1px solid var(--line);
  background: transparent;
  color: var(--muted2);
  font-size: 0.55rem;
  font-weight: 600;
  cursor: pointer;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: all 0.15s;
  padding: 0;
  line-height: 1;
}
.sleep-time-group .day-indicator:hover {
  border-color: var(--accent);
  color: var(--text);
}
.sleep-time-group .day-indicator.active {
  background: var(--accent);
  border-color: var(--accent);
  color: #000;
}
.sleep-time-group.no-alt .alt-block {
  display: none;
}

/* Section block (chart) */
.section-block {
  background: var(--card);
  border: 1px solid var(--line);
  border-radius: 8px;
  padding: 16px;
  margin-bottom: 16px;
  position: sticky;
  top: 49px;
  z-index: 50;
}

/* Sliders */
input[type=range] {
  width: 100%;
  background: transparent;
  appearance: none;
  height: 20px;
  padding: 0;
  margin: 0;
}
input[type=range]:focus { outline: none; }
input[type=range]::-webkit-slider-runnable-track {
  height: 4px;
  background: rgba(255,255,255,0.3);
  border-radius: 2px;
}
input[type=range]::-moz-range-track {
  height: 4px;
  background: rgba(255,255,255,0.3);
  border-radius: 2px;
}
input[type=range]::-webkit-slider-thumb {
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid rgba(0,0,0,0.3);
  margin-top: -6px;
  cursor: pointer;
}
input[type=range]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid rgba(0,0,0,0.3);
  cursor: pointer;
}

/* Chart Section */
.chart-wrapper { position: relative; margin-bottom: 18px; }
#chart { height: 280px; }
.chart-toolbar {
  display: flex;
  align-items: center;
  gap: 8px;
  margin: 6px 0 8px;
}
.chart-date-control {
  display: flex;
  align-items: center;
  gap: 8px;
  flex: 1;
  max-width: 300px;
}
.chart-date-display {
  font-size: 0.8rem;
  color: var(--text);
  min-width: 50px;
  font-weight: 600;
}
.chart-date-control input[type=range] {
  flex: 1;
}
.modeled-conditions {
  display: flex;
  align-items: center;
  margin-left: auto;
}
.modeled-conditions select {
  padding: 4px 8px;
  border-radius: 6px;
  border: 1px solid var(--line);
  background: var(--panel2);
  color: var(--text);
  font-size: 0.75rem;
}
.chart-below-row {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  margin-top: 8px;
}
.time-nav-group {
  display: flex;
  gap: 4px;
  align-items: center;
}
.time-nav-divider {
  width: 1px;
  height: 16px;
  background: rgba(255,255,255,0.15);
  margin: 0 2px;
}
.time-nav-btn {
  --btn-bg: rgba(255,255,255,0.06);
  --btn-text: #fff;
  --btn-fill: 0;
  --btn-fill-opacity: 0;
  background: var(--btn-bg);
  border: 1px solid rgba(255,255,255,0.2);
  color: var(--btn-text);
  font-size: 0.65rem;
  padding: 3px 10px;
  border-radius: 999px;
  cursor: pointer;
  white-space: nowrap;
  transition: all 0.15s;
  position: relative;
  overflow: hidden;
}
.time-nav-btn::after {
  content: '';
  position: absolute;
  inset: 2px;
  border-radius: 999px;
  background: rgba(255,255,255,0.18);
  opacity: var(--btn-fill-opacity);
  pointer-events: none;
}
.time-nav-btn:hover {
  border-color: rgba(255,255,255,0.4);
}

/* Schedule toggles in chart toolbar */
.chart-schedule-toggles { display: flex; gap: 10px; align-items: center; font-size: 0.75rem; color: var(--muted); }
.schedule-toggle { display: flex; align-items: center; gap: 4px; cursor: pointer; user-select: none; }
.schedule-toggle input[type=checkbox] { width: 13px; height: 13px; accent-color: var(--muted2); }

/* Time hover label - above x-axis, shows time with phase color */
.time-hover-label {
  position: absolute;
  bottom: 70px;
  padding: 4px 9px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.3);
  background: rgba(5,5,5,0.88);
  color: #fff;
  font-size: 0.75rem;
  font-weight: 600;
  pointer-events: none;
  transform: translateX(-50%);
  opacity: 0;
  transition: opacity 0.12s ease, left 0.08s ease;
  white-space: nowrap;
  box-shadow: 0 4px 10px rgba(0,0,0,0.35);
  z-index: 100;
}

/* Cursor callout - shows values at cursor position */
.graph-cursor-callout {
  position: absolute;
  bottom: -14px;
  padding: 4px 10px;
  border-radius: 8px;
  border: 1.5px solid #fdfdfd;
  background: rgba(10,10,10,0.85);
  color: #fff;
  font-size: 0.78rem;
  font-weight: 600;
  pointer-events: none;
  transform: translateX(-50%);
  opacity: 0;
  transition: opacity 0.12s ease, left 0.08s ease;
  white-space: nowrap;
  z-index: 100;
}

/* Dual Range Slider - fixed from llm_access for proper left handle grabbing */
.dual-range {
  position: relative;
  display: flex;
  align-items: center;
  gap: 8px;
}
.dual-track {
  position: relative;
  flex: 1;
  height: 6px;
  background: rgba(255,255,255,0.3);
  border-radius: 3px;
}
.dual-track.color-track {
  height: 12px;
  border-radius: 6px;
  box-shadow: inset 0 1px 3px rgba(0,0,0,0.3);
}
.dual-fill {
  position: absolute;
  top: 0;
  height: 100%;
  background: var(--accent);
  border-radius: inherit;
  pointer-events: none;
}
.dual-mask {
  position: absolute;
  top: 0;
  height: 100%;
  background: rgba(0,0,0,0.7);
  pointer-events: none;
}
.dual-range input[type=range] {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  width: 100%;
  height: 20px;
  background: transparent;
  pointer-events: none;
  cursor: pointer;
}
.dual-range input[type=range]::-webkit-slider-runnable-track {
  background: transparent;
}
.dual-range input[type=range]::-moz-range-track {
  background: transparent;
}
.dual-range input[type=range]::-webkit-slider-thumb {
  pointer-events: auto;
}
.dual-range input[type=range]::-moz-range-thumb {
  pointer-events: auto;
}
.dual-range input[type=range].range-min {
  z-index: 4;
}
.dual-range input[type=range].range-max {
  z-index: 3;
}
.dual-chip {
  font-size: 0.85rem;
  color: var(--muted);
  min-width: 60px;
}
.dual-chip.right { text-align: left; }

/* Color Value Chip Button */
.color-value-chip {
  border: none;
  border-radius: 999px;
  padding: 3px 12px;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  min-width: 80px;
  text-align: center;
}
.color-value-chip:hover {
  filter: brightness(1.1);
}

/* Lock checkbox for range controls */
.lock-checkbox-wrap {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  margin-left: 8px;
  font-size: 0.75rem;
  color: #888;
  cursor: pointer;
  user-select: none;
}
.lock-checkbox-wrap input[type="checkbox"] {
  width: 14px;
  height: 14px;
  margin: 0;
  cursor: pointer;
  accent-color: #666;
}
.lock-checkbox-wrap .lock-icon {
  font-size: 0.8rem;
  opacity: 0.6;
}
.lock-checkbox-wrap input[type="checkbox"]:checked + .lock-icon {
  opacity: 1;
  color: #f5a623;
}

/* Color Slider Popup */
.color-controls-wrap {
  position: relative;
  display: inline-block;
}
.color-slider-popup {
  position: absolute;
  top: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: #101010;
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 10px;
  padding: 12px 14px;
  box-shadow: 0 12px 24px rgba(0,0,0,0.45);
  min-width: 280px;
  display: none;
  z-index: 50;
}
.color-slider-popup.is-open {
  display: block;
}
.color-slider-popup .dual-track {
  height: 10px;
  border-radius: 5px;
}
.color-slider-popup input[type=range] {
  height: 20px;
}

/* Color Rule Stack */
.color-rule-grid {
  display: flex;
  flex-direction: column;
  gap: 0;
  margin-top: 16px;
}
.color-rule-stack {
  padding: 10px 0 2px;
}
.color-rule-stack-label {
  display: grid;
  grid-template-columns: 140px 1fr;
  align-items: center;
  gap: 10px;
  margin-bottom: 4px;
  max-width: 600px;
}
.color-rule-stack-label .color-rule-label-left {
  display: flex;
  align-items: center;
  gap: 8px;
}
.color-rule-stack-label .color-rule-controls {
  display: flex;
  align-items: center;
  gap: 10px;
}
.color-rule-stack-label select {
  padding: 4px 8px;
  border-radius: 6px;
  border: 1px solid var(--line);
  background: var(--panel2);
  color: var(--text);
  font-size: 0.85rem;
}
.color-rule-label {
  font-size: 0.7rem;
  text-transform: uppercase;
  letter-spacing: 0.1em;
  color: var(--muted);
}
.info-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  position: relative;
  width: 16px;
  height: 16px;
  margin-left: 6px;
  font-size: 11px;
  font-weight: 600;
  color: rgba(255,255,255,0.5);
  border: 1px solid rgba(255,255,255,0.3);
  border-radius: 50%;
  cursor: pointer;
  vertical-align: middle;
  user-select: none;
  transition: all 0.15s ease;
}
.info-icon:hover {
  color: rgba(255,255,255,0.8);
  border-color: rgba(255,255,255,0.5);
}
.info-tooltip {
  display: none;
  position: absolute;
  top: 24px;
  left: 50%;
  transform: translateX(-50%);
  width: 280px;
  padding: 10px 12px;
  background: rgba(30,30,35,0.98);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  font-size: 0.85rem;
  font-weight: 400;
  line-height: 1.4;
  color: rgba(255,255,255,0.85);
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  z-index: 100;
}
.info-tooltip.is-open {
  display: block;
}
.color-rule-toggle input[type=checkbox] {
  width: 16px;
  height: 16px;
  accent-color: white;
}
.color-rule-stack-body {
  display: block;
  padding-left: 22px;
}
.color-rule-stack-body.is-disabled {
  opacity: 0.4;
  pointer-events: none;
}


/* Buttons */
.btn {
  border: 1px solid rgba(255,255,255,0.3);
  background: rgba(255,255,255,0.1);
  color: #fff;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.9rem;
  transition: all 0.15s;
}
.btn:hover { background: rgba(255,255,255,0.15); }
.btn-primary {
  background: var(--accent);
  border-color: var(--accent);
}
.btn-primary:hover { filter: brightness(1.1); }

/* Collapsible Section */
.collapsible-section {
  margin-top: 16px;
  border-top: 1px solid var(--line);
  padding-top: 12px;
}
.collapsible-header {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  user-select: none;
  color: var(--muted);
  font-size: 0.85rem;
}
.collapsible-header:hover {
  color: var(--text);
}
.collapsible-arrow {
  transition: transform 0.2s ease;
  font-size: 0.7rem;
}
.collapsible-section.is-open .collapsible-arrow {
  transform: rotate(90deg);
}
.collapsible-content {
  display: none;
  padding-top: 12px;
}
.collapsible-section.is-open .collapsible-content {
  display: block;
}
.location-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}
.location-field {
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.location-field label {
  font-size: 0.8rem;
  color: var(--muted);
}
.location-field input {
  padding: 8px 10px;
  border-radius: 6px;
  border: 1px solid var(--line);
  background: var(--panel2);
  color: var(--text);
  font-size: 0.9rem;
}
.location-field input:disabled {
  opacity: 0.5;
}
.location-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  font-size: 0.85rem;
  color: var(--muted);
}
.location-toggle input[type=checkbox] {
  width: 14px;
  height: 14px;
}

/* Status Messages */
.success {
  color: #51cf66;
  font-size: 0.9rem;
  margin: 10px 0;
  padding: 12px 16px;
  background: rgba(81,207,102,0.15);
  border: 1px solid rgba(81,207,102,0.3);
  border-radius: 8px;
  font-weight: 600;
}
.error {
  color: #ff6b6b;
  font-size: 0.9rem;
  margin: 10px 0;
  padding: 12px 16px;
  background: rgba(255,107,107,0.15);
  border: 1px solid rgba(255,107,107,0.3);
  border-radius: 8px;
  font-weight: 600;
}

/* Live Design Controls */
.live-design-controls {
  display: flex;
  align-items: center;
  padding: 4px 0;
  margin-bottom: 12px;
  gap: 16px;
}
.live-design-controls label {
  font-size: 0.9rem;
  color: var(--muted);
  font-weight: 600;
}
.live-design-controls select {
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(255,255,255,0.06);
  color: #fff;
  min-width: 180px;
  font-size: 0.9rem;
}
.live-design-controls select:focus {
  outline: none;
  border-color: dodgerblue;
}
.live-design-link {
  font-size: 0.85rem;
  color: var(--muted);
  cursor: pointer;
  text-decoration: none;
  background: none;
  border: none;
  padding: 0;
  font-family: inherit;
}
.live-design-link:hover { color: var(--text); text-decoration: underline; }
.live-design-status {
  font-size: 0.8rem;
  color: var(--text);
  margin-left: 4px;
}
.live-design-status.active {
  color: var(--text);
}
@keyframes live-pulse {
  0%, 100% { opacity: 1; }
  50% { opacity: 0.3; }
}
.live-design-status.live-blink {
  animation: live-pulse 1.8s ease-in-out infinite;
}

/* Rhythm Zone Management Styles */
.glozone-section {
  margin-bottom: 16px;
}
.glozone-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}
.glozone-header h2 {
  margin: 0;
  font-size: 1rem;
  color: var(--muted);
}
.glozone-tabs {
  display: flex;
  gap: 8px;
}
.glozone-tab {
  padding: 6px 14px;
  border: 1px solid var(--line);
  border-radius: 6px;
  background: var(--panel);
  color: var(--muted);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s;
}
.glozone-tab:hover {
  border-color: var(--accent);
  color: var(--text);
}
.glozone-tab.active {
  background: var(--accent);
  border-color: var(--accent);
  color: #fff;
}
.glozone-content {
  display: none;
}
.glozone-content.active {
  display: block;
}

/* Zone/Preset Lists */
.glozone-list {
  display: flex;
  flex-direction: column;
  gap: 8px;
}
.glozone-item {
  display: flex;
  align-items: center;
  justify-content: space-between;
  padding: 10px 14px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 8px;
  transition: border-color 0.15s;
}
.glozone-item:hover {
  border-color: var(--accent);
}
.glozone-item.selected {
  border-color: var(--accent);
  background: rgba(30, 144, 255, 0.1);
}
.glozone-item-info {
  display: flex;
  flex-direction: column;
  gap: 2px;
}
.glozone-item-name {
  font-weight: 600;
  font-size: 0.95rem;
}
.glozone-item-meta {
  font-size: 0.75rem;
  color: var(--muted2);
}
.glozone-item-actions {
  display: flex;
  gap: 6px;
}
.glozone-item-actions button {
  padding: 4px 10px;
  font-size: 0.75rem;
  border: 1px solid var(--line);
  border-radius: 4px;
  background: transparent;
  color: var(--muted);
  cursor: pointer;
  transition: all 0.15s;
}
.glozone-item-actions button:hover {
  border-color: var(--accent);
  color: var(--text);
}
.glozone-item-actions button.delete:hover {
  border-color: #ef4444;
  color: #ef4444;
}

/* Add New Button */
.glozone-add {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 6px;
  padding: 10px;
  border: 1px dashed var(--line);
  border-radius: 8px;
  background: transparent;
  color: var(--muted);
  font-size: 0.85rem;
  cursor: pointer;
  transition: all 0.15s;
  width: 100%;
  margin-top: 8px;
}
.glozone-add:hover {
  border-color: var(--accent);
  color: var(--accent);
}

/* Zone Detail Panel */
.glozone-detail {
  margin-top: 12px;
  padding: 14px;
  background: var(--panel2);
  border: 1px solid var(--line);
  border-radius: 8px;
}
.glozone-detail-header {
  display: flex;
  align-items: center;
  justify-content: space-between;
  margin-bottom: 12px;
}
.glozone-detail-title {
  font-weight: 600;
  font-size: 1rem;
}
.glozone-rename-btn {
  padding: 4px 10px;
  font-size: 0.75rem;
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 4px;
  color: var(--text);
  cursor: pointer;
  transition: all 0.2s;
}
.glozone-rename-btn:hover {
  background: var(--accent);
  border-color: var(--accent);
  color: white;
}
.glozone-detail-row {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 10px;
}
.glozone-detail-row label {
  font-size: 0.85rem;
  color: var(--muted);
  min-width: 80px;
}
.glozone-detail-row select,
.glozone-detail-row input {
  flex: 1;
  padding: 8px 12px;
  border: 1px solid var(--line);
  border-radius: 6px;
  background: var(--panel);
  color: var(--text);
  font-size: 0.9rem;
}

/* Area Assignment */
.area-assignment {
  margin-top: 12px;
}
.area-assignment-header {
  font-size: 0.85rem;
  color: var(--muted);
  margin-bottom: 8px;
}
.area-chips {
  display: flex;
  flex-wrap: wrap;
  gap: 6px;
}
.area-chip {
  display: flex;
  align-items: center;
  gap: 4px;
  padding: 4px 10px;
  background: rgba(30, 144, 255, 0.15);
  border: 1px solid rgba(30, 144, 255, 0.3);
  border-radius: 12px;
  font-size: 0.8rem;
  color: var(--text);
}
.area-chip .remove {
  cursor: pointer;
  opacity: 0.6;
  font-size: 0.9rem;
}
.area-chip .remove:hover {
  opacity: 1;
  color: #ef4444;
}
.area-chip.unassigned {
  background: rgba(255, 255, 255, 0.05);
  border-color: var(--line);
  cursor: pointer;
}
.area-chip.unassigned:hover {
  border-color: var(--accent);
}
/* Drag and Drop */
.area-chip[draggable="true"] {
  cursor: grab;
}
.area-chip[draggable="true"]:active {
  cursor: grabbing;
}
.area-chip.dragging {
  opacity: 0.5;
}
.area-chips.drag-over {
  background: rgba(var(--accent-rgb, 99, 102, 241), 0.1);
  border-radius: 8px;
  outline: 2px dashed var(--accent);
  outline-offset: 2px;
}
.drop-zone {
  min-height: 40px;
  transition: all 0.2s;
}

/* Empty State */
.glozone-empty {
  text-align: center;
  padding: 20px;
  color: var(--muted2);
  font-size: 0.9rem;
}

/* Modal Styles */
.glozone-modal-overlay {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 1000;
  opacity: 0;
  visibility: hidden;
  transition: opacity 0.2s, visibility 0.2s;
}
.glozone-modal-overlay.visible {
  opacity: 1;
  visibility: visible;
}
.glozone-modal {
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 20px;
  min-width: 320px;
  max-width: 90vw;
  max-height: 80vh;
  overflow-y: auto;
}
.glozone-modal h3 {
  margin: 0 0 16px;
  font-size: 1.1rem;
}
.glozone-modal-actions {
  display: flex;
  justify-content: flex-end;
  gap: 8px;
  margin-top: 16px;
}
.glozone-modal-actions button {
  padding: 8px 16px;
  border-radius: 6px;
  font-size: 0.9rem;
  cursor: pointer;
}
.glozone-modal-actions .btn-cancel {
  background: transparent;
  border: 1px solid var(--line);
  color: var(--muted);
}
.glozone-modal-actions .btn-confirm {
  background: var(--accent);
  border: 1px solid var(--accent);
  color: #fff;
}

/* Back-button page header */
.back-btn {
  display: flex;
  align-items: center;
  justify-content: center;
  width: 36px;
  height: 36px;
  border-radius: 8px;
  border: 1px solid var(--line);
  background: var(--card);
  color: var(--text);
  cursor: pointer;
  transition: all 0.2s;
  flex-shrink: 0;
}
.back-btn:hover {
  background: rgba(255, 255, 255, 0.1);
  border-color: var(--accent);
}
.back-btn svg {
  width: 20px;
  height: 20px;
}

/* Header action links */
.header-link { background: none; border: none; font-size: 0.8rem; cursor: pointer; padding: 0; }
.header-link-cancel { color: var(--muted); }
.header-link-cancel:hover { color: var(--text); }
.header-link-save { color: var(--accent); font-weight: 600; transition: color 0.6s ease; }
.header-link-save:hover { opacity: 0.8; }
.header-link-save.saved { color: var(--text); }
</style>
</head>
<body>
<!-- Page Header -->
<header class="page-header">
  <button class="back-btn" onclick="goBack()" title="Back">
    <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
      <polyline points="15 18 9 12 15 6"/>
    </svg>
  </button>
  <span style="color: var(--muted); font-size: 1.1rem; font-weight: 500;">Design:</span>
  <input type="text" class="rhythm-name-input" id="rhythm-name" value="Daily Rhythm 1" placeholder="Zone name">
  <div class="header-actions">
    <button class="header-link header-link-cancel" id="cancel-btn">Cancel</button>
    <button class="header-link header-link-save" id="save-config">Save</button>
  </div>
</header>

<div class="container">
  <div id="save-status"></div>

  <!-- Live Design Controls -->
  <div class="live-design-controls" id="live-design-controls">
    <label for="live-area-select">Live Design:</label>
    <select id="live-area-select">
      <option value="">Select Area</option>
    </select>
    <a href="#" class="live-design-link" id="live-design-toggle" style="display: none;">Pause</a>
    <span class="live-design-status" id="live-design-status"></span>
  </div>

  <!-- Chart -->
  <div class="section-block" id="chart-section">
    <div class="chart-toolbar">
      <div class="chart-date-control">
        <span class="chart-date-display" id="chart-date-display">Today</span>
        <input type="range" id="chart-date-slider" min="0" max="364" value="0">
      </div>
      <div class="modeled-conditions">
        <select id="modeled-conditions" title="Preview how weather affects the color curve">
          <option value="1.0">Clear sun</option>
          <option value="0.6">Partly cloudy</option>
          <option value="0.3">Overcast</option>
          <option value="0.15">Heavy overcast</option>
          <option value="0">Dark / indoor</option>
        </select>
      </div>
      <div class="chart-schedule-toggles" id="chart-schedule-toggles" style="display:none;">
        <label class="schedule-toggle">
          <input type="checkbox" id="chart-wake-secondary"> wake secondary
        </label>
        <label class="schedule-toggle">
          <input type="checkbox" id="chart-bed-secondary"> bed secondary
        </label>
      </div>
    </div>
    <div class="chart-wrapper">
      <div id="chart"></div>
      <div class="time-hover-label" id="time-hover-label"></div>
      <div class="graph-cursor-callout" id="cursor-callout"></div>
    </div>

    <div class="chart-below-row">
      <div class="time-nav-group">
        <button class="time-nav-btn" id="cursor-time-minus-30" title="-30 minutes">-30</button>
        <button class="time-nav-btn" id="cursor-time-minus" title="-5 minutes">-5</button>
        <button class="time-nav-btn" id="cursor-time-plus" title="+5 minutes">+5</button>
        <button class="time-nav-btn" id="cursor-time-plus-30" title="+30 minutes">+30</button>
      </div>
      <div class="time-nav-divider"></div>
      <button class="time-nav-btn" id="cursor-time-now" title="Jump to current time">Now</button>
    </div>
  </div>

  <div class="rhythm-card" id="rhythm-sleep-card">
    <div class="rhythm-card-header" onclick="toggleRhythmCard('rhythm-sleep-card', 'rhythm_sleep_expanded')">
      <span class="rhythm-card-chevron" id="rhythm-sleep-chevron">&#x203A;</span>
      <span class="rhythm-card-title">Sleep</span>
      <div class="rhythm-sleep-summary" id="rhythm-sleep-summary">
        <div class="rhythm-sleep-summary-row">
          <span class="rhythm-sleep-summary-label">wake</span>
          <span class="rhythm-sleep-summary-bri" id="sleep-sum-wake-bri">50%</span>
          <span class="rhythm-sleep-summary-time" id="sleep-sum-wake-time">7:00a</span>
        </div>
        <div class="rhythm-sleep-summary-row">
          <span class="rhythm-sleep-summary-label">bed</span>
          <span class="rhythm-sleep-summary-bri" id="sleep-sum-bed-bri">50%</span>
          <span class="rhythm-sleep-summary-time" id="sleep-sum-bed-time">9:00p</span>
        </div>
      </div>
    </div>
    <div class="rhythm-card-body" id="rhythm-sleep-body">
      <div style="display:flex;align-items:center;gap:8px;padding:6px 0 2px;">
        <span class="tune-control-label">Pattern</span>
        <select id="activity-preset" class="rhythm-select">
          <option value="young">Young Child</option>
          <option value="adult" selected>Adult</option>
          <option value="nightowl">Night Owl</option>
          <option value="duskbat">Dusk Bat</option>
          <option value="shiftearly">Shift Early</option>
          <option value="shiftlate">Shift Late</option>
        </select>
      </div>

      <div class="tune-group-label">Wake</div>
      <!-- Hidden day bubbles (data source) -->
      <div class="day-bubbles" id="wake-days">
        <button class="day-bubble" data-day="0">Mo</button>
        <button class="day-bubble" data-day="1">Tu</button>
        <button class="day-bubble" data-day="2">We</button>
        <button class="day-bubble" data-day="3">Th</button>
        <button class="day-bubble" data-day="4">Fr</button>
        <button class="day-bubble" data-day="5">Sa</button>
        <button class="day-bubble" data-day="6">Su</button>
      </div>
      <div class="sleep-time-group no-alt" id="wake-time-blocks">
        <div class="primary-block">
          <div class="tune-control-row">
            <span class="tune-control-left"><span class="tune-control-label" id="wake-primary-label">Time</span></span>
            <span class="tune-control-impact" id="wake-time-display">7:00a</span>
          </div>
          <div class="tune-slider-row">
            <input type="range" id="wake-time" min="0" max="24" step="0.25" value="7">
            <div class="day-indicators" id="wake-primary-days"></div>
          </div>
        </div>
        <div class="alt-block" id="wake-alt-time-row">
          <div class="tune-control-row">
            <span class="tune-control-left"><span class="tune-control-label" id="wake-alt-label">Secondary</span></span>
            <span class="tune-control-impact" id="wake-alt-time-display">9:00a</span>
          </div>
          <div class="tune-slider-row">
            <input type="range" id="wake-alt-time" min="0" max="24" step="0.25" value="9">
            <div class="day-indicators" id="wake-alt-days"></div>
          </div>
        </div>
      </div>
      <div class="tune-control-row">
        <span class="tune-control-left">
          <span class="tune-control-label">Brightness</span>
          <span class="tune-control-reset" id="reset-wake-brightness" data-default="25">reset</span>
        </span>
        <span class="tune-control-impact" id="wake-brightness-display">50%</span>
      </div>
      <div class="tune-slider-row">
        <input type="range" id="wake-brightness" min="10" max="90" step="5" value="50">
      </div>
      <div class="tune-control-row">
        <span class="tune-control-left">
          <span class="tune-control-label">Speed</span>
          <span class="tune-control-reset" id="reset-wake-speed" data-default="6">reset</span>
        </span>
        <span class="tune-control-impact" id="wake-speed-display">Crisp (6)</span>
      </div>
      <div class="tune-slider-row">
        <input type="range" id="wake-speed" min="1" max="10" step="1" value="6">
      </div>

      <div class="tune-group-label">Bed</div>
      <!-- Hidden day bubbles (data source) -->
      <div class="day-bubbles" id="bed-days">
        <button class="day-bubble" data-day="0">Mo</button>
        <button class="day-bubble" data-day="1">Tu</button>
        <button class="day-bubble" data-day="2">We</button>
        <button class="day-bubble" data-day="3">Th</button>
        <button class="day-bubble" data-day="4">Fr</button>
        <button class="day-bubble" data-day="5">Sa</button>
        <button class="day-bubble" data-day="6">Su</button>
      </div>
      <div class="sleep-time-group no-alt" id="bed-time-blocks">
        <div class="primary-block">
          <div class="tune-control-row">
            <span class="tune-control-left"><span class="tune-control-label" id="bed-primary-label">Time</span></span>
            <span class="tune-control-impact" id="bed-time-display">9:00p</span>
          </div>
          <div class="tune-slider-row">
            <input type="range" id="bed-time" min="0" max="36" step="0.25" value="21">
            <div class="day-indicators" id="bed-primary-days"></div>
          </div>
        </div>
        <div class="alt-block" id="bed-alt-time-row">
          <div class="tune-control-row">
            <span class="tune-control-left"><span class="tune-control-label" id="bed-alt-label">Secondary</span></span>
            <span class="tune-control-impact" id="bed-alt-time-display">11:00p</span>
          </div>
          <div class="tune-slider-row">
            <input type="range" id="bed-alt-time" min="0" max="36" step="0.25" value="23">
            <div class="day-indicators" id="bed-alt-days"></div>
          </div>
        </div>
      </div>
      <div class="tune-control-row">
        <span class="tune-control-left">
          <span class="tune-control-label">Brightness</span>
          <span class="tune-control-reset" id="reset-bed-brightness" data-default="25">reset</span>
        </span>
        <span class="tune-control-impact" id="bed-brightness-display">50%</span>
      </div>
      <div class="tune-slider-row">
        <input type="range" id="bed-brightness" min="10" max="90" step="5" value="50">
      </div>
      <div class="tune-control-row">
        <span class="tune-control-left">
          <span class="tune-control-label">Speed</span>
          <span class="tune-control-reset" id="reset-bed-speed" data-default="6">reset</span>
        </span>
        <span class="tune-control-impact" id="bed-speed-display">Smooth (4)</span>
      </div>
      <div class="tune-slider-row">
        <input type="range" id="bed-speed" min="1" max="10" step="1" value="4">
      </div>

      <!-- Hidden fields for ascend/descend (set by sleep pattern) -->
      <input type="range" id="ascend-start" min="0" max="24" step="0.5" value="3" style="display:none">
      <input type="range" id="descend-start" min="0" max="36" step="0.5" value="12" style="display:none">
    </div>
  </div>

  <!-- Color temperature -->
  <div class="rhythm-card" id="rhythm-color-card">
    <div class="rhythm-card-header" onclick="toggleRhythmCard('rhythm-color-card', 'rhythm_color_expanded')">
      <span class="rhythm-card-chevron">&#x203A;</span>
      <span class="rhythm-card-title">Color temperature</span>
      <span class="rhythm-card-val" id="rhythm-color-val">500 – 6500 K</span>
    </div>
    <div class="rhythm-card-body" id="rhythm-color-body">
      <div class="tune-control-row" style="padding-left:0;">
        <span class="tune-control-left"><span class="tune-control-label">Range</span></span>
        <span class="tune-control-impact" id="color-range-display">500 – 6500 K</span>
      </div>
      <div class="tune-slider-row">
        <div class="dual-range">
          <div class="dual-track color-track" id="color-track">
            <div class="dual-mask" id="color-mask-left"></div>
            <div class="dual-mask" id="color-mask-right"></div>
          </div>
          <input type="range" id="color-min" class="range-min" min="500" max="6500" step="100" value="500">
          <input type="range" id="color-max" class="range-max" min="500" max="6500" step="100" value="6500">
        </div>
      </div>

      <div class="color-rule-grid">
        <div class="color-rule-stack" data-color-row="night">
          <div class="color-rule-stack-label">
            <div class="color-rule-label-left">
              <label class="color-rule-label">Warm night<span class="info-icon" data-tooltip="warm-night-info">i<span class="info-tooltip" id="warm-night-info">Caps color temperature when sun isn't up; if your curve is cool (high K) between sunset and sunrise, this warms it.</span></span></label>
              <div class="color-rule-toggle"><input type="checkbox" id="warm-night-enabled"></div>
            </div>
            <div class="color-rule-controls">
              <div class="color-controls-wrap">
                <button type="button" class="color-value-chip" id="warm-night-target-chip">2700 K</button>
                <div class="color-slider-popup" id="warm-night-popup">
                  <div class="dual-range">
                    <div class="dual-track color-track" id="warm-night-track"></div>
                    <input type="range" id="warm-night-target" class="range-min" min="500" max="6500" step="100" value="2700">
                  </div>
                </div>
              </div>
            </div>
          </div>
          <input type="hidden" id="warm-night-mode" value="all">
          <div class="color-rule-stack-body" id="warm-night-body">
            <div class="tune-control-row">
              <span class="tune-control-left">
                <span class="tune-control-label">Start</span>
                <span class="tune-control-reset" id="reset-warm-night-start" data-default="-60">reset</span>
              </span>
              <span class="tune-control-impact" id="warm-night-start-impact"></span>
            </div>
            <div class="tune-slider-row">
              <input type="range" id="warm-night-start" min="-180" max="180" step="30" value="-60">
              <div class="tune-slider-word" id="warm-night-start-text">1 hr before sunset</div>
            </div>
            <div class="tune-control-row">
              <span class="tune-control-left">
                <span class="tune-control-label">End</span>
                <span class="tune-control-reset" id="reset-warm-night-end" data-default="60">reset</span>
              </span>
              <span class="tune-control-impact" id="warm-night-end-impact"></span>
            </div>
            <div class="tune-slider-row">
              <input type="range" id="warm-night-end" min="-180" max="180" step="30" value="60">
              <div class="tune-slider-word" id="warm-night-end-text">1 hr after sunrise</div>
            </div>
            <div class="tune-control-row">
              <span class="tune-control-left">
                <span class="tune-control-label">Fade</span>
                <span class="tune-control-reset" id="reset-warm-night-fade" data-default="60">reset</span>
              </span>
              <span class="tune-control-impact" id="warm-night-fade-text">1 hr</span>
            </div>
            <div class="tune-slider-row">
              <input type="range" id="warm-night-fade" min="0" max="300" step="30" value="60">
            </div>
          </div>
        </div>

        <div class="color-rule-stack" data-color-row="daylight">
          <div class="color-rule-stack-label">
            <div class="color-rule-label-left">
              <label class="color-rule-label">Cool day<span class="info-icon" data-tooltip="daylight-info">i<span class="info-tooltip" id="daylight-info">Pushes color toward a cooler target during the day based on outdoor brightness and sun elevation.</span></span></label>
              <div class="color-rule-toggle"><input type="checkbox" id="daylight-enabled" checked></div>
            </div>
            <div class="color-rule-controls">
              <div class="color-controls-wrap">
                <button type="button" class="color-value-chip" id="daylight-cct-chip">5500 K</button>
                <div class="color-slider-popup" id="daylight-cct-popup">
                  <div class="dual-range">
                    <div class="dual-track color-track" id="daylight-cct-track"></div>
                    <input type="range" id="daylight-cct" class="range-min" min="0" max="6500" step="100" value="5500">
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="color-rule-stack-body" id="daylight-body">
            <div class="tune-control-row">
              <span class="tune-control-left">
                <span class="tune-control-label">Start</span>
                <span class="tune-control-reset" id="reset-daylight-start" data-default="60">reset</span>
              </span>
              <span class="tune-control-impact" id="daylight-start-impact"></span>
            </div>
            <div class="tune-slider-row">
              <input type="range" id="daylight-start" min="-180" max="180" step="30" value="60">
              <div class="tune-slider-word" id="daylight-start-text">1 hr after sunrise</div>
            </div>
            <div class="tune-control-row">
              <span class="tune-control-left">
                <span class="tune-control-label">End</span>
                <span class="tune-control-reset" id="reset-daylight-end" data-default="-60">reset</span>
              </span>
              <span class="tune-control-impact" id="daylight-end-impact"></span>
            </div>
            <div class="tune-slider-row">
              <input type="range" id="daylight-end" min="-180" max="180" step="30" value="-60">
              <div class="tune-slider-word" id="daylight-end-text">1 hr before sunset</div>
            </div>
            <div class="tune-control-row">
              <span class="tune-control-left">
                <span class="tune-control-label">Fade</span>
                <span class="tune-control-reset" id="reset-daylight-fade" data-default="60">reset</span>
              </span>
              <span class="tune-control-impact" id="daylight-fade-text">1 hr</span>
            </div>
            <div class="tune-slider-row">
              <input type="range" id="daylight-fade" min="0" max="300" step="30" value="60">
            </div>
            <div class="tune-control-row">
              <span class="tune-control-left">
                <span class="tune-control-label">Sun sensitivity</span>
                <span class="tune-control-reset" id="reset-color-sensitivity" data-default="6">reset</span>
              </span>
              <span class="tune-control-impact" id="color-sensitivity-text">1.50: strong</span>
            </div>
            <div class="tune-slider-row">
              <input type="range" id="color-sensitivity" min="0" max="9" step="1" value="6">
            </div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <!-- Brightness -->
  <div class="rhythm-card" id="rhythm-brightness-card">
    <div class="rhythm-card-header" onclick="toggleRhythmCard('rhythm-brightness-card', 'rhythm_brightness_expanded')">
      <span class="rhythm-card-chevron">&#x203A;</span>
      <span class="rhythm-card-title">Brightness</span>
      <span class="rhythm-card-val" id="rhythm-brightness-val">1 – 100%</span>
    </div>
    <div class="rhythm-card-body" id="rhythm-brightness-body">
      <div class="tune-control-row" style="padding-left:0;">
        <span class="tune-control-left"><span class="tune-control-label">Range</span></span>
        <span class="tune-control-impact" id="brightness-range-display">1 – 100%</span>
      </div>
      <div class="tune-slider-row">
        <div class="dual-range">
          <div class="dual-track" id="brightness-track" style="background:linear-gradient(to right,#111,#fff);">
            <div class="dual-mask" id="brightness-mask-left"></div>
            <div class="dual-mask" id="brightness-mask-right"></div>
          </div>
          <input type="range" id="brightness-min" class="range-min" min="1" max="100" step="1" value="1">
          <input type="range" id="brightness-max" class="range-max" min="1" max="100" step="1" value="100">
        </div>
      </div>
    </div>
  </div>
</div>

<script src="./shared.js"></script>
<script>
// ============================================================
// Circadian Light Designer - Ascend/Descend Model
// ============================================================

const GRAPH_Y_MAX = 125;
const SPEED_LABELS = ['', 'Calm', 'Gentle', 'Soft', 'Smooth', 'Balanced', 'Crisp', 'Fast', 'Snappy', 'Quick', 'Sharp'];
const SPEED_TO_SLOPE = [0, 0.4, 0.6, 0.8, 1.0, 1.3, 1.7, 2.3, 3.0, 4.0, 5.5];

// Colors matching llm_access.html
const ASCEND_COLORS = {
  shade: 'rgba(120,190,255,0.35)',
  text: '#5cb3ff',
  boundary: 'rgba(120,185,245,0.55)',
  axis: '#5cb3ff',
  hoverBg: '#7fc7ff'
};
const DESCEND_COLORS = {
  shade: 'rgba(255,220,100,0.12)',
  text: '#ffe680',
  boundary: 'rgba(255,230,128,0.85)',
  axis: 'rgba(255,230,128,0.7)',
  hoverBg: '#ffe680'
};

// Activity Presets
// warm_night_enabled: true for young, adult, nightowl
// daylight_cct: 5500 for all (intensity-based daylight blend)
const ACTIVITY_PRESETS = {
  young: { wake_time: 6.0, bed_time: 18.0, ascend_start: 0.0, descend_start: 12.0, warm_night_enabled: true, daylight_cct: 5500 },
  adult: { wake_time: 7.0, bed_time: 21.0, ascend_start: 3.0, descend_start: 12.0, warm_night_enabled: true, daylight_cct: 5500 },
  nightowl: { wake_time: 10.0, bed_time: 2.0, ascend_start: 8.0, descend_start: 16.0, warm_night_enabled: true, daylight_cct: 5500 },
  duskbat: { wake_time: 14.0, bed_time: 6.0, ascend_start: 12.0, descend_start: 20.0, warm_night_enabled: false, daylight_cct: 5500 },
  shiftearly: { wake_time: 18.0, bed_time: 10.0, ascend_start: 16.0, descend_start: 0.0, warm_night_enabled: false, daylight_cct: 5500 },
  shiftlate: { wake_time: 22.0, bed_time: 14.0, ascend_start: 20.0, descend_start: 4.0, warm_night_enabled: false, daylight_cct: 5500 }
};

const SENSITIVITY_STEPS = [
  { label: "None",        multiplier: 0.00 },
  { label: "Minimal",     multiplier: 0.15 },
  { label: "Low",         multiplier: 0.35 },
  { label: "Slight",      multiplier: 0.55 },
  { label: "Moderate",    multiplier: 0.80 },
  { label: "Noticeable",  multiplier: 1.10 },
  { label: "Strong",      multiplier: 1.50 },
  { label: "High",        multiplier: 2.00 },
  { label: "Very high",   multiplier: 3.00 },
  { label: "Maximum",     multiplier: 5.00 },
];

function findClosestSensitivityStep(value) {
  let closest = 0, minDist = Infinity;
  for (let i = 0; i < SENSITIVITY_STEPS.length; i++) {
    const dist = Math.abs(SENSITIVITY_STEPS[i].multiplier - value);
    if (dist < minDist) { minDist = dist; closest = i; }
  }
  return closest;
}

// Chart schedule toggles — pick which wake/bed timing the chart displays
let chartWakeMode = 'primary';
let chartBedMode = 'primary';

// State
let config = {
  ascend_start: 3.0,
  descend_start: 12.0,
  wake_time: 7.0,
  bed_time: 21.0,
  wake_speed: 6,
  bed_speed: 4,
  min_color_temp: 500,
  max_color_temp: 6500,
  min_brightness: 1,
  max_brightness: 100,
  max_dim_steps: 10,  // home-wide setting, read from config
  warm_night_enabled: true,  // default matches adult preset
  warm_night_mode: 'all',
  warm_night_target: 2700,
  warm_night_start: -60,  // minutes offset from sunset (negative = before)
  warm_night_end: 60,     // minutes offset from sunrise (positive = after)
  warm_night_fade: 60,    // fade duration in minutes
  daylight_enabled: true,
  daylight_cct: 5500,
  daylight_start: 60,    // minutes offset from sunrise (positive = after)
  daylight_end: -60,     // minutes offset from sunset (negative = before)
  daylight_fade: 60,
  color_sensitivity: 1.50,
  activity_preset: 'adult',
  use_ha_location: true,
  latitude: 35.0,
  longitude: -78.6,
  timezone: 'US/Eastern'
};

// Current sun times (cached for solar rules)
let sunTimes = { sunrise: 6, sunset: 18, solarNoon: 12, solarMid: 0 };

// Cursor state — always present, initialized to current time
const _nowInit = new Date();
let cursorHour = _nowInit.getHours() + _nowInit.getMinutes() / 60;
let graphData = null;

// Live Design state
let liveDesignEnabled = false;
let liveDesignAreaId = null;
let liveDesignFirstApply = false;  // Use longer transition on first apply after entering

// ============================================================
// Solar Calculation Helpers
// ============================================================

const rad = d => d * Math.PI / 180;

function wrap24(x) {
  return ((x % 24) + 24) % 24;
}

// Check if hour is within a time window (handles midnight wrap-around)
function isInTimeWindow(hour, windowStart, windowEnd) {
  hour = wrap24(hour);
  windowStart = wrap24(windowStart);
  windowEnd = wrap24(windowEnd);

  if (windowStart > windowEnd) {
    // Wraps around midnight
    return hour >= windowStart || hour <= windowEnd;
  } else {
    return hour >= windowStart && hour <= windowEnd;
  }
}

// Get warm_night window boundaries based on current config and sun times
function getWarmNightWindow() {
  if (!config || !sunTimes || !config.warm_night_enabled) return null;

  const { sunrise, sunset } = sunTimes;
  const solarMid = wrap24(sunTimes.solarMid);
  const startOffsetHrs = config.warm_night_start / 60;
  const endOffsetHrs = config.warm_night_end / 60;
  const mode = config.warm_night_mode;

  let windowStart, windowEnd;
  if (mode === 'sunrise') {
    windowStart = solarMid;
    windowEnd = wrap24(sunrise + endOffsetHrs);
  } else if (mode === 'sunset') {
    windowStart = wrap24(sunset + startOffsetHrs);
    windowEnd = solarMid;
  } else {
    windowStart = wrap24(sunset + startOffsetHrs);
    windowEnd = wrap24(sunrise + endOffsetHrs);
  }

  return { windowStart, windowEnd };
}

// ============================================================
// Single-Point Value Calculation (source of truth)
// ============================================================

/**
 * Check if hour is in window and calculate fade weight.
 */
function getWindowWeight(hour, windowStart, windowEnd, fadeHrs) {
  const h = wrap24(hour);
  let inWindow = false;
  let distFromStart = 0;
  let distToEnd = 0;

  if (windowStart > windowEnd) {
    // Wraps around midnight
    inWindow = h >= windowStart || h <= windowEnd;
    if (inWindow) {
      distFromStart = h >= windowStart ? (h - windowStart) : (h + 24 - windowStart);
      distToEnd = h <= windowEnd ? (windowEnd - h) : (windowEnd + 24 - h);
    }
  } else {
    // Normal range
    inWindow = h >= windowStart && h <= windowEnd;
    if (inWindow) {
      distFromStart = h - windowStart;
      distToEnd = windowEnd - h;
    }
  }

  if (!inWindow) {
    return { inWindow: false, weight: 0 };
  }

  // Calculate fade weight
  let weight = 1;
  if (fadeHrs > 0.01) {
    if (distFromStart < fadeHrs) {
      weight = Math.min(weight, distFromStart / fadeHrs);
    }
    if (distToEnd < fadeHrs) {
      weight = Math.min(weight, distToEnd / fadeHrs);
    }
  }

  return { inWindow: true, weight };
}

/**
 * Apply warm_night and daylight blend solar rules to a single CCT value at a given hour.
 */
function applySolarRuleAtHour(baseCCT, hour) {
  if (!sunTimes) return baseCCT;

  let cct = baseCCT;
  const { sunrise, sunset, solarMid } = sunTimes;

  // Warm night — ceiling
  if (config.warm_night_enabled) {
    const warmTarget = config.warm_night_target;

    if (cct > warmTarget) {
      const fadeHrs = config.warm_night_fade / 60;
      const startOffsetHrs = config.warm_night_start / 60;
      const endOffsetHrs = config.warm_night_end / 60;
      const mode = config.warm_night_mode;

      let ws, we;
      if (mode === 'sunrise') {
        ws = wrap24(solarMid);
        we = wrap24(sunrise + endOffsetHrs);
      } else if (mode === 'sunset') {
        ws = wrap24(sunset + startOffsetHrs);
        we = wrap24(solarMid);
      } else {
        ws = wrap24(sunset + startOffsetHrs);
        we = wrap24(sunrise + endOffsetHrs);
      }

      const { inWindow, weight } = getWindowWeight(hour, ws, we, fadeHrs);
      if (inWindow && weight > 0) {
        cct = cct + (warmTarget - cct) * weight;
      }
    }
  }

  // Cool day color blend (intensity-based)
  // Condition multiplier from dropdown modulates clear-sky lux at this hour's sun elevation
  if (config.daylight_enabled !== false) {
    const conditionMult = parseFloat(document.getElementById('modeled-conditions')?.value ?? '1.0');
    const dateStr = getSelectedDateISO();
    const elev = getSunElevationAtHour(hour, config.latitude, config.longitude, dateStr);
    const outdoorNorm = elevationToOutdoorNorm(elev, conditionMult);
    const daylightCct = config.daylight_cct || 0;
    const colorSensitivity = config.color_sensitivity ?? 1.50;
    if (daylightCct > 0 && outdoorNorm > 0) {
      let blend = Math.min(1.0, outdoorNorm * colorSensitivity);
      // Apply start/end offsets and fade
      const startOffsetHrs = (config.daylight_start ?? 60) / 60;
      const endOffsetHrs = (config.daylight_end ?? -60) / 60;
      const fadeHrs = (config.daylight_fade || 60) / 60;
      const ds = wrap24(sunrise + startOffsetHrs);
      const de = wrap24(sunset + endOffsetHrs);
      const { inWindow, weight } = getWindowWeight(hour, ds, de, fadeHrs);
      blend *= weight;
      const daylightTarget = daylightCct;
      if (daylightTarget > cct && blend > 0) {
        cct += (daylightTarget - cct) * blend;
      }
    }
  }

  return cct;
}

/**
 * Get Python weekday (0=Mon..6=Sun) for the chart date slider.
 */
function getChartWeekday() {
  const slider = document.getElementById('chart-date-slider');
  const dayOffset = slider ? parseInt(slider.value) : 0;
  const target = new Date(new Date().getFullYear(), 0, 1 + dayOffset);
  return (target.getDay() + 6) % 7;  // JS getDay (0=Sun) → Python weekday (0=Mon)
}

/**
 * Resolve effective wake/bed times based on alt days and overrides (JS mirror of brain.py).
 */
function resolveEffectiveTiming(hour, weekday, wakeWeekdayOverride) {
  let wake = config.wake_time;
  let bed = config.bed_time;

  // Chart schedule toggles override weekday-based logic
  if (chartWakeMode === 'alt' && config.wake_alt_time != null) {
    wake = config.wake_alt_time;
  } else if (chartWakeMode === 'primary') {
    // use primary (default)
  } else {
    // Weekday-based fallback
    const wakeWd = wakeWeekdayOverride != null ? wakeWeekdayOverride : weekday;
    if (config.wake_alt_time != null && (config.wake_alt_days || []).includes(wakeWd)) {
      wake = config.wake_alt_time;
    }
  }

  if (chartBedMode === 'alt' && config.bed_alt_time != null) {
    bed = config.bed_alt_time;
  } else if (chartBedMode === 'primary') {
    // use primary (default)
  } else {
    // Weekday-based fallback
    let bedWeekday = weekday;
    if (hour < config.ascend_start) {
      bedWeekday = (weekday + 6) % 7;  // yesterday
    }
    if (config.bed_alt_time != null && (config.bed_alt_days || []).includes(bedWeekday)) {
      bed = config.bed_alt_time;
    }
  }

  return { wake, bed };
}

/**
 * JS mirror of brain.py inverse_midpoint.
 */
function inverseMidpoint(x, targetValue, slope, y0, y1) {
  const epsilon = 0.001;
  const clamped = Math.max(y0 + epsilon, Math.min(y1 - epsilon, targetValue));
  const ratio = (clamped - y0) / (y1 - y0);
  try {
    return x + Math.log((1 - ratio) / ratio) / slope;
  } catch (e) {
    return x;
  }
}

/**
 * JS mirror of brain.py compute_shifted_midpoint.
 */
function computeShiftedMidpoint(targetTimeH48, brightnessPct, slope, bMinNorm, bMaxNorm) {
  if (brightnessPct === 50) return targetTimeH48;
  const targetNorm = bMinNorm + (bMaxNorm - bMinNorm) * (brightnessPct / 100);
  return inverseMidpoint(targetTimeH48, targetNorm, slope, bMinNorm, bMaxNorm);
}

/**
 * Calculate brightness, CCT, and phase at a specific hour.
 * Single source of truth for curve + solar rule calculations.
 */
function getValuesAtTime(hour) {
  // Phase detection
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  const h48 = hour < tAscend ? hour + 24 : hour;
  const inAscend = h48 >= tAscend && h48 < tDescend;
  const phase = inAscend ? 'Ascend' : 'Descend';

  // Slopes - clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];

  // Config bounds (only use these, no runtime overrides)
  const bMin = config.min_brightness / 100;
  const bMax = config.max_brightness / 100;
  const cLow = config.min_color_temp;
  const cHigh = config.max_color_temp;

  // Resolve effective timing with phase-aware weekday for wake
  // Use cursor/now phase (not per-hour) — when in descent, entire ascend = tomorrow
  const chartWeekday = getChartWeekday();
  const nowH = cursorHour !== null ? cursorHour : new Date().getHours() + new Date().getMinutes() / 60;
  const nowH48 = nowH < tAscend ? nowH + 24 : nowH;
  const nowInAscend = nowH48 >= tAscend && nowH48 < tDescend;
  const wakeWd = !nowInAscend && nowH >= tAscend ? (chartWeekday + 1) % 7 : chartWeekday;
  const timing = resolveEffectiveTiming(hour, chartWeekday, wakeWd);

  // Brightness midpoint
  let wakeMid = timing.wake;
  let bedMid = timing.bed;

  // Apply brightness target shift
  const slope = inAscend ? kAscend : -kDescend;
  const brightPct = inAscend ? (config.wake_brightness || 50) : (config.bed_brightness || 50);
  if (brightPct !== 50) {
    if (inAscend) {
      let mid48 = wakeMid;
      while (mid48 < tAscend) mid48 += 24;
      while (mid48 > tDescend) mid48 -= 24;
      const shifted = computeShiftedMidpoint(mid48, brightPct, slope, bMin, bMax);
      wakeMid = shifted % 24;
    } else {
      let mid48 = bedMid;
      while (mid48 < tDescend) mid48 += 24;
      while (mid48 > tDescend + 24) mid48 -= 24;
      const shifted = computeShiftedMidpoint(mid48, brightPct, slope, bMin, bMax);
      bedMid = shifted % 24;
    }
  }

  let wakeMid48 = wakeMid;
  while (wakeMid48 < tAscend) wakeMid48 += 24;
  while (wakeMid48 > tDescend) wakeMid48 -= 24;

  let bedMid48 = bedMid;
  while (bedMid48 < tDescend) bedMid48 += 24;
  while (bedMid48 > tDescend + 24) bedMid48 -= 24;

  // Calculate brightness
  let brightnessNorm;
  if (inAscend) {
    brightnessNorm = logistic(h48, wakeMid48, kAscend, bMin, bMax);
  } else {
    const hDescend48 = h48 < tDescend ? h48 + 24 : h48;
    brightnessNorm = logistic(hDescend48, bedMid48, -kDescend, bMin, bMax);
  }
  const brightness = brightnessNorm * 100;

  // Color midpoint — same brightness target shift (circadian: color follows brightness)
  let colorWakeMid = timing.wake;
  let colorBedMid = timing.bed;

  const cSlope = inAscend ? kAscend : -kDescend;
  const cBrightPct = inAscend ? (config.wake_brightness || 50) : (config.bed_brightness || 50);
  if (cBrightPct !== 50) {
    if (inAscend) {
      let cMid48 = colorWakeMid;
      while (cMid48 < tAscend) cMid48 += 24;
      while (cMid48 > tDescend) cMid48 -= 24;
      colorWakeMid = computeShiftedMidpoint(cMid48, cBrightPct, cSlope, bMin, bMax) % 24;
    } else {
      let cMid48 = colorBedMid;
      while (cMid48 < tDescend) cMid48 += 24;
      while (cMid48 > tDescend + 24) cMid48 -= 24;
      colorBedMid = computeShiftedMidpoint(cMid48, cBrightPct, cSlope, bMin, bMax) % 24;
    }
  }

  let colorWakeMid48 = colorWakeMid;
  while (colorWakeMid48 < tAscend) colorWakeMid48 += 24;
  while (colorWakeMid48 > tDescend) colorWakeMid48 -= 24;

  let colorBedMid48 = colorBedMid;
  while (colorBedMid48 < tDescend) colorBedMid48 += 24;
  while (colorBedMid48 > tDescend + 24) colorBedMid48 -= 24;

  // Calculate base CCT
  let colorNorm;
  if (inAscend) {
    colorNorm = logistic(h48, colorWakeMid48, kAscend, 0, 1);
  } else {
    const hDescend48 = h48 < tDescend ? h48 + 24 : h48;
    colorNorm = logistic(hDescend48, colorBedMid48, -kDescend, 0, 1);
  }
  colorNorm = Math.max(0, Math.min(1, colorNorm));
  let cct = cLow + (cHigh - cLow) * colorNorm;

  // Apply solar rules
  cct = applySolarRuleAtHour(cct, hour);

  return { brightness, cct, phase };
}

function dayOfYear(dateStr) {
  const d = new Date(dateStr + 'T12:00:00');
  const s = new Date(d.getFullYear(), 0, 0);
  return Math.floor((d - s) / 86400000);
}

function solarDeclination(doy) {
  return (23.44 * Math.PI / 180) * Math.sin(2 * Math.PI * (284 + doy) / 365);
}

/**
 * Equation of time correction in hours, from day-of-year and longitude.
 * Accounts for Earth's elliptical orbit and axial tilt (~±16 min).
 */
function equationOfTimeHours(doy, lon) {
  const J = doy + ((lon < 0 ? 360 + lon : lon) / 360);
  const M = (357.5291 + 0.9856 * J) % 360;
  const C = 1.9148 * Math.sin(rad(M)) + 0.02 * Math.sin(rad(2 * M)) + 0.0003 * Math.sin(rad(3 * M));
  const L = (M + 102.9372 + C + 180) % 360;
  return (0.0053 * Math.sin(rad(M)) - 0.0069 * Math.sin(rad(2 * L))) * 24;
}

function getSunTimes(lat, lon, dateStr) {
  const date = new Date(dateStr || new Date().toISOString());
  const n = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
  const J = n + ((lon < 0 ? 360 + lon : lon) / 360);
  const M = (357.5291 + 0.9856 * J) % 360;
  const C = 1.9148 * Math.sin(rad(M)) + 0.02 * Math.sin(rad(2 * M)) + 0.0003 * Math.sin(rad(3 * M));
  const L = (M + 102.9372 + C + 180) % 360;
  const D = Math.asin(Math.sin(rad(L)) * Math.sin(rad(23.44)));
  const cosH0 = (Math.cos(rad(90.833)) - Math.sin(rad(lat)) * Math.sin(D)) / (Math.cos(rad(lat)) * Math.cos(D));

  if (cosH0 < -1 || cosH0 > 1) {
    const eot = equationOfTimeHours(n, lon);
    const sn = 12 - date.getTimezoneOffset() / 60 - (lon / 15) + eot;
    return { sunrise: sn - 6, sunset: sn + 6, solarNoon: sn, solarMid: (sn + 12) % 24 };
  }

  const H0 = Math.acos(cosH0);
  const dl = (2 * H0 * 180 / Math.PI) / 15;
  const tz = -date.getTimezoneOffset() / 60;
  const eot = equationOfTimeHours(n, lon);
  const sn = 12 + tz - (lon / 15) + eot;
  return { sunrise: sn - dl / 2, sunset: sn + dl / 2, solarNoon: sn, solarMid: (sn + 12) % 24 };
}

/**
 * Estimate sun elevation (degrees) at a given hour, using lat/lon and date.
 * Returns 0 for below-horizon.
 */
function getSunElevationAtHour(hour, lat, lon, dateStr) {
  const date = new Date(dateStr || new Date().toISOString());
  const doy = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
  const decl = solarDeclination(doy);
  const latRad = lat * Math.PI / 180;
  const tz = -date.getTimezoneOffset() / 60;
  const eot = equationOfTimeHours(doy, lon);
  const solarNoon = 12 + tz - (lon / 15) + eot;
  const hourAngle = (hour - solarNoon) * 15 * Math.PI / 180;
  const sinElev = Math.sin(latRad) * Math.sin(decl) + Math.cos(latRad) * Math.cos(decl) * Math.cos(hourAngle);
  return Math.max(0, Math.asin(sinElev) * 180 / Math.PI);
}

/**
 * Convert sun elevation to outdoor_normalized (0-1) with condition multiplier.
 * Models: clear_sky_lux = 120000 * sin(elev), then log-scale to 0-1.
 */
function elevationToOutdoorNorm(elevDeg, conditionMultiplier) {
  if (elevDeg <= 0 || conditionMultiplier <= 0) return 0;
  const FULL_SUN_INTENSITY = 8.4;
  const clearSkyLux = 120000 * Math.sin(elevDeg * Math.PI / 180);
  const estimatedLux = clearSkyLux * conditionMultiplier;
  if (estimatedLux <= 300) return 0;
  return Math.min(1.0, Math.log2(estimatedLux / 300) / FULL_SUN_INTENSITY);
}

function getSelectedDateISO() {
  const slider = document.getElementById('chart-date-slider');
  const dayOffset = slider ? parseInt(slider.value) : 0;
  const now = new Date();
  const target = new Date(now.getFullYear(), 0, 1 + dayOffset);
  return target.toISOString().split('T')[0];
}

// ============================================================
// Color Helpers - loaded from shared.js
// ============================================================

// Generate color gradient for slider tracks
function updateColorGradients() {
  const minK = config.min_color_temp;
  const maxK = config.max_color_temp;
  const steps = 16;

  // Main color track
  const colorTrack = document.getElementById('color-track');
  if (colorTrack) {
    const stops = [];
    for (let i = 0; i <= steps; i++) {
      const k = 500 + (6000 * i / steps);
      stops.push(`${cctToRGB(k)} ${(i / steps) * 100}%`);
    }
    colorTrack.style.background = `linear-gradient(90deg, ${stops.join(',')})`;

    // Update masks
    const maskLeft = document.getElementById('color-mask-left');
    const maskRight = document.getElementById('color-mask-right');
    if (maskLeft && maskRight) {
      const leftPct = ((minK - 500) / 6000) * 100;
      const rightPct = ((maxK - 500) / 6000) * 100;
      maskLeft.style.left = '0%';
      maskLeft.style.width = `${leftPct}%`;
      maskRight.style.left = `${rightPct}%`;
      maskRight.style.width = `${100 - rightPct}%`;
    }
  }

  // Warm night track - gradient matches slider's dynamic bounds
  const warmTrack = document.getElementById('warm-night-track');
  const warmSlider = document.getElementById('warm-night-target');
  if (warmTrack && warmSlider) {
    const warmMin = parseInt(warmSlider.min) || minK;
    const warmMax = parseInt(warmSlider.max) || maxK;
    const stops = [];
    for (let i = 0; i <= steps; i++) {
      const k = warmMin + ((warmMax - warmMin) * i / steps);
      stops.push(`${cctToRGB(k)} ${(i / steps) * 100}%`);
    }
    warmTrack.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
  }

  // Daylight CCT track - gradient matches slider's dynamic bounds
  const daylightTrack = document.getElementById('daylight-cct-track');
  const daylightSlider = document.getElementById('daylight-cct');
  if (daylightTrack && daylightSlider) {
    const daylightMin = parseInt(daylightSlider.min) || minK;
    const daylightMax = parseInt(daylightSlider.max) || maxK;
    const stops = [];
    for (let i = 0; i <= steps; i++) {
      const k = daylightMin + ((daylightMax - daylightMin) * i / steps);
      stops.push(`${cctToRGB(Math.max(500, k))} ${(i / steps) * 100}%`);
    }
    daylightTrack.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
  }

  // Update target chips
  updateColorChips();
}

function updateColorChips() {
  const warmChip = document.getElementById('warm-night-target-chip');
  if (warmChip) {
    const k = config.warm_night_target;
    warmChip.textContent = `${k} K`;
    warmChip.style.background = cctToRGB(k);
    warmChip.style.color = readableTextColor(cctToRGB(k));
  }

  const daylightChip = document.getElementById('daylight-cct-chip');
  if (daylightChip) {
    const k = config.daylight_cct;
    daylightChip.textContent = k > 0 ? `${k} K` : 'Off';
    daylightChip.style.background = k > 0 ? cctToRGB(k) : '#666';
    daylightChip.style.color = k > 0 ? readableTextColor(cctToRGB(k)) : '#fff';
  }

}

// Apply solar color rules to CCT curve (batch version for chart rendering)
function adjustCCTForSolarRules(cctArray, hoursArray, sunrise, sunset) {
  if (!config.warm_night_enabled && !config.daylight_cct) return;
  for (let i = 0; i < cctArray.length; i++) {
    cctArray[i] = applySolarRuleAtHour(cctArray[i], hoursArray[i]);
  }
}

// ============================================================
// Utility Functions
// ============================================================

function formatHour(h) {
  const h24 = ((h % 24) + 24) % 24;
  let hr = Math.floor(h24);
  let min = Math.round((h24 - hr) * 60);
  // Handle rounding to 60 minutes
  if (min === 60) {
    min = 0;
    hr = (hr + 1) % 24;
  }
  const suffix = hr < 12 ? 'a' : 'p';
  const hr12 = hr === 0 ? 12 : (hr > 12 ? hr - 12 : hr);
  return min === 0 ? `${hr12}:00${suffix}` : `${hr12}:${min.toString().padStart(2, '0')}${suffix}`;
}

function fmtTime(h) {
  return formatHour(h);
}

function logistic(x, midpoint, slope, y0, y1) {
  try {
    const expVal = Math.exp(-slope * (x - midpoint));
    return y0 + (y1 - y0) / (1 + expVal);
  } catch {
    return slope * (x - midpoint) > 0 ? y1 : y0;
  }
}

// ============================================================
// Curve Calculation
// ============================================================

// ============================================================
// Core Calculation Functions (single source of truth)
// These mirror brain.py's CircadianLight.calculate_* methods
// ============================================================

/**
 * Calculate brightness at a specific hour (0-1 scale).
 * This is the single source of truth for brightness calculations.
 */
function calculateBrightnessAtHour(hour) {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  // Determine current phase from cursor
  const cursorH48 = cursorHour !== null ? (cursorHour < tAscend ? cursorHour + 24 : cursorHour) : tAscend;
  const cursorInAscend = cursorH48 >= tAscend && cursorH48 < tDescend;

  // Resolve effective timing with phase-aware weekday for wake
  const chartWeekday = getChartWeekday();
  const nowH = cursorHour !== null ? cursorHour : new Date().getHours() + new Date().getMinutes() / 60;
  const wakeWd = !cursorInAscend && nowH >= tAscend ? (chartWeekday + 1) % 7 : chartWeekday;
  const timing = resolveEffectiveTiming(hour, chartWeekday, wakeWd);

  let wakeMid = timing.wake;
  let bedMid = timing.bed;

  // Clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];

  // Config bounds
  const bMin = config.min_brightness / 100;
  const bMax = config.max_brightness / 100;

  // Phase detection for this hour
  const h48 = hour < tAscend ? hour + 24 : hour;
  const inAscend = h48 >= tAscend && h48 < tDescend;

  // Apply brightness target shift
  const slope = inAscend ? kAscend : -kDescend;
  const brightPct = inAscend ? (config.wake_brightness || 50) : (config.bed_brightness || 50);
  if (brightPct !== 50) {
    if (inAscend) {
      let rawMid48 = wakeMid;
      while (rawMid48 < tAscend) rawMid48 += 24;
      while (rawMid48 > tDescend) rawMid48 -= 24;
      rawMid48 = Math.max(tAscend + 0.01, Math.min(tDescend - 0.01, rawMid48));
      wakeMid = computeShiftedMidpoint(rawMid48, brightPct, slope, bMin, bMax) % 24;
    } else {
      const phaseEnd = tDescend + 24;
      let rawMid48 = bedMid;
      while (rawMid48 < tDescend) rawMid48 += 24;
      while (rawMid48 > phaseEnd) rawMid48 -= 24;
      rawMid48 = Math.max(tDescend + 0.01, Math.min(phaseEnd - 0.01, rawMid48));
      bedMid = computeShiftedMidpoint(rawMid48, brightPct, slope, bMin, bMax) % 24;
    }
  }

  // Lift midpoint to 48h space and clamp to phase boundaries
  let mid48;
  if (inAscend) {
    mid48 = wakeMid;
    while (mid48 < tAscend - 12) mid48 += 24;
    while (mid48 > tDescend + 12) mid48 -= 24;
    mid48 = Math.max(tAscend + 0.01, Math.min(tDescend - 0.01, mid48));
  } else {
    mid48 = bedMid;
    const phaseEnd = tDescend + 24;
    while (mid48 < tDescend - 12) mid48 += 24;
    while (mid48 > phaseEnd + 12) mid48 -= 24;
    mid48 = Math.max(tDescend + 0.01, Math.min(phaseEnd - 0.01, mid48));
  }

  // Calculate brightness from logistic curve
  let value;
  if (inAscend) {
    value = logistic(h48, mid48, kAscend, bMin, bMax);
  } else {
    const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
    value = logistic(hDescend48, mid48, -kDescend, bMin, bMax);
  }

  // Clamp to bounds (matches brain.py)
  return Math.max(bMin, Math.min(bMax, value));
}

/**
 * Calculate color temperature at a specific hour (Kelvin).
 * This is the single source of truth for CCT calculations.
 * @param {number} hour - Hour (0-24)
 * @param {boolean} applySolar - Whether to apply solar rules (default true)
 */
function calculateColorAtHour(hour, applySolar = true) {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  // Determine current phase from cursor
  const cursorH48 = cursorHour !== null ? (cursorHour < tAscend ? cursorHour + 24 : cursorHour) : tAscend;
  const cursorInAscend = cursorH48 >= tAscend && cursorH48 < tDescend;

  // Resolve effective timing with phase-aware weekday for wake
  const chartWeekday = getChartWeekday();
  const nowH = cursorHour !== null ? cursorHour : new Date().getHours() + new Date().getMinutes() / 60;
  const wakeWd = !cursorInAscend && nowH >= tAscend ? (chartWeekday + 1) % 7 : chartWeekday;
  const timing = resolveEffectiveTiming(hour, chartWeekday, wakeWd);

  let colorWakeMid = timing.wake;
  let colorBedMid = timing.bed;

  // Clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];

  // Config bounds
  const cLow = config.min_color_temp;
  const cHigh = config.max_color_temp;

  // Phase detection for this hour
  const h48 = hour < tAscend ? hour + 24 : hour;
  const inAscend = h48 >= tAscend && h48 < tDescend;

  // Apply brightness target shift — color follows brightness on the circadian curve
  const bMin = config.min_brightness / 100;
  const bMax = config.max_brightness / 100;
  const slope = inAscend ? kAscend : -kDescend;
  const brightPct = inAscend ? (config.wake_brightness || 50) : (config.bed_brightness || 50);
  if (brightPct !== 50) {
    if (inAscend) {
      let rawMid48 = colorWakeMid;
      while (rawMid48 < tAscend) rawMid48 += 24;
      while (rawMid48 > tDescend) rawMid48 -= 24;
      rawMid48 = Math.max(tAscend + 0.01, Math.min(tDescend - 0.01, rawMid48));
      colorWakeMid = computeShiftedMidpoint(rawMid48, brightPct, slope, bMin, bMax) % 24;
    } else {
      const phaseEnd = tDescend + 24;
      let rawMid48 = colorBedMid;
      while (rawMid48 < tDescend) rawMid48 += 24;
      while (rawMid48 > phaseEnd) rawMid48 -= 24;
      rawMid48 = Math.max(tDescend + 0.01, Math.min(phaseEnd - 0.01, rawMid48));
      colorBedMid = computeShiftedMidpoint(rawMid48, brightPct, slope, bMin, bMax) % 24;
    }
  }

  // Lift midpoint to 48h space and clamp to phase boundaries
  let mid48;
  if (inAscend) {
    mid48 = colorWakeMid;
    // Lift into valid range first
    while (mid48 < tAscend - 12) mid48 += 24;
    while (mid48 > tDescend + 12) mid48 -= 24;
    // Clamp to phase boundaries (with small margin for numerical stability)
    mid48 = Math.max(tAscend + 0.01, Math.min(tDescend - 0.01, mid48));
  } else {
    mid48 = colorBedMid;
    const phaseEnd = tDescend + 24;
    // Lift into valid range first
    while (mid48 < tDescend - 12) mid48 += 24;
    while (mid48 > phaseEnd + 12) mid48 -= 24;
    // Clamp to phase boundaries (with small margin for numerical stability)
    mid48 = Math.max(tDescend + 0.01, Math.min(phaseEnd - 0.01, mid48));
  }

  // Calculate normalized color value (0-1)
  let normalized;
  if (inAscend) {
    normalized = logistic(h48, mid48, kAscend, 0, 1);
  } else {
    const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
    normalized = logistic(hDescend48, mid48, -kDescend, 0, 1);
  }
  normalized = Math.max(0, Math.min(1, normalized));

  // Convert to Kelvin
  let cct = cLow + (cHigh - cLow) * normalized;

  // Apply solar rules if requested
  if (applySolar) {
    cct = applySolarRuleAtHour(cct, hour);
  }

  return cct;
}

/**
 * Get phase (Ascend/Descend) at a specific hour.
 */
function getPhaseAtHour(hour) {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  const h48 = hour < tAscend ? hour + 24 : hour;
  return h48 < tDescend ? 'Ascend' : 'Descend';
}

/**
 * Generate curve data for chart rendering.
 * Uses the core calculation functions to ensure consistency.
 */
function calculateCurveData() {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  const hours = Array.from({ length: 480 }, (_, i) => (i * 3) / 60);

  // Use core calculation functions for each data point
  const brightness = hours.map(h => calculateBrightnessAtHour(h));
  const cct = hours.map(h => calculateColorAtHour(h, false));  // Solar rules applied separately in renderChart
  const phase = hours.map(h => getPhaseAtHour(h));

  return { hours, brightness, cct, phase, tAscend, tDescend };
}

// ============================================================
// Chart Rendering
// ============================================================

function renderChart() {
  const dateStr = getSelectedDateISO();
  const { sunrise, sunset, solarNoon, solarMid } = getSunTimes(config.latitude, config.longitude, dateStr);

  // Cache sun times for color rules
  sunTimes = { sunrise, sunset, solarNoon, solarMid };
  updateSolarImpacts();

  const data = calculateCurveData();

  // Apply solar color rules to CCT
  adjustCCTForSolarRules(data.cct, data.hours, sunrise, sunset);

  const { hours, brightness, cct, phase, tAscend, tDescend } = data;
  const brightnessPct = brightness.map(v => v * 100);

  // Store graph data for cursor functions (include brightnessPct for 0-100 scale)
  graphData = { ...data, brightnessPct };
  const samplesPerHour = hours.length / 24;

  // Build traces
  const traces = [];

  // Color-gradient brightness curve (filled + line segments)
  const step = 2;
  for (let i = step; i < hours.length; i += step) {
    const color = cctToRGB(cct[i]);
    const fillColor = colorWithAlpha(color, 0.5);
    const x0 = hours[i - step];
    const x1 = hours[i];
    const y0 = brightnessPct[i - step];
    const y1 = brightnessPct[i];

    // Filled area under curve
    traces.push({
      type: 'scatter',
      mode: 'lines',
      x: [x0, x1, x1, x0],
      y: [y0, y1, 0, 0],
      fill: 'toself',
      line: { width: 0 },
      fillcolor: fillColor,
      hoverinfo: 'skip',
      showlegend: false
    });

    // Colored line segment
    traces.push({
      type: 'scatter',
      mode: 'lines',
      x: [x0, x1],
      y: [y0, y1],
      line: { width: 3, color },
      hoverinfo: 'skip',
      showlegend: false
    });
  }

  // Hover trace - CCT colored background, shows phase, no time
  const hoverDetails = brightnessPct.map((v, i) => {
    const pct = Math.round(v);
    const kelvin = Math.round(cct[i]);
    return `${pct}% • ${kelvin}K`;
  });

  const hoverBgColors = cct.map(k => colorWithAlpha(cctToRGB(k), 0.92));
  const hoverTextColors = cct.map(k => readableTextColor(cctToRGB(k)));
  const hoverBorderColors = cct.map(k => colorWithAlpha(cctToRGB(k), 0.65));

  traces.push({
    type: 'scatter',
    mode: 'lines',
    x: hours,
    y: brightnessPct,
    line: { width: 0 },
    showlegend: false,
    text: hoverDetails,
    hovertemplate: '%{text}<extra></extra>',
    hoverlabel: {
      bgcolor: hoverBgColors,
      bordercolor: hoverBorderColors,
      font: { color: hoverTextColors, size: 13 }
    }
  });

  // Legend placeholder for Circadian Light
  traces.push({
    type: 'scatter',
    mode: 'lines',
    x: [null],
    y: [null],
    line: { width: 3, color: '#fff' },
    name: 'Circadian Light',
    hoverinfo: 'skip',
    showlegend: true
  });

  // Cursor point marker trace (CCT-colored ball at cursor position)
  traces.push({
    x: [null],
    y: [null],
    mode: 'markers',
    marker: { size: 14, color: '#fff', line: { width: 2, color: '#fff' } },
    hoverinfo: 'skip',
    showlegend: false,
    name: 'cursor-point'
  });
  window.cursorTraceIndex = traces.length - 1;

  // Shapes and annotations
  const shapes = [];
  const annotations = [];

  const ascendStart = wrap24(config.ascend_start);
  const descendStart = wrap24(config.descend_start);

  // Below-axis annotation positions (tiered: x-ticks → phase → solar → cursor)
  const phaseLabelLineY = -0.08;
  const phaseLabelY = -0.16;
  const solarLabelLineY = -0.18;
  const solarLabelY = -0.25;
  const cursorExtendY = -0.32;

  // X-axis labels (from top to bottom):
  // 1. Time labels (handled by xaxis ticktext at y=0)
  // 2. Phase labels (ascend starts, wake, descend starts, bed)
  // 3. Solar labels (sunrise, sunset, etc.), muted grey

  // Phase labels with vertical lines — phase-aware timing for alt days
  const chartWeekday = getChartWeekday();
  // Determine current phase to resolve correct day for wake vs bed lines
  const nowH = typeof cursorHour !== 'undefined' && cursorHour !== null
    ? cursorHour : new Date().getHours() + new Date().getMinutes() / 60;
  const h48c = nowH < ascendStart ? nowH + 24 : nowH;
  const dStart48 = descendStart <= ascendStart ? descendStart + 24 : descendStart;
  const chartInAscend = h48c >= ascendStart && h48c < dStart48;
  // During ascend: wake=today, bed=today
  // During descend: wake=tomorrow, bed=today (or yesterday if post-midnight)
  let wakeWeekday, bedWeekday;
  if (chartInAscend) {
    wakeWeekday = chartWeekday;
    bedWeekday = chartWeekday;
  } else {
    wakeWeekday = nowH < ascendStart ? chartWeekday : (chartWeekday + 1) % 7;
    bedWeekday = nowH < ascendStart ? (chartWeekday + 6) % 7 : chartWeekday;
  }
  const wakeTiming = resolveEffectiveTiming(nowH, wakeWeekday);
  const bedTiming = resolveEffectiveTiming(nowH, bedWeekday);
  const phaseLabels = [
    { label: 'wake', x: wrap24(wakeTiming.wake), color: ASCEND_COLORS.text, lineColor: ASCEND_COLORS.axis },
    { label: 'bed', x: wrap24(bedTiming.bed), color: DESCEND_COLORS.text, lineColor: DESCEND_COLORS.axis }
  ];

  phaseLabels.forEach(marker => {
    // Vertical line from label up through the graph
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: marker.x, x1: marker.x,
      y0: phaseLabelLineY,
      y1: 1,
      line: { color: marker.lineColor, width: 1, dash: 'dot' }
    });
    const hoverBg = marker.color === ASCEND_COLORS.text ? ASCEND_COLORS.hoverBg : DESCEND_COLORS.hoverBg;
    annotations.push({
      x: marker.x, y: phaseLabelY, xref: 'x', yref: 'paper',
      text: marker.label,
      showarrow: false,
      font: { size: 11, color: marker.color },
      hovertext: fmtTime(marker.x),
      hoverlabel: {
        bgcolor: hoverBg,
        bordercolor: hoverBg,
        font: { color: readableTextColor(hoverBg), size: 12 }
      }
    });
  });

  // Solar labels - all same muted grey color, lower position
  const solarLabelColor = 'rgba(215,215,215,0.8)';
  const solarLineColor = 'rgba(200,200,200,0.35)';
  const solarLabels = [
    { label: 'sunrise', x: wrap24(sunrise) },
    { label: 'sunset', x: wrap24(sunset) }
  ];

  const solarHoverBg = '#3a3a3a';
  solarLabels.forEach(marker => {
    if (!Number.isFinite(marker.x)) return;
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: marker.x, x1: marker.x,
      y0: solarLabelLineY,
      y1: 0,
      line: { color: solarLineColor, width: 1, dash: 'dot' }
    });
    annotations.push({
      x: marker.x, y: solarLabelY, xref: 'x', yref: 'paper',
      text: marker.label,
      showarrow: false,
      font: { size: 10, color: solarLabelColor },
      hovertext: fmtTime(marker.x),
      hoverlabel: {
        bgcolor: solarHoverBg,
        bordercolor: solarHoverBg,
        font: { color: '#fff', size: 12 }
      }
    });
  });

  // Store base shapes/annotations for cursor updates
  window.baseShapes = shapes.slice();
  window.baseAnnotations = annotations.slice();

  const layout = {
    paper_bgcolor: '#0a0a0a',
    plot_bgcolor: '#0a0a0a',
    margin: { t: 10, r: 40, l: 50, b: 70 },
    showlegend: false,
    hovermode: 'closest',
    xaxis: {
      range: [0, 24],
      dtick: 2,
      tickvals: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24],
      ticktext: ['12a', '2a', '4a', '6a', '8a', '10a', '12p', '2p', '4p', '6p', '8p', '10p', '12a'],
      gridcolor: 'rgba(80,100,130,0.22)',
      tickfont: { color: '#c8c8c8' },
      ticklen: 4,
      tickcolor: 'rgba(160,190,220,0.2)'
    },
    yaxis: {
      range: [0, 105],
      gridcolor: 'rgba(80,100,130,0.22)',
      tickfont: { color: '#c8c8c8' },
      ticklen: 4,
      title: 'Brightness (%)',
      titlefont: { color: '#c8c8c8' }
    },
    shapes,
    annotations
  };

  Plotly.react('chart', traces, layout, { displayModeBar: false }).then(() => {
    initChartInteractivity();
    applyCursor();
  });

  // Update date display
  const dateDisplay = document.getElementById('chart-date-display');
  if (dateDisplay) {
    const d = new Date(dateStr + 'T12:00:00');
    dateDisplay.textContent = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }

  // Update color chips (including temp ceiling/floor)
  updateColorChips();
}

// ============================================================
// Chart Interactivity
// ============================================================

function initChartInteractivity() {
  const chart = document.getElementById('chart');
  if (!chart || chart._interactivityInitialized) return;

  const chartWrapper = document.querySelector('.chart-wrapper');
  const hoverLabel = document.getElementById('time-hover-label');

  // Helper to get plot area (Plotly creates this after rendering)
  const getPlotArea = () => {
    // Try multiple selectors for Plotly's plot area
    return chart.querySelector('.cartesianlayer .plot') ||
           chart.querySelector('.plot-container .plot') ||
           chart.querySelector('.nsewdrag');
  };

  // Mouse move for time hover label at top
  chart.addEventListener('mousemove', (ev) => {
    const plotArea = getPlotArea();
    if (!plotArea) return;

    const rect = plotArea.getBoundingClientRect();
    const inside = ev.clientX >= rect.left && ev.clientX <= rect.right &&
                   ev.clientY >= rect.top && ev.clientY <= rect.bottom;

    if (!inside) {
      hoverLabel.style.opacity = '0';
      return;
    }

    const layout = chart._fullLayout;
    const xRange = layout?.xaxis?.range || [0, 24];
    const ratio = (ev.clientX - rect.left) / rect.width;
    const xVal = xRange[0] + ratio * (xRange[1] - xRange[0]);
    const wrapperRect = chartWrapper.getBoundingClientRect();

    hoverLabel.textContent = fmtTime(xVal);
    hoverLabel.style.left = `${ev.clientX - wrapperRect.left}px`;

    // Color based on phase
    const tAscend = config.ascend_start;
    let tDescend = config.descend_start;
    if (tDescend <= tAscend) tDescend += 24;
    let h = xVal;
    if (h < tAscend) h += 24;
    const inAscend = h < tDescend;
    const chipColor = inAscend ? ASCEND_COLORS.hoverBg : DESCEND_COLORS.hoverBg;

    hoverLabel.style.background = chipColor;
    hoverLabel.style.color = readableTextColor(chipColor);
    hoverLabel.style.opacity = '1';
  }, true);  // Use capture phase

  chart.addEventListener('mouseleave', () => {
    hoverLabel.style.opacity = '0';
  }, true);

  // Click for cursor placement - always interactive
  chart.addEventListener('click', (ev) => {
    const plotArea = getPlotArea();
    if (!plotArea) {
      console.log('No plot area found');
      return;
    }

    const rect = plotArea.getBoundingClientRect();
    if (ev.clientX < rect.left || ev.clientX > rect.right ||
        ev.clientY < rect.top || ev.clientY > rect.bottom) {
      return;
    }

    const layout = chart._fullLayout;
    const xRange = layout?.xaxis?.range || [0, 24];
    const ratio = (ev.clientX - rect.left) / rect.width;
    const xVal = xRange[0] + ratio * (xRange[1] - xRange[0]);

    cursorHour = xVal;
    applyCursor();
  }, true);  // Use capture phase

  chart._interactivityInitialized = true;
}

function applyCursor() {
  const chart = document.getElementById('chart');
  const cursorCallout = document.getElementById('cursor-callout');
  const traceIdx = typeof window.cursorTraceIndex === 'number' ? window.cursorTraceIndex : null;

  if (!chart || !window.baseShapes) return;

  const shapes = window.baseShapes.slice();
  const annotations = window.baseAnnotations ? window.baseAnnotations.slice() : [];

  // Get cursor point data using core calculation functions (exact values, no interpolation)
  let cursorPoint = null;
  if (config) {
    cursorPoint = {
      x: cursorHour,
      y: calculateBrightnessAtHour(cursorHour) * 100,  // Convert 0-1 to 0-100
      cct: calculateColorAtHour(cursorHour, true),     // With solar rules
      phase: getPhaseAtHour(cursorHour)
    };
  }

  // Cursor line style - dotted white
  const cursorLineStyle = { color: '#fdfdfd', width: 2, dash: 'dot' };
  const cursorLabelY = -0.26;

  // Add cursor line with gap around the point
  if (cursorPoint) {
    const gap = 3;
    const lowerEnd = Math.max(0, cursorPoint.y - gap);
    const upperStart = Math.min(GRAPH_Y_MAX, cursorPoint.y + gap);

    // Lower segment
    shapes.push({
      type: 'line', xref: 'x', yref: 'y',
      x0: cursorHour, x1: cursorHour, y0: 0, y1: lowerEnd,
      line: cursorLineStyle, layer: 'above'
    });
    // Upper segment
    shapes.push({
      type: 'line', xref: 'x', yref: 'y',
      x0: cursorHour, x1: cursorHour, y0: upperStart, y1: GRAPH_Y_MAX,
      line: cursorLineStyle, layer: 'above'
    });
  } else {
    // Full line if no point
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: cursorHour, x1: cursorHour, y0: 0, y1: 1,
      line: cursorLineStyle, layer: 'above'
    });
  }

  // Cursor line extending below x-axis down to callout
  const cursorExtendY = -0.32;
  shapes.push({
    type: 'line', xref: 'x', yref: 'paper',
    x0: cursorHour, x1: cursorHour, y0: cursorExtendY, y1: 0,
    line: cursorLineStyle, layer: 'above'
  });


  Plotly.relayout(chart, { shapes, annotations });

  // Update cursor callout and marker
  if (cursorPoint) {
    const bri = Math.round(cursorPoint.y);
    const cctVal = Math.round(cursorPoint.cct);
    const color = cctToRGB(cctVal);

    const plotArea = chart.querySelector('.cartesianlayer .plot') || chart.querySelector('.nsewdrag');
    const chartWrapper = document.querySelector('.chart-wrapper');
    if (plotArea && chartWrapper) {
      const rect = plotArea.getBoundingClientRect();
      const chartRect = chart.getBoundingClientRect();
      const wrapperRect = chartWrapper.getBoundingClientRect();
      const layout = chart._fullLayout;
      const xRange = layout?.xaxis?.range || [0, 24];
      const ratio = (cursorHour - xRange[0]) / (xRange[1] - xRange[0] || 1);
      const leftPx = rect.left + ratio * rect.width - wrapperRect.left;

      cursorCallout.textContent = `${fmtTime(cursorHour)} • ${bri}% • ${cctVal}K`;
      cursorCallout.style.left = `${leftPx}px`;
      cursorCallout.style.opacity = '1';

      // Color callout based on CCT
      cursorCallout.style.background = color;
      cursorCallout.style.color = readableTextColor(color);
      cursorCallout.style.borderColor = '#fdfdfd';
    }

    // Update cursor ball marker (CCT-colored with white border)
    if (traceIdx != null) {
      const markerUpdate = {
        x: [[cursorPoint.x]],
        y: [[cursorPoint.y]],
        marker: [{
          size: 14,
          color,
          opacity: 1,
          symbol: 'circle',
          line: { width: 2, color: '#fff' }
        }]
      };
      Plotly.restyle(chart, markerUpdate, traceIdx);
    }

    // Live Design: update lights when cursor values change
    applyLiveLight();
  }

  // Update sleep card phase badges
  updateSleepPhaseBadges();
}

function updateSleepPhaseBadges() {
  // Phase badges removed from sleep card header (kept for chart cursor)
}

// ============================================================
// UI Updates
// ============================================================

function updateDisplay(id, value) {
  const el = document.getElementById(id);
  if (el) el.textContent = value;
}


/**
 * Show/hide design-mode-only controls based on Live Design state.
 */
function updateDesignModeUI() {
  // Chart toolbar and simple mode checkbox are always visible now.
  // This function retained for Live Design status indicator updates if needed.
}

/**
 * Show/hide chart schedule toggles based on whether alt times are configured.
 */
function updateScheduleToggles() {
  const el = document.getElementById('chart-schedule-toggles');
  if (!el) return;
  const hasAlt = config.wake_alt_time != null || config.bed_alt_time != null;
  el.style.display = hasAlt ? 'flex' : 'none';
}

/**
 * Snap cursor to current time and re-render.
 */
function snapCursorToNow() {
  const now = new Date();
  cursorHour = now.getHours() + now.getMinutes() / 60;
  renderChart();
  applyCursor();
}
function positionTimelineBadges() {
  const ascendBadge = document.getElementById('ascend-start-badge');
  const descendBadge = document.getElementById('descend-start-badge');

  if (ascendBadge) {
    const pct = (config.ascend_start / 24) * 100;
    ascendBadge.style.left = `${pct}%`;
  }
  if (descendBadge) {
    const pct = (config.descend_start / 24) * 100;
    descendBadge.style.left = `${pct}%`;
  }
}

function updateSliderValue(sliderId, displayId, formatter) {
  const slider = document.getElementById(sliderId);
  if (!slider) return;
  slider.addEventListener('input', () => {
    const val = parseFloat(slider.value);
    updateDisplay(displayId, formatter(val));
    syncConfigFromUI();
    renderChart();
  });
}

// Day bubble helpers
function getSelectedDays(containerId) {
  const container = document.getElementById(containerId);
  if (!container) return [];
  return Array.from(container.querySelectorAll('.day-bubble.active'))
    .map(btn => parseInt(btn.dataset.day));
}

function setSelectedDays(containerId, days) {
  const container = document.getElementById(containerId);
  if (!container) return;
  container.querySelectorAll('.day-bubble').forEach(btn => {
    const day = parseInt(btn.dataset.day);
    btn.classList.toggle('active', days.includes(day));
  });
}

// Sleep card helpers
const DAY_ABBR = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
const DAY_SHORT = ['Mo', 'Tu', 'We', 'Th', 'Fr', 'Sa', 'Su'];

function formatDayList(dayIndices) {
  if (!dayIndices || dayIndices.length === 0 || dayIndices.length === 7) return 'Every day';
  const sorted = [...dayIndices].sort((a, b) => a - b);
  if (sorted.length === 5 && sorted.join(',') === '0,1,2,3,4') return 'Weekdays';
  if (sorted.length === 2 && sorted.join(',') === '5,6') return 'Weekends';
  return sorted.map(d => DAY_ABBR[d]).join(', ');
}

function getSleepPhase() {
  // Determine current/next for wake and bed based on cursor time
  const now = typeof cursorHour !== 'undefined' && cursorHour !== null
    ? cursorHour : new Date().getHours() + new Date().getMinutes() / 60;
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;
  const h = now < tAscend ? now + 24 : now;
  const inAscend = h >= tAscend && h < tDescend;
  return { wake: inAscend ? 'current' : 'next', bed: inAscend ? 'next' : 'current' };
}

function updateSleepSummary() {
  const ALL = [0, 1, 2, 3, 4, 5, 6];
  const phase = getSleepPhase();

  ['wake', 'bed'].forEach(prefix => {
    const primaryDays = getSelectedDays(`${prefix}-days`);
    const altDays = primaryDays.length === 0
      ? ALL.slice()
      : (primaryDays.length < 7 ? ALL.filter(d => !primaryDays.includes(d)) : []);
    const hasAlt = altDays.length > 0;

    // Determine which time to show (primary or alt based on today/next)
    const p = phase[prefix];
    const primaryTime = prefix === 'wake' ? config.wake_time : config.bed_time;
    const altSlider = document.getElementById(`${prefix}-alt-time`);
    const altTimeVal = hasAlt && altSlider ? parseFloat(altSlider.value) % 24 : null;
    let timeVal = primaryTime;

    if (altTimeVal != null && altDays.length > 0) {
      const jsToday = new Date().getDay();
      const pyToday = jsToday === 0 ? 6 : jsToday - 1;
      if (p === 'current') {
        if (altDays.includes(pyToday)) timeVal = altTimeVal;
      } else {
        const nowDecimal = new Date().getHours() + new Date().getMinutes() / 60;
        let startOffset = 1;
        if (prefix === 'bed' && nowDecimal < (config.descend_start || 20)) startOffset = 0;
        if (prefix === 'wake' && nowDecimal < (config.ascend_start || 6)) startOffset = 0;
        const checkDay = (pyToday + startOffset) % 7;
        if (altDays.includes(checkDay)) timeVal = altTimeVal;
      }
    }

    // Update header summary
    updateDisplay(`sleep-sum-${prefix}-time`, formatHour(timeVal));
    const bri = prefix === 'wake' ? (config.wake_brightness || 50) : (config.bed_brightness || 50);
    updateDisplay(`sleep-sum-${prefix}-bri`, bri + '%');

    // Update slider word labels
    const speed = prefix === 'wake' ? config.wake_speed : config.bed_speed;
    updateDisplay(`${prefix}-speed-word`, SPEED_LABELS[speed]);
    updateDisplay(`${prefix}-brightness-word`, getBrightnessWord(bri));

    // Time control labels — "Time" when single, "Primary"/"Secondary" when alt exists
    const primaryLabel = document.getElementById(`${prefix}-primary-label`);
    const altLabel = document.getElementById(`${prefix}-alt-label`);
    if (primaryLabel) primaryLabel.textContent = hasAlt ? 'Primary' : 'Time';
    if (altLabel) altLabel.textContent = 'Secondary';

    // Render clickable day indicators inside time blocks
    const primaryDaysEl = document.getElementById(`${prefix}-primary-days`);
    const altDaysEl = document.getElementById(`${prefix}-alt-days`);
    [
      { el: primaryDaysEl, days: hasAlt ? primaryDays : ALL, isPrimary: true },
      { el: altDaysEl, days: altDays, isPrimary: false }
    ].forEach(({ el, days, isPrimary }) => {
      if (!el) return;
      el.innerHTML = ALL.map(d =>
        `<button class="day-indicator${days.includes(d) ? ' active' : ''}" data-day="${d}" data-block="${isPrimary ? 'primary' : 'secondary'}">${DAY_SHORT[d]}</button>`
      ).join('');
    });

    // Toggle no-alt class
    const blocks = document.getElementById(`${prefix}-time-blocks`);
    if (blocks) blocks.classList.toggle('no-alt', !hasAlt);
  });
}

function getBrightnessWord(val) {
  if (val <= 20) return 'Dim';
  if (val <= 35) return 'Low';
  if (val <= 55) return 'Moderate';
  if (val <= 70) return 'Bright';
  return 'Very bright';
}

function toggleRhythmCard(cardId, storageKey) {
  const card = document.getElementById(cardId);
  if (!card) return;
  const isOpen = card.classList.toggle('is-open');
  localStorage.setItem(storageKey, isOpen ? 'true' : 'false');
}

function initSleepDayIndicators() {
  // Delegate day-indicator clicks from the sleep card body
  const body = document.getElementById('rhythm-sleep-body');
  if (!body) return;
  body.addEventListener('click', (e) => {
    const indicator = e.target.closest('.day-indicator');
    if (!indicator) return;
    // Determine wake or bed from closest time group container
    const blocksContainer = indicator.closest('.sleep-time-group');
    if (!blocksContainer) return;
    const prefix = blocksContainer.id.includes('wake') ? 'wake' : 'bed';
    const dayIndex = parseInt(indicator.dataset.day);
    const bubblesContainer = document.getElementById(`${prefix}-days`);
    if (!bubblesContainer) return;

    const bubble = bubblesContainer.querySelector(`.day-bubble[data-day="${dayIndex}"]`);
    if (!bubble) return;
    bubble.classList.toggle('active');

    const altBlock = document.getElementById(`${prefix}-alt-time-row`);
    const parentBlocks = altBlock ? altBlock.parentElement : null;
    const activeCount = bubblesContainer.querySelectorAll('.day-bubble.active').length;
    const shouldShow = activeCount > 0 && activeCount < 7;
    if (parentBlocks) {
      const wasHidden = parentBlocks.classList.contains('no-alt');
      parentBlocks.classList.toggle('no-alt', !shouldShow);
      if (shouldShow && wasHidden) {
        const altSlider = altBlock.querySelector('input[type="range"]');
        if (altSlider && prefix === 'wake') {
          const restored = config._wake_alt_time_last ?? config.wake_time;
          let val = restored;
          if (val < config.ascend_start) val += 24;
          altSlider.value = val;
        } else if (altSlider && prefix === 'bed') {
          const restored = config._bed_alt_time_last ?? config.bed_time;
          let val = restored;
          if (val < config.descend_start) val += 24;
          altSlider.value = val;
        }
      }
    }

    syncConfigFromUI();
    renderChart();
  });
}

function syncConfigFromUI() {
  config.ascend_start = parseFloat(document.getElementById('ascend-start').value);
  config.descend_start = parseFloat(document.getElementById('descend-start').value) % 24;
  config.wake_time = parseFloat(document.getElementById('wake-time').value);
  config.bed_time = parseFloat(document.getElementById('bed-time').value) % 24;
  config.wake_speed = parseInt(document.getElementById('wake-speed').value);
  config.bed_speed = parseInt(document.getElementById('bed-speed').value);

  // Alt timing — selected "Days" = primary days, unselected = alt days
  const ALL_DAYS = [0, 1, 2, 3, 4, 5, 6];
  const wakePrimaryDays = getSelectedDays('wake-days');
  if (wakePrimaryDays.length === 7) {
    config.wake_alt_days = [];
    config._wake_alt_time_last = parseFloat(document.getElementById('wake-alt-time').value) % 24;
    config.wake_alt_time = null;
  } else if (wakePrimaryDays.length === 0) {
    config.wake_alt_days = ALL_DAYS.slice();
    config.wake_alt_time = parseFloat(document.getElementById('wake-alt-time').value) % 24;
    config._wake_alt_time_last = config.wake_alt_time;
  } else {
    config.wake_alt_days = ALL_DAYS.filter(d => !wakePrimaryDays.includes(d));
    config.wake_alt_time = parseFloat(document.getElementById('wake-alt-time').value) % 24;
    config._wake_alt_time_last = config.wake_alt_time;
  }
  const bedPrimaryDays = getSelectedDays('bed-days');
  if (bedPrimaryDays.length === 7) {
    config.bed_alt_days = [];
    config._bed_alt_time_last = parseFloat(document.getElementById('bed-alt-time').value) % 24;
    config.bed_alt_time = null;
  } else if (bedPrimaryDays.length === 0) {
    config.bed_alt_days = ALL_DAYS.slice();
    config.bed_alt_time = parseFloat(document.getElementById('bed-alt-time').value) % 24;
    config._bed_alt_time_last = config.bed_alt_time;
  } else {
    config.bed_alt_days = ALL_DAYS.filter(d => !bedPrimaryDays.includes(d));
    config.bed_alt_time = parseFloat(document.getElementById('bed-alt-time').value) % 24;
    config._bed_alt_time_last = config.bed_alt_time;
  }
  config.wake_brightness = parseInt(document.getElementById('wake-brightness').value);
  config.bed_brightness = parseInt(document.getElementById('bed-brightness').value);

  config.min_color_temp = parseInt(document.getElementById('color-min').value);
  config.max_color_temp = parseInt(document.getElementById('color-max').value);
  config.min_brightness = parseInt(document.getElementById('brightness-min').value);
  config.max_brightness = parseInt(document.getElementById('brightness-max').value);
  // Constrain solar target sliders to color range (clamps values if needed)
  updateSolarTargetSliderConstraints();

  config.warm_night_enabled = document.getElementById('warm-night-enabled').checked;
  config.warm_night_mode = document.getElementById('warm-night-mode').value;
  config.warm_night_target = parseInt(document.getElementById('warm-night-target').value);
  config.warm_night_start = parseInt(document.getElementById('warm-night-start')?.value || -60);
  config.warm_night_end = parseInt(document.getElementById('warm-night-end')?.value || 60);
  config.warm_night_fade = parseInt(document.getElementById('warm-night-fade')?.value || 60);

  config.daylight_enabled = document.getElementById('daylight-enabled').checked;
  config.daylight_cct = parseInt(document.getElementById('daylight-cct').value);
  config.daylight_start = parseInt(document.getElementById('daylight-start')?.value || 60);
  config.daylight_end = parseInt(document.getElementById('daylight-end')?.value || -60);
  config.daylight_fade = parseInt(document.getElementById('daylight-fade')?.value || '60');
  config.color_sensitivity = SENSITIVITY_STEPS[parseInt(document.getElementById('color-sensitivity').value)].multiplier;

  updateColorGradients();
  constrainWakeBedSliders();
  updateSleepSummary();
}

function syncUIFromConfig() {
  document.getElementById('ascend-start').value = config.ascend_start;
  document.getElementById('descend-start').value = config.descend_start;

  // Update wake/bed slider constraints BEFORE setting values
  // (prevents clamping by old constraints when switching presets)
  updateWakeBedSliderConstraints();

  // Handle wake_time slider - if it's before ascend_start, add 24 for slider
  let wakeSliderVal = config.wake_time;
  if (config.wake_time < config.ascend_start) {
    wakeSliderVal = config.wake_time + 24;
  }
  document.getElementById('wake-time').value = wakeSliderVal;

  // Handle bed_time slider - if it's before descend_start, add 24 for slider
  let bedSliderVal = config.bed_time;
  if (config.bed_time < config.descend_start) {
    bedSliderVal = config.bed_time + 24;
  }
  document.getElementById('bed-time').value = bedSliderVal;

  document.getElementById('wake-speed').value = config.wake_speed;
  document.getElementById('bed-speed').value = config.bed_speed;

  // Alt timing — show primary days (complement of alt_days) as selected
  const ALL_DAYS_UI = [0, 1, 2, 3, 4, 5, 6];
  const wakeAltDays = config.wake_alt_days || [];
  const wakePrimary = wakeAltDays.length > 0
    ? ALL_DAYS_UI.filter(d => !wakeAltDays.includes(d))
    : [];  // none selected = all primary (no alt)
  setSelectedDays('wake-days', wakePrimary);
  if (wakeAltDays.length > 0 && config.wake_alt_time != null) {
    let wakeAltSlider = config.wake_alt_time;
    if (config.wake_alt_time < config.ascend_start) wakeAltSlider += 24;
    document.getElementById('wake-alt-time').value = wakeAltSlider;
    document.getElementById('wake-time-blocks').classList.remove('no-alt');
  } else {
    // Pre-load slider with last-used alt time so it's ready if days are re-added
    const wakeLastAlt = config._wake_alt_time_last ?? config.wake_time;
    let wakeAltPreload = wakeLastAlt;
    if (wakeLastAlt < config.ascend_start) wakeAltPreload += 24;
    document.getElementById('wake-alt-time').value = wakeAltPreload;
    document.getElementById('wake-time-blocks').classList.add('no-alt');
  }
  const bedAltDays = config.bed_alt_days || [];
  const bedPrimary = bedAltDays.length > 0
    ? ALL_DAYS_UI.filter(d => !bedAltDays.includes(d))
    : [];  // none selected = all primary (no alt)
  setSelectedDays('bed-days', bedPrimary);
  if (bedAltDays.length > 0 && config.bed_alt_time != null) {
    let bedAltSlider = config.bed_alt_time;
    if (config.bed_alt_time < config.descend_start) bedAltSlider += 24;
    document.getElementById('bed-alt-time').value = bedAltSlider;
    document.getElementById('bed-time-blocks').classList.remove('no-alt');
  } else {
    // Pre-load slider with last-used alt time so it's ready if days are re-added
    const bedLastAlt = config._bed_alt_time_last ?? config.bed_time;
    let bedAltPreload = bedLastAlt;
    if (bedLastAlt < config.descend_start) bedAltPreload += 24;
    document.getElementById('bed-alt-time').value = bedAltPreload;
    document.getElementById('bed-time-blocks').classList.add('no-alt');
  }
  document.getElementById('wake-brightness').value = config.wake_brightness || 50;
  document.getElementById('bed-brightness').value = config.bed_brightness || 50;

  document.getElementById('color-min').value = config.min_color_temp;
  document.getElementById('color-max').value = config.max_color_temp;
  document.getElementById('brightness-min').value = config.min_brightness;
  document.getElementById('brightness-max').value = config.max_brightness;
  // Set warm night slider values FROM CONFIG BEFORE calling updateSolarTargetSliderConstraints
  document.getElementById('warm-night-enabled').checked = config.warm_night_enabled;
  document.getElementById('warm-night-mode').value = config.warm_night_mode;
  document.getElementById('warm-night-target').value = config.warm_night_target;
  const warmStart = document.getElementById('warm-night-start');
  const warmEnd = document.getElementById('warm-night-end');
  const warmFade = document.getElementById('warm-night-fade');
  if (warmStart) warmStart.value = config.warm_night_start;
  if (warmEnd) warmEnd.value = config.warm_night_end;
  if (warmFade) warmFade.value = config.warm_night_fade;

  document.getElementById('daylight-enabled').checked = config.daylight_enabled !== false;
  document.getElementById('daylight-cct').value = config.daylight_cct;
  const daylightStart = document.getElementById('daylight-start');
  const daylightEnd = document.getElementById('daylight-end');
  const daylightFade = document.getElementById('daylight-fade');
  if (daylightStart) daylightStart.value = config.daylight_start ?? 60;
  if (daylightEnd) daylightEnd.value = config.daylight_end ?? -60;
  if (daylightFade) daylightFade.value = config.daylight_fade;
  document.getElementById('color-sensitivity').value = findClosestSensitivityStep(config.color_sensitivity);

  // Now update constraints (reads slider values, clamps to color range)
  updateSolarTargetSliderConstraints();

  document.getElementById('activity-preset').value = config.activity_preset || 'adult';

  updateDisplay('ascend-start-display', formatHour(config.ascend_start));
  updateDisplay('descend-start-display', formatHour(config.descend_start));
  updateDisplay('ascend-start-badge', formatHour(config.ascend_start));
  updateDisplay('descend-start-badge', formatHour(config.descend_start));
  positionTimelineBadges();
  updateDisplay('wake-time-display', formatHour(config.wake_time));
  updateDisplay('bed-time-display', formatHour(config.bed_time));
  updateDisplay('wake-alt-time-display', formatHour(config.wake_alt_time ?? config._wake_alt_time_last ?? config.wake_time));
  updateDisplay('bed-alt-time-display', formatHour(config.bed_alt_time ?? config._bed_alt_time_last ?? config.bed_time));
  const wb = config.wake_brightness || 50;
  updateDisplay('wake-brightness-display', wb + '%');
  const bb = config.bed_brightness || 50;
  updateDisplay('bed-brightness-display', bb + '%');
  updateDisplay('wake-speed-display', `${config.wake_speed}: ${SPEED_LABELS[config.wake_speed].toLowerCase()}`);
  updateDisplay('bed-speed-display', `${config.bed_speed}: ${SPEED_LABELS[config.bed_speed].toLowerCase()}`);
  updateRangeDisplays();


  updateDualFills();
  updateColorGradients();
  updateOffsetDisplays();
  syncColorRuleRows();
  constrainWakeBedSliders();
  updateSleepSummary();
  updateSolarImpacts();
  updateScheduleToggles();
  initChartScheduleDefaults();

  // Capture loaded values for reset links (so "reset" restores to loaded state)
  document.querySelectorAll('.tune-control-reset').forEach(resetEl => {
    const sliderId = resetEl.id.replace('reset-', '');
    const input = document.getElementById(sliderId);
    if (input) {
      resetEl.dataset.loaded = input.value;
      resetEl.classList.remove('is-dirty');
    }
  });
}

// Set chart wake/bed secondary checkboxes based on current/next effective schedule
function initChartScheduleDefaults() {
  const ALL = [0, 1, 2, 3, 4, 5, 6];
  const phase = getSleepPhase();
  const jsToday = new Date().getDay();
  const pyToday = jsToday === 0 ? 6 : jsToday - 1;
  const nowDecimal = new Date().getHours() + new Date().getMinutes() / 60;

  ['wake', 'bed'].forEach(prefix => {
    const primaryDays = getSelectedDays(`${prefix}-days`);
    const altDays = primaryDays.length === 0
      ? []
      : (primaryDays.length < 7 ? ALL.filter(d => !primaryDays.includes(d)) : []);
    if (altDays.length === 0) return;

    const altSlider = document.getElementById(`${prefix}-alt-time`);
    if (!altSlider) return;

    const p = phase[prefix];
    let useAlt = false;
    if (p === 'current') {
      useAlt = altDays.includes(pyToday);
    } else {
      let startOffset = 1;
      if (prefix === 'bed' && nowDecimal < (config.descend_start || 20)) startOffset = 0;
      if (prefix === 'wake' && nowDecimal < (config.ascend_start || 6)) startOffset = 0;
      const checkDay = (pyToday + startOffset) % 7;
      useAlt = altDays.includes(checkDay);
    }

    const checkboxId = prefix === 'wake' ? 'chart-wake-secondary' : 'chart-bed-secondary';
    if (useAlt) {
      if (prefix === 'wake') chartWakeMode = 'alt'; else chartBedMode = 'alt';
      const cb = document.getElementById(checkboxId);
      if (cb) cb.checked = true;
    } else {
      if (prefix === 'wake') chartWakeMode = 'primary'; else chartBedMode = 'primary';
      const cb = document.getElementById(checkboxId);
      if (cb) cb.checked = false;
    }
  });
}

// Update combined range displays (color temp + brightness)
function updateRangeDisplays() {
  const ctRange = `${config.min_color_temp} – ${config.max_color_temp} K`;
  const briRange = `${config.min_brightness} – ${config.max_brightness}%`;
  updateDisplay('color-range-display', ctRange);
  updateDisplay('brightness-range-display', briRange);
  // Update card header summaries with bold range values
  const briEl = document.getElementById('rhythm-brightness-val');
  if (briEl) briEl.innerHTML = `<b>${config.min_brightness} – ${config.max_brightness}%</b>`;
  // Color temp header: rule labels · bold range
  const ctEl = document.getElementById('rhythm-color-val');
  if (ctEl) {
    const rules = [];
    if (config.warm_night_enabled) rules.push('warm');
    if (config.daylight_enabled !== false) rules.push('cool');
    const labels = rules.length ? rules.join(' \u00b7 ') + ' \u00b7 ' : '';
    ctEl.innerHTML = labels + `<b>${config.min_color_temp} – ${config.max_color_temp} K</b>`;
  }
}

// Update offset text displays
function updateOffsetDisplays() {
  const fmtHrs = (min) => {
    const hrs = Math.abs(min) / 60;
    return hrs === 1 ? '1 hr' : `${hrs} hrs`;
  };
  const formatOffset = (val, baseEvent) => {
    if (val === 0) return `at ${baseEvent}`;
    const direction = val < 0 ? 'before' : 'after';
    return `${fmtHrs(val)} ${direction} ${baseEvent}`;
  };

  updateDisplay('warm-night-start-text', formatOffset(config.warm_night_start, 'sunset'));
  updateDisplay('warm-night-end-text', formatOffset(config.warm_night_end, 'sunrise'));
  updateDisplay('warm-night-fade-text', fmtHrs(config.warm_night_fade));
  updateDisplay('daylight-start-text', formatOffset(config.daylight_start ?? 60, 'sunrise'));
  updateDisplay('daylight-end-text', formatOffset(config.daylight_end ?? -60, 'sunset'));
  updateDisplay('daylight-fade-text', fmtHrs(config.daylight_fade));
  const sensStep = SENSITIVITY_STEPS[findClosestSensitivityStep(config.color_sensitivity)];
  updateDisplay('color-sensitivity-text', `${sensStep.multiplier.toFixed(2)}: ${sensStep.label.toLowerCase()}`);
}

function updateSolarImpacts() {
  if (!sunTimes) return;
  const { sunrise, sunset, solarNoon } = sunTimes;
  const fmt12 = (h) => {
    const h24 = ((h % 24) + 24) % 24;
    let hr = Math.floor(h24);
    let min = Math.round((h24 - hr) * 60);
    if (min === 60) { hr++; min = 0; }
    const ampm = hr >= 12 ? 'PM' : 'AM';
    const hr12 = hr === 0 ? 12 : (hr > 12 ? hr - 12 : hr);
    return `${hr12}:${String(min).padStart(2, '0')} ${ampm}`;
  };

  // Warm night start/end impacts — actual clock times
  const wnStart = sunset + (config.warm_night_start / 60);
  updateDisplay('warm-night-start-impact', fmt12(wnStart));
  const wnEnd = sunrise + (config.warm_night_end / 60);
  updateDisplay('warm-night-end-impact', fmt12(wnEnd));

  // Cool day start/end impacts
  const dlStart = sunrise + ((config.daylight_start ?? 60) / 60);
  updateDisplay('daylight-start-impact', fmt12(dlStart));
  const dlEnd = sunset + ((config.daylight_end ?? -60) / 60);
  updateDisplay('daylight-end-impact', fmt12(dlEnd));

}

// Sync color rule rows - toggle is-disabled based on checkbox + mode state
function syncColorRuleRows() {
  const warmEnabled = config.warm_night_enabled;

  // Warm night body
  const warmBody = document.getElementById('warm-night-body');
  if (warmBody) {
    warmBody.classList.toggle('is-disabled', !warmEnabled);
    warmBody.querySelectorAll('select, input[type="range"]').forEach(el => {
      el.disabled = !warmEnabled;
    });
  }

  // Cool day body
  const daylightEnabled = config.daylight_enabled !== false;
  const daylightBody = document.getElementById('daylight-body');
  if (daylightBody) {
    daylightBody.classList.toggle('is-disabled', !daylightEnabled);
    daylightBody.querySelectorAll('input[type="range"]').forEach(el => {
      el.disabled = !daylightEnabled;
    });
  }

  // Grey out weather selector when cool day is off
  const weatherEl = document.getElementById('modeled-conditions');
  if (weatherEl) {
    weatherEl.disabled = !daylightEnabled;
    weatherEl.style.opacity = daylightEnabled ? '' : '0.4';
  }

  // Update card header with warm/cool labels
  updateRangeDisplays();
}

// Update wake/bed slider min/max constraints only (no value clamping)
// Called before setting slider values to prevent clamping by old constraints
function updateWakeBedSliderConstraints() {
  const wakeSlider = document.getElementById('wake-time');
  const bedSlider = document.getElementById('bed-time');
  if (!wakeSlider || !bedSlider) return;

  const ascendStart = config.ascend_start;
  let descendStart = config.descend_start;
  if (descendStart <= ascendStart) descendStart += 24;

  // Wake sliders: ascend_start to descend_start
  const wakeMin = ascendStart;
  const wakeMax = descendStart;
  wakeSlider.min = wakeMin;
  wakeSlider.max = wakeMax;

  // Bed sliders: descend_start to (descend_start + descend phase length)
  const bedMin = config.descend_start;
  const bedMax = config.descend_start + 24 - (descendStart - ascendStart);
  bedSlider.min = bedMin;
  bedSlider.max = bedMax;

  // Alt sliders get the same bounds
  const wakeAltSlider = document.getElementById('wake-alt-time');
  const bedAltSlider = document.getElementById('bed-alt-time');
  if (wakeAltSlider) { wakeAltSlider.min = wakeMin; wakeAltSlider.max = wakeMax; }
  if (bedAltSlider) { bedAltSlider.min = bedMin; bedAltSlider.max = bedMax; }
}

// Constrain warm_night_target slider to color range
function updateSolarTargetSliderConstraints() {
  const warmSlider = document.getElementById('warm-night-target');
  if (!warmSlider) return;

  const minTemp = config.min_color_temp;
  const maxTemp = config.max_color_temp;

  warmSlider.min = minTemp;
  warmSlider.max = maxTemp;

  let warmVal = Math.max(minTemp, Math.min(maxTemp, parseInt(warmSlider.value)));
  warmSlider.value = warmVal;
  config.warm_night_target = warmVal;

  // Update track gradients to match new bounds
  updateColorGradients();
}

// Constrain wake slider to between ascend_start and descend_start
// Constrain bed slider to between descend_start and ascend_start (wrapping)
function constrainWakeBedSliders() {
  const wakeSlider = document.getElementById('wake-time');
  const bedSlider = document.getElementById('bed-time');
  if (!wakeSlider || !bedSlider) return;

  // Update constraints first
  updateWakeBedSliderConstraints();

  // Wake must be between ascend_start and descend_start
  const ascendStart = config.ascend_start;
  let descendStart = config.descend_start;
  if (descendStart <= ascendStart) descendStart += 24;

  // Clamp current value
  let wakeVal = parseFloat(wakeSlider.value);
  if (wakeVal < ascendStart) wakeVal = ascendStart;
  if (wakeVal > descendStart) wakeVal = descendStart;
  wakeSlider.value = wakeVal;
  config.wake_time = wakeVal % 24;
  updateDisplay('wake-time-display', formatHour(config.wake_time));

  // Bed: clamp to new constraints
  let bedVal = parseFloat(bedSlider.value);
  const bedMin = parseFloat(bedSlider.min);
  const bedMax = parseFloat(bedSlider.max);
  if (bedVal < bedMin) bedVal = bedMin;
  if (bedVal > bedMax) bedVal = bedMax;
  bedSlider.value = bedVal;
  config.bed_time = bedVal % 24;
  updateDisplay('bed-time-display', formatHour(config.bed_time));
}

function updateDualFills() {
  const colorMin = parseInt(document.getElementById('color-min').value);
  const colorMax = parseInt(document.getElementById('color-max').value);
  const colorFill = document.getElementById('color-fill');
  if (colorFill) {
    const left = ((colorMin - 500) / 6000) * 100;
    const right = ((colorMax - 500) / 6000) * 100;
    colorFill.style.left = `${left}%`;
    colorFill.style.width = `${right - left}%`;
  }

  const briMin = parseInt(document.getElementById('brightness-min').value);
  const briMax = parseInt(document.getElementById('brightness-max').value);
  const briMaskLeft = document.getElementById('brightness-mask-left');
  const briMaskRight = document.getElementById('brightness-mask-right');
  if (briMaskLeft && briMaskRight) {
    const leftPct = ((briMin - 1) / 99) * 100;
    const rightPct = ((briMax - 1) / 99) * 100;
    briMaskLeft.style.left = '0%';
    briMaskLeft.style.width = `${leftPct}%`;
    briMaskRight.style.left = `${rightPct}%`;
    briMaskRight.style.width = `${100 - rightPct}%`;
  }
}

// ============================================================
// Event Handlers
// ============================================================

function setupEventListeners() {
  updateSliderValue('ascend-start', 'ascend-start-display', formatHour);
  updateSliderValue('descend-start', 'descend-start-display', formatHour);
  updateSliderValue('wake-time', 'wake-time-display', formatHour);
  updateSliderValue('bed-time', 'bed-time-display', formatHour);
  updateSliderValue('wake-speed', 'wake-speed-display', v => `${v}: ${SPEED_LABELS[v].toLowerCase()}`);
  updateSliderValue('bed-speed', 'bed-speed-display', v => `${v}: ${SPEED_LABELS[v].toLowerCase()}`);

  // Alt time sliders
  updateSliderValue('wake-alt-time', 'wake-alt-time-display', formatHour);
  updateSliderValue('bed-alt-time', 'bed-alt-time-display', formatHour);

  // Brightness target sliders
  updateSliderValue('wake-brightness', 'wake-brightness-display', v => v + '%');
  updateSliderValue('bed-brightness', 'bed-brightness-display', v => v + '%');

  // Reset links — click to reset slider to loaded value
  document.querySelectorAll('.tune-control-reset').forEach(resetEl => {
    resetEl.addEventListener('click', (e) => {
      e.stopPropagation();
      const sliderId = resetEl.id.replace('reset-', '');
      const input = document.getElementById(sliderId);
      if (input && resetEl.dataset.loaded != null) {
        input.value = resetEl.dataset.loaded;
        input.dispatchEvent(new Event('input', { bubbles: true }));
      }
    });
  });

  // Dirty-state tracking for reset links
  document.querySelectorAll('.tune-control-reset').forEach(resetEl => {
    const sliderId = resetEl.id.replace('reset-', '');
    const input = document.getElementById(sliderId);
    if (input) {
      input.addEventListener('input', () => {
        if (resetEl.dataset.loaded != null) {
          resetEl.classList.toggle('is-dirty', input.value !== resetEl.dataset.loaded);
        }
      });
    }
  });

  // Sleep day indicators
  initSleepDayIndicators();

  // Restore rhythm card expand states
  ['rhythm-sleep-card', 'rhythm-color-card', 'rhythm-brightness-card'].forEach(id => {
    const key = id.replace('rhythm-', 'rhythm_').replace('-card', '_expanded');
    if (localStorage.getItem(key) === 'true') {
      document.getElementById(id)?.classList.add('is-open');
    }
  });

  // Dual-range sliders update combined display
  ['color-min', 'color-max'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('input', () => { syncConfigFromUI(); updateRangeDisplays(); renderChart(); });
  });
  ['brightness-min', 'brightness-max'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('input', () => { syncConfigFromUI(); updateRangeDisplays(); renderChart(); });
  });
  // Warm night target slider (inside popup)
  document.getElementById('warm-night-target')?.addEventListener('input', () => {
    config.warm_night_target = parseInt(document.getElementById('warm-night-target').value);
    updateSolarTargetSliderConstraints();
    renderChart();
  });
  document.getElementById('daylight-cct')?.addEventListener('input', () => {
    config.daylight_cct = parseInt(document.getElementById('daylight-cct').value);
    updateColorGradients();
    renderChart();
  });

  // Cool day sliders (sensitivity, start, end, fade)
  ['color-sensitivity', 'daylight-start', 'daylight-end', 'daylight-fade'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('input', () => {
        syncConfigFromUI();
        updateOffsetDisplays();
        renderChart();
      });
    }
  });

  // Cool day enable checkbox
  document.getElementById('daylight-enabled')?.addEventListener('change', () => {
    config.daylight_enabled = document.getElementById('daylight-enabled').checked;
    syncColorRuleRows();
    renderChart();
  });

  // Warm night offset sliders
  ['warm-night-start', 'warm-night-end', 'warm-night-fade'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('input', () => {
        syncConfigFromUI();
        updateOffsetDisplays();
        renderChart();
      });
    }
  });

  document.getElementById('warm-night-enabled')?.addEventListener('change', () => {
    config.warm_night_enabled = document.getElementById('warm-night-enabled').checked;
    syncColorRuleRows();
    renderChart();
  });

  // Color chip buttons - toggle popups
  document.getElementById('warm-night-target-chip')?.addEventListener('click', (e) => {
    e.stopPropagation();
    const popup = document.getElementById('warm-night-popup');
    const other = document.getElementById('daylight-cct-popup');
    if (other) other.classList.remove('is-open');
    popup?.classList.toggle('is-open');
  });
  document.getElementById('daylight-cct-chip')?.addEventListener('click', (e) => {
    e.stopPropagation();
    const popup = document.getElementById('daylight-cct-popup');
    const other = document.getElementById('warm-night-popup');
    if (other) other.classList.remove('is-open');
    popup?.classList.toggle('is-open');
  });

  // Close popups when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.color-controls-wrap')) {
      document.querySelectorAll('.color-slider-popup').forEach(p => p.classList.remove('is-open'));
    }
    // Close info tooltips when clicking outside
    if (!e.target.closest('.info-icon') && !e.target.closest('.info-tooltip')) {
      document.querySelectorAll('.info-tooltip').forEach(t => t.classList.remove('is-open'));
    }
  });

  // Info icon click handlers - toggle tooltip visibility
  document.querySelectorAll('.info-icon').forEach(icon => {
    icon.addEventListener('click', (e) => {
      e.stopPropagation();
      const tooltipId = icon.getAttribute('data-tooltip');
      const tooltip = document.getElementById(tooltipId);
      // Close other tooltips
      document.querySelectorAll('.info-tooltip').forEach(t => {
        if (t.id !== tooltipId) t.classList.remove('is-open');
      });
      tooltip?.classList.toggle('is-open');
    });
  });

  document.getElementById('activity-preset').addEventListener('change', (e) => {
    const preset = ACTIVITY_PRESETS[e.target.value];
    if (preset) {
      config.activity_preset = e.target.value;
      config.wake_time = preset.wake_time;
      config.bed_time = preset.bed_time;
      config.warm_night_enabled = preset.warm_night_enabled;
      config.daylight_cct = preset.daylight_cct;

      // Get current sun times for solar-based presets
      const { solarNoon, solarMid } = getSunTimes(config.latitude, config.longitude, getSelectedDateISO());
      const solarNoonRounded = Math.round(solarNoon);
      const solarMidRounded = Math.round(solarMid);

      // Young Child: ascend=solar midnight, descend=solar noon
      // Adult: descend=solar noon (ascend stays fixed)
      if (e.target.value === 'young') {
        config.ascend_start = solarMidRounded % 24;
        config.descend_start = solarNoonRounded % 24;
      } else if (e.target.value === 'adult') {
        config.ascend_start = preset.ascend_start;
        config.descend_start = solarNoonRounded % 24;
      } else {
        config.ascend_start = preset.ascend_start;
        config.descend_start = preset.descend_start;
      }

      syncUIFromConfig();
      renderChart();
    }
  });

  document.getElementById('chart-date-slider').addEventListener('input', () => {
    renderChart();
  });

  document.getElementById('modeled-conditions').addEventListener('change', () => {
    renderChart();
  });

  // Chart schedule toggles (wake/bed primary vs alt)
  document.getElementById('chart-wake-secondary')?.addEventListener('change', (e) => {
    chartWakeMode = e.target.checked ? 'alt' : 'primary';
    renderChart();
    applyCursor();
  });
  document.getElementById('chart-bed-secondary')?.addEventListener('change', (e) => {
    chartBedMode = e.target.checked ? 'alt' : 'primary';
    renderChart();
    applyCursor();
  });

  // Time navigation buttons — always active
  document.getElementById('cursor-time-now')?.addEventListener('click', () => {
    const now = new Date();
    cursorHour = now.getHours() + now.getMinutes() / 60;
    renderChart();
    applyCursor();
  });
  document.getElementById('cursor-time-plus')?.addEventListener('click', () => {
    cursorHour = (cursorHour + 5/60) % 24;  // +5 minutes, wrap at 24
    renderChart();
    applyCursor();
  });
  document.getElementById('cursor-time-minus')?.addEventListener('click', () => {
    cursorHour = (cursorHour - 5/60 + 24) % 24;
    renderChart();
    applyCursor();
  });
  document.getElementById('cursor-time-plus-30')?.addEventListener('click', () => {
    cursorHour = (cursorHour + 30/60) % 24;
    renderChart();
    applyCursor();
  });
  document.getElementById('cursor-time-minus-30')?.addEventListener('click', () => {
    cursorHour = (cursorHour - 30/60 + 24) % 24;
    renderChart();
    applyCursor();
  });

  ['color-min', 'color-max', 'brightness-min', 'brightness-max'].forEach(id => {
    document.getElementById(id)?.addEventListener('input', updateDualFills);
  });

}


// ============================================================
// API Communication
// ============================================================

async function loadConfig() {
  try {
    const resp = await fetch('./api/config');
    if (resp.ok) {
      const data = await resp.json();
      Object.assign(config, data);
      syncUIFromConfig();
      renderChart();
    }
  } catch (err) {
    console.error('Error loading config:', err);
  }
}

async function saveConfig() {
  // Delegate to saveZoneSettings for zone-based saving
  return saveZoneSettings();
}

// ============================================================
// Live Design Functions
// ============================================================

/**
 * Load areas from Home Assistant and populate the dropdown.
 */
async function loadLiveDesignAreas() {
  const select = document.getElementById('live-area-select');
  if (!select) return;

  console.log('[Live Design] Loading areas...');

  try {
    const response = await fetch('./api/areas');
    console.log('[Live Design] API response status:', response.status);

    if (!response.ok) {
      const text = await response.text();
      console.warn('[Live Design] Failed to load areas:', response.status, text);
      return;
    }
    const areas = await response.json();
    console.log('[Live Design] Received areas:', areas);

    if (!Array.isArray(areas) || areas.length === 0) {
      console.warn('[Live Design] No areas returned or invalid response');
      return;
    }

    // Clear existing options except the placeholder
    while (select.options.length > 1) {
      select.remove(1);
    }

    // Add area options
    areas.forEach(area => {
      const option = document.createElement('option');
      option.value = area.area_id;
      option.textContent = area.name;
      select.appendChild(option);
    });
    console.log('[Live Design] Added', areas.length, 'areas to dropdown');
  } catch (err) {
    console.error('[Live Design] Error loading areas:', err);
  }
}

/**
 * Get the brightness and color temperature at the current cursor position.
 * @returns {Object|null} {brightness, colorTemp} or null if cursor not set
 */
function getCursorLightValues() {
  if (cursorHour === null || !config) return null;

  // Use core calculation functions for exact values (consistent with brain.py)
  return {
    brightness: calculateBrightnessAtHour(cursorHour) * 100,  // Convert 0-1 to 0-100
    colorTemp: calculateColorAtHour(cursorHour, true)         // With solar rules
  };
}

/**
 * Apply the current cursor lighting values to the selected area.
 */
async function applyLiveLight() {
  console.log('[Live Design] applyLiveLight called, enabled=', liveDesignEnabled, 'areaId=', liveDesignAreaId);
  if (!liveDesignEnabled || !liveDesignAreaId) {
    console.log('[Live Design] Skipping - not enabled or no area selected');
    return;
  }

  const values = getCursorLightValues();
  console.log('[Live Design] Cursor values:', values);
  if (!values) {
    console.log('[Live Design] No cursor values available');
    return;
  }

  const statusEl = document.getElementById('live-design-status');

  // Use 2-second transition on first apply after entering, then default 0.3s
  const transition = liveDesignFirstApply ? 2 : 0.3;
  if (liveDesignFirstApply) {
    liveDesignFirstApply = false;
    console.log('[Live Design] First apply - using 2s transition');
  }

  console.log('[Live Design] Sending to API:', {
    area_id: liveDesignAreaId,
    brightness: Math.round(values.brightness),
    color_temp: Math.round(values.colorTemp),
    transition
  });

  try {
    const response = await fetch('./api/apply-light', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        area_id: liveDesignAreaId,
        brightness: Math.round(values.brightness),
        color_temp: Math.round(values.colorTemp),
        transition
      })
    });

    if (response.ok) {
      if (statusEl) {
        statusEl.textContent = 'Live!';
        statusEl.classList.add('active', 'live-blink');
      }
    } else {
      console.warn('Failed to apply light:', response.status);
      if (statusEl) {
        statusEl.textContent = 'Error';
        statusEl.classList.remove('active', 'live-blink');
      }
    }
  } catch (err) {
    console.error('Error applying live light:', err);
    if (statusEl) {
      statusEl.textContent = 'Error';
      statusEl.classList.remove('active', 'live-blink');
    }
  }
}

/**
 * Enable or disable Circadian mode for an area via API.
 */
async function setCircadianMode(areaId, enabled) {
  if (!areaId) return;

  try {
    const response = await fetch('./api/circadian-mode', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ area_id: areaId, enabled })
    });

    if (response.ok) {
      console.log(`[Live Design] Circadian mode ${enabled ? 'enabled' : 'disabled'} for ${areaId}`);
    } else {
      console.warn('[Live Design] Failed to set circadian mode:', response.status);
    }
  } catch (err) {
    console.error('[Live Design] Error setting circadian mode:', err);
  }
}

/**
 * Set up Live Design event listeners.
 * - Selecting an area auto-enables Live Design
 * - Pause button pauses/resumes (restoring lights on pause)
 */
function setupLiveDesign() {
  const toggleBtn = document.getElementById('live-design-toggle');
  const areaSelect = document.getElementById('live-area-select');
  const statusEl = document.getElementById('live-design-status');

  if (toggleBtn) {
    toggleBtn.addEventListener('click', async (e) => {
      e.preventDefault();
      if (!liveDesignAreaId) return;

      liveDesignEnabled = !liveDesignEnabled;
      toggleBtn.textContent = liveDesignEnabled ? 'Pause' : 'Resume';
      updateDesignModeUI();

      // Disable/enable Circadian mode for the area
      if (liveDesignEnabled) {
        // Disable Circadian so periodic updates don't override Live Design
        await setCircadianMode(liveDesignAreaId, false);
        if (statusEl) {
          statusEl.textContent = 'starting Live Design';
          statusEl.classList.remove('live-blink');
          statusEl.classList.add('active');
        }
        // Apply current cursor position with 3s transition
        liveDesignFirstApply = true;
        if (cursorHour !== null) {
          applyLiveLight();
        }
        // Update status after transition
        setTimeout(() => {
          if (liveDesignEnabled && statusEl) {
            statusEl.textContent = 'Live!';
            statusEl.classList.add('live-blink');
          }
        }, 2500);
      } else {
        // Re-enable Circadian when pausing (this restores lights via backend)
        if (statusEl) {
          statusEl.textContent = 'Paused';
          statusEl.classList.remove('active', 'live-blink');
        }
        await setCircadianMode(liveDesignAreaId, true);
        // Snap cursor back to now — exiting design mode
        snapCursorToNow();
      }
    });
  }

  if (areaSelect) {
    areaSelect.addEventListener('change', async (e) => {
      const oldAreaId = liveDesignAreaId;
      const newAreaId = e.target.value || null;

      // If we had an active Live Design, end it for the old area
      if (liveDesignEnabled && oldAreaId) {
        if (statusEl) {
          statusEl.textContent = 'Exiting...';
        }
        await setCircadianMode(oldAreaId, true);
      }

      liveDesignAreaId = newAreaId;

      if (newAreaId) {
        // Auto-enable Live Design when area is selected
        liveDesignEnabled = true;
        toggleBtn.style.display = '';
        toggleBtn.textContent = 'Pause';
        updateDesignModeUI();
        if (statusEl) {
          statusEl.textContent = 'starting Live Design';
          statusEl.classList.remove('live-blink');
          statusEl.classList.add('active');
        }
        await setCircadianMode(newAreaId, false);
        // Apply current cursor position if set with 3s transition
        liveDesignFirstApply = true;
        if (cursorHour !== null) {
          applyLiveLight();
        }
        // Update status after transition
        setTimeout(() => {
          if (liveDesignEnabled && statusEl) {
            statusEl.textContent = 'Live!';
            statusEl.classList.add('live-blink');
          }
        }, 2500);
      } else {
        // No area selected - hide button and reset state
        liveDesignEnabled = false;
        toggleBtn.style.display = 'none';
        if (statusEl) {
          statusEl.textContent = '';
          statusEl.classList.remove('active', 'live-blink');
        }
        updateDesignModeUI();
        // Snap cursor back to now — exiting design mode
        snapCursorToNow();
      }
    });
  }

  // Load areas from HA
  loadLiveDesignAreas();
}

// ============================================================
// Initialize
// ============================================================
// Rhythm Zone Management
// ============================================================

let glozonesData = {};
let selectedZone = null;
let allAreas = [];
let modalMode = null; // 'create-zone', 'edit-zone'
let modalTarget = null;

/**
 * Fetch GloZones from API
 */
async function fetchGlozones() {
  try {
    const response = await fetch('./api/glozones');
    if (response.ok) {
      const data = await response.json();
      glozonesData = data.zones || {};
      renderZonesList();
    }
  } catch (err) {
    console.error('Error fetching glozones:', err);
  }
}

/**
 * Format decimal hour compactly: 7a, 10p, 12:30a
 */
function fmtCompactHour(decimalHour) {
  if (decimalHour == null) return '?';
  const h24 = ((Math.round(decimalHour * 60) / 60) % 24 + 24) % 24;
  const h = Math.floor(h24);
  const m = Math.round((h24 - h) * 60);
  const h12 = h % 12 || 12;
  const ampm = h < 12 ? 'a' : 'p';
  return m === 0 ? h12 + ampm : h12 + ':' + String(m).padStart(2, '0') + ampm;
}

/**
 * Fetch all areas from API
 */
async function fetchAllAreas() {
  try {
    const response = await fetch('./api/areas');
    if (response.ok) {
      allAreas = await response.json();
      console.log('[GloZone] Loaded', allAreas.length, 'areas');
    }
  } catch (err) {
    console.error('Error fetching areas:', err);
  }
}

/**
 * Render zones list
 */
function renderZonesList() {
  const container = document.getElementById('zones-list');
  if (!container) return;

  const zoneNames = Object.keys(glozonesData);
  if (zoneNames.length === 0) {
    container.innerHTML = '<div class="glozone-empty">No Rhythm Zones configured. Add a Rhythm Zone to get started.</div>';
    return;
  }

  container.innerHTML = zoneNames.map(zoneName => {
    const zone = glozonesData[zoneName];
    const areaCount = (zone.areas || []).length;
    const isDefault = zone.is_default === true;
    const isLastZone = zoneNames.length === 1;
    return `
      <div class="glozone-item ${selectedZone === zoneName ? 'selected' : ''}" data-zone="${zoneName}">
        <div class="glozone-item-info">
          <span class="glozone-item-name">${zoneName}${isDefault ? ' ⭐' : ''}</span>
          <span class="glozone-item-meta">${areaCount} area${areaCount !== 1 ? 's' : ''}</span>
        </div>
        <div class="glozone-item-actions">
          <button class="edit" data-zone="${zoneName}">Edit</button>
          ${!isLastZone ? `<button class="delete" data-zone="${zoneName}">Delete</button>` : ''}
        </div>
      </div>
    `;
  }).join('');

  // Event listeners for zone items
  container.querySelectorAll('.glozone-item').forEach(item => {
    item.addEventListener('click', (e) => {
      if (e.target.tagName === 'BUTTON') return;
      selectZone(item.dataset.zone);
    });
  });

  container.querySelectorAll('.edit').forEach(btn => {
    btn.addEventListener('click', () => selectZone(btn.dataset.zone));
  });

  container.querySelectorAll('.delete').forEach(btn => {
    btn.addEventListener('click', () => deleteZone(btn.dataset.zone));
  });
}

/**
 * Select a zone and show details
 */
function selectZone(zoneName) {
  selectedZone = zoneName;
  renderZonesList();
  showZoneDetail(zoneName);
}

/**
 * Setup drag and drop for area management
 */
function setupDragAndDrop(container, zoneName, dropType) {
  // Drag start
  container.addEventListener('dragstart', (e) => {
    const chip = e.target.closest('.area-chip');
    if (chip) {
      chip.classList.add('dragging');
      e.dataTransfer.setData('text/plain', JSON.stringify({
        areaId: chip.dataset.area,
        sourceZone: chip.dataset.zone || null
      }));
      e.dataTransfer.effectAllowed = 'move';
    }
  });

  // Drag end
  container.addEventListener('dragend', (e) => {
    const chip = e.target.closest('.area-chip');
    if (chip) {
      chip.classList.remove('dragging');
    }
  });

  // Drag over (allow drop)
  container.addEventListener('dragover', (e) => {
    e.preventDefault();
    e.dataTransfer.dropEffect = 'move';
    container.classList.add('drag-over');
  });

  // Drag leave
  container.addEventListener('dragleave', (e) => {
    if (!container.contains(e.relatedTarget)) {
      container.classList.remove('drag-over');
    }
  });

  // Drop
  container.addEventListener('drop', async (e) => {
    e.preventDefault();
    container.classList.remove('drag-over');

    try {
      const data = JSON.parse(e.dataTransfer.getData('text/plain'));
      const { areaId, sourceZone } = data;

      if (dropType === 'zone') {
        // Dropping into the zone's area list - add to zone
        if (sourceZone !== zoneName) {
          console.log('[GloZone] Drag: Adding area', areaId, 'to zone', zoneName);
          await addAreaToZone(zoneName, areaId);
        }
      } else if (dropType === 'available') {
        // Dropping into available areas - remove from zone
        if (sourceZone === zoneName) {
          console.log('[GloZone] Drag: Removing area', areaId, 'from zone', zoneName);
          await removeAreaFromZone(zoneName, areaId);
        }
      }
    } catch (err) {
      console.error('[GloZone] Drop error:', err);
    }
  });
}

/**
 * Show zone detail panel
 */
function showZoneDetail(zoneName) {
  const detail = document.getElementById('zone-detail');
  const title = document.getElementById('zone-detail-title');
  const zoneAreas = document.getElementById('zone-areas');
  const availableAreas = document.getElementById('available-areas');
  const setDefaultBtn = document.getElementById('zone-set-default-btn');

  if (!detail || !zoneName) {
    if (detail) detail.style.display = 'none';
    return;
  }

  const zone = glozonesData[zoneName];
  if (!zone) return;

  detail.style.display = 'block';
  title.textContent = zoneName + (zone.is_default ? ' ⭐' : '');

  // Show/hide "Set as Default" button
  if (setDefaultBtn) {
    setDefaultBtn.style.display = zone.is_default ? 'none' : 'block';
    setDefaultBtn.onclick = () => setZoneAsDefault(zoneName);
  }

  // Render areas in this zone (draggable)
  const zoneAreaIds = (zone.areas || []).map(a => typeof a === 'string' ? a : a.id);
  zoneAreas.innerHTML = zoneAreaIds.length === 0
    ? '<span class="glozone-item-meta">No areas assigned - drag areas here</span>'
    : zoneAreaIds.map(areaId => {
        const areaInfo = (zone.areas || []).find(a => (typeof a === 'string' ? a : a.id) === areaId);
        const areaName = typeof areaInfo === 'object' ? areaInfo.name : areaId;
        return `<span class="area-chip" draggable="true" data-area="${areaId}" data-zone="${zoneName}">${areaName}<span class="remove" data-area="${areaId}">&times;</span></span>`;
      }).join('');
  zoneAreas.classList.add('drop-zone');

  // Render available areas (draggable, not in this zone)
  const availableForZone = allAreas.filter(a => !zoneAreaIds.includes(a.area_id));

  availableAreas.innerHTML = availableForZone.length === 0
    ? '<span class="glozone-item-meta">All areas assigned to this zone</span>'
    : availableForZone.map(area => `<span class="area-chip unassigned" draggable="true" data-area="${area.area_id}">${area.name || area.area_id}</span>`).join('');
  availableAreas.classList.add('drop-zone');

  // Event delegation for remove buttons (using event delegation for reliability)
  zoneAreas.onclick = (e) => {
    const removeBtn = e.target.closest('.remove');
    if (removeBtn) {
      e.preventDefault();
      e.stopPropagation();
      const areaId = removeBtn.dataset.area;
      console.log('[GloZone] Remove button clicked for area:', areaId);
      removeAreaFromZone(zoneName, areaId);
    }
  };

  // Click to add available areas
  availableAreas.onclick = (e) => {
    const chip = e.target.closest('.area-chip.unassigned');
    if (chip) {
      addAreaToZone(zoneName, chip.dataset.area);
    }
  };

  // Drag and drop handlers for zone areas
  setupDragAndDrop(zoneAreas, zoneName, 'zone');
  setupDragAndDrop(availableAreas, zoneName, 'available');

}

/**
 * Add area to zone via API
 */
async function addAreaToZone(zoneName, areaId) {
  const area = allAreas.find(a => a.area_id === areaId);
  try {
    const response = await fetch(`./api/glozones/${encodeURIComponent(zoneName)}/areas`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ area_id: areaId, area_name: area?.name || areaId })
    });
    if (response.ok) {
      await fetchGlozones();
      showZoneDetail(zoneName);
    }
  } catch (err) {
    console.error('Error adding area to zone:', err);
  }
}

/**
 * Remove area from zone via API
 */
async function removeAreaFromZone(zoneName, areaId) {
  console.log('[GloZone] Removing area:', areaId, 'from zone:', zoneName);
  try {
    const response = await fetch(`./api/glozones/${encodeURIComponent(zoneName)}/areas/${encodeURIComponent(areaId)}`, {
      method: 'DELETE'
    });
    if (response.ok) {
      console.log('[GloZone] Area removed successfully');
      await fetchGlozones();
      showZoneDetail(zoneName);
    } else {
      const data = await response.json();
      console.error('[GloZone] Failed to remove area:', data.error);
      alert(data.error || 'Failed to remove area from zone');
    }
  } catch (err) {
    console.error('Error removing area from zone:', err);
  }
}

/**
 * Delete a zone via API
 */
async function deleteZone(zoneName) {
  if (!confirm(`Delete Rhythm Zone "${zoneName}"? Areas will be moved to the default zone.`)) return;

  try {
    const response = await fetch(`./api/glozones/${encodeURIComponent(zoneName)}`, {
      method: 'DELETE'
    });
    if (response.ok) {
      if (selectedZone === zoneName) {
        selectedZone = null;
        document.getElementById('zone-detail').style.display = 'none';
      }
      await fetchGlozones();
    }
  } catch (err) {
    console.error('Error deleting zone:', err);
  }
}

/**
 * Set a zone as the default zone via API
 */
async function setZoneAsDefault(zoneName) {
  try {
    const response = await fetch(`./api/glozones/${encodeURIComponent(zoneName)}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ is_default: true })
    });
    if (response.ok) {
      await fetchGlozones();
      // Re-select the zone to update the detail view
      if (selectedZone === zoneName) {
        showZoneDetail(zoneName);
      }
    }
  } catch (err) {
    console.error('Error setting default zone:', err);
  }
}

/**
 * Show modal for creating or renaming zone/preset
 */
function showModal(mode, target = null) {
  modalMode = mode;
  modalTarget = target;

  const overlay = document.getElementById('glozone-modal');
  const title = document.getElementById('modal-title');
  const nameInput = document.getElementById('modal-name-input');
  const rhythmRow = document.getElementById('modal-rhythm-row');
  const confirmBtn = document.getElementById('modal-confirm');

  nameInput.value = '';

  if (mode === 'create-zone') {
    title.textContent = 'Create Rhythm Zone';
    if (rhythmRow) rhythmRow.style.display = 'none';
    confirmBtn.textContent = 'Create';
  } else if (mode === 'rename-zone') {
    title.textContent = 'Rename Rhythm Zone';
    nameInput.value = target || '';
    if (rhythmRow) rhythmRow.style.display = 'none';
    confirmBtn.textContent = 'Rename';
  }

  overlay.classList.add('visible');
  nameInput.focus();
}

/**
 * Hide modal
 */
function hideModal() {
  document.getElementById('glozone-modal').classList.remove('visible');
  modalMode = null;
  modalTarget = null;
}

/**
 * Handle modal confirm
 */
async function handleModalConfirm() {
  const nameInput = document.getElementById('modal-name-input');
  const name = nameInput.value.trim();

  if (!name) {
    alert('Please enter a name');
    return;
  }

  if (modalMode === 'create-zone') {
    try {
      const body = { name };
      // Copy settings from the current zone if available
      if (selectedZoneName) {
        body.copy_from = selectedZoneName;
      }
      const response = await fetch('./api/glozones', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body)
      });
      if (response.ok) {
        hideModal();
        await fetchGlozones();
        selectZone(name);
      } else {
        const data = await response.json();
        alert(data.error || 'Failed to create Rhythm Zone');
      }
    } catch (err) {
      console.error('Error creating Rhythm Zone:', err);
    }
  } else if (modalMode === 'rename-zone') {
    if (name === modalTarget) {
      hideModal();
      return;
    }
    try {
      const response = await fetch(`./api/glozones/${encodeURIComponent(modalTarget)}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ name })
      });
      if (response.ok) {
        hideModal();
        await fetchGlozones();
        selectZone(name);
      } else {
        const data = await response.json();
        alert(data.error || 'Failed to rename Rhythm Zone');
      }
    } catch (err) {
      console.error('Error renaming Rhythm Zone:', err);
    }
  }
}

/**
 * Setup GloZone UI event listeners
 */
function setupGlozoneUI() {
  // Tab switching
  document.querySelectorAll('.glozone-tab').forEach(tab => {
    tab.addEventListener('click', () => {
      document.querySelectorAll('.glozone-tab').forEach(t => t.classList.remove('active'));
      document.querySelectorAll('.glozone-content').forEach(c => c.classList.remove('active'));
      tab.classList.add('active');
      document.getElementById(`${tab.dataset.tab}-content`)?.classList.add('active');
    });
  });

  // Add buttons
  document.getElementById('add-zone-btn')?.addEventListener('click', () => showModal('create-zone'));

  // Zone rename button
  document.getElementById('zone-rename-btn')?.addEventListener('click', () => {
    if (selectedZone) showModal('rename-zone', selectedZone);
  });

  // Modal buttons
  document.getElementById('modal-cancel')?.addEventListener('click', hideModal);
  document.getElementById('modal-confirm')?.addEventListener('click', handleModalConfirm);

  // Close modal on overlay click
  document.getElementById('glozone-modal')?.addEventListener('click', (e) => {
    if (e.target.classList.contains('glozone-modal-overlay')) hideModal();
  });

  // Load data
  fetchAllAreas();
  fetchGlozones();
}

// ============================================================
// Zone Loading & Saving
// ============================================================

let selectedZoneName = 'Daily Rhythm 1';

/**
 * Get zone name from injected page data or URL path (e.g., /zone-design/MyZone)
 */
function getZoneNameFromUrl() {
  // Prefer injected data from server
  const data = window.circadianData || {};
  if (data.selectedZoneName) {
    return data.selectedZoneName;
  }
  // Fallback: parse from URL (match both /zone-design/ and /zone/)
  const path = window.location.pathname;
  const match = path.match(/\/(?:zone-design|zone)\/([^/]+)$/);
  if (match) {
    return decodeURIComponent(match[1]);
  }
  return null;
}

/**
 * Load zone rhythm settings from the glozones API
 */
async function loadZoneFromData() {
  const zoneName = getZoneNameFromUrl();
  if (!zoneName) {
    // No zone specified - redirect to home
    const path = window.location.pathname;
    const base = path.replace(/\/(?:zone-design|zone)\/[^/]*\/?$/, '').replace(/\/(?:zone-design|zone)\/?$/, '');
    window.location.href = (base || '.') + '/';
    return;
  }

  selectedZoneName = zoneName;

  // Set name input
  const nameInput = document.getElementById('rhythm-name');
  if (nameInput) nameInput.value = zoneName;

  try {
    const response = await fetch('./api/glozones');
    if (response.ok) {
      const data = await response.json();
      const zones = data.zones || {};
      glozonesData = zones;
      const zoneData = zones[zoneName] || {};

      // Merge zone rhythm settings into config object
      Object.assign(config, zoneData);

      syncUIFromConfig();
      renderChart();
    }
  } catch (err) {
    console.error('Error loading zone:', err);
  }
}

/**
 * Save current settings to the selected zone
 */
async function saveZoneSettings() {
  const statusEl = document.getElementById('save-status');
  const newName = document.getElementById('rhythm-name')?.value.trim();

  if (!newName) {
    statusEl.innerHTML = '<div class="error">Name cannot be empty</div>';
    setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
    return;
  }

  const zoneSettings = {
    wake_time: config.wake_time,
    bed_time: config.bed_time,
    wake_speed: config.wake_speed,
    bed_speed: config.bed_speed,
    ascend_start: config.ascend_start,
    descend_start: config.descend_start,
    min_brightness: config.min_brightness,
    max_brightness: config.max_brightness,
    min_color_temp: config.min_color_temp,
    max_color_temp: config.max_color_temp,
    color_mode: config.color_mode,
    wake_alt_time: config.wake_alt_time,
    wake_alt_days: config.wake_alt_days,
    bed_alt_time: config.bed_alt_time,
    bed_alt_days: config.bed_alt_days,
    _wake_alt_time_last: config._wake_alt_time_last,
    _bed_alt_time_last: config._bed_alt_time_last,
    wake_brightness: config.wake_brightness,
    bed_brightness: config.bed_brightness,
    warm_night_enabled: config.warm_night_enabled,
    warm_night_mode: config.warm_night_mode,
    warm_night_target: config.warm_night_target,
    warm_night_start: config.warm_night_start,
    warm_night_end: config.warm_night_end,
    warm_night_fade: config.warm_night_fade,
    daylight_enabled: config.daylight_enabled,
    daylight_cct: config.daylight_cct,
    daylight_start: config.daylight_start,
    daylight_end: config.daylight_end,
    daylight_fade: config.daylight_fade,
    color_sensitivity: config.color_sensitivity,
    activity_preset: config.activity_preset,
  };

  // Include name for rename support
  if (newName !== selectedZoneName) {
    zoneSettings.name = newName;
  }

  try {
    const response = await fetch(`./api/glozones/${encodeURIComponent(selectedZoneName)}/settings`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(zoneSettings)
    });

    const saveBtn = document.getElementById('save-config');
    if (response.ok) {
      if (newName !== selectedZoneName) {
        // Update URL to reflect new name
        selectedZoneName = newName;
        const basePath = window.location.pathname.replace(/\/(?:zone-design|zone)\/[^/]+\/?$/, '');
        // Preserve current URL prefix (/zone/ or /zone-design/)
        const prefix = window.location.pathname.includes('/zone-design/') ? '/zone-design/' : '/zone/';
        window.history.replaceState(null, '', basePath + prefix + encodeURIComponent(newName) + window.location.search);
      }
      // Brief feedback then navigate back
      if (saveBtn) {
        saveBtn.textContent = 'Saved';
        saveBtn.classList.add('saved');
      }
      if (typeof _saveCallback === 'function') {
        setTimeout(_saveCallback, 600);
      }
    } else {
      const data = await response.json();
      statusEl.innerHTML = '<div class="error">' + (data.error || 'Failed to save') + '</div>';
      setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
    }
  } catch (err) {
    statusEl.innerHTML = '<div class="error">Error: ' + err.message + '</div>';
    setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
  }
}

/**
 * Navigation
 */
const _basePath = window.location.pathname.replace(/\/(?:zone-design|zone)\/[^/]*\/?$/, '').replace(/\/(?:zone-design|zone)\/?$/, '');
const _backParam = new URLSearchParams(window.location.search).get('back');
const _backUrl = _backParam && _backParam !== 'home'
  ? (_basePath || '.') + '/' + _backParam
  : (_basePath || '.') + '/';

function goBack() {
  if (window.history.length > 1 && document.referrer) {
    window.history.back();
  } else {
    window.location.href = _backUrl;
  }
}

let _saveCallback = goBack;

/**
 * Setup save and cancel buttons
 */
function setupSaveButton() {
  document.getElementById('save-config')?.addEventListener('click', (e) => {
    e.preventDefault();
    e.stopImmediatePropagation();
    saveZoneSettings();
  });
  document.getElementById('cancel-btn')?.addEventListener('click', goBack);
}

// ============================================================

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('chart-date-slider');
  if (slider) {
    const now = new Date();
    const start = new Date(now.getFullYear(), 0, 1);
    const diff = now - start;
    const dayOfYear = Math.floor(diff / 86400000);
    slider.value = dayOfYear;
  }

  // Apply server-injected global settings (lat, lon, timezone) before first render
  const injectedCfg = (window.circadianData || {}).config || {};
  ['latitude', 'longitude', 'timezone', 'use_ha_location'].forEach(key => {
    if (injectedCfg[key] != null) config[key] = injectedCfg[key];
  });

  setupEventListeners();
  setupLiveDesign();
  setupSaveButton();
  syncUIFromConfig();

  // Set cursor to current time on page load
  const now = new Date();
  cursorHour = now.getHours() + now.getMinutes() / 60;

  renderChart();
  applyCursor();
  updateDesignModeUI();

  // Load zone settings from API
  loadZoneFromData();

  // Keep cursor at "now" when not in Live Design mode (tick every 30s)
  setInterval(() => {
    if (!liveDesignEnabled) {
      snapCursorToNow();
    }
  }, 30000);
});
</script>
</body>
</html>
