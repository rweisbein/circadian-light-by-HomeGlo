<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Circadian Light - Home</title>
  <style>
    :root {
      --bg: #000;
      --panel: #111;
      --card: #1a1a1a;
      --accent: #feac60;
      --accent-hover: #ffc078;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --muted2: #64748b;
      --line: #334155;
      --success: #22c55e;
      --warning: #f59e0b;
      --danger: #ef4444;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    /* Navigation */
    .nav {
      background: var(--panel);
      border-bottom: 1px solid var(--line);
      padding: 0 24px;
      display: flex;
      align-items: center;
      height: 56px;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .nav-brand {
      font-weight: 600;
      font-size: 1.1rem;
      color: var(--text);
      margin-right: 32px;
      text-decoration: none;
    }

    .nav-brand.active {
      color: var(--accent);
    }

    .nav-links {
      display: flex;
      gap: 8px;
    }

    .nav-link {
      padding: 8px 16px;
      color: var(--muted);
      text-decoration: none;
      border-radius: 6px;
      font-size: 0.9rem;
      transition: all 0.2s;
    }

    .nav-link:hover {
      color: var(--text);
      background: rgba(255, 255, 255, 0.05);
    }

    .nav-link.active {
      color: var(--accent);
    }

    /* Main Content */
    .main {
      max-width: 1000px;
      margin: 0 auto;
      padding: 24px;
    }

    .page-header {
      margin-bottom: 24px;
    }

    .page-title {
      font-size: 1.5rem;
      font-weight: 600;
    }

    /* Areas Table */
    .areas-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 8px;
      overflow: hidden;
    }

    .areas-table th {
      text-align: left;
      padding: 12px 16px;
      background: var(--panel);
      border-bottom: 1px solid var(--line);
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
      transition: color 0.2s;
    }

    .areas-table th:hover {
      color: var(--text);
    }

    .areas-table th.sorted {
      color: var(--accent);
    }

    .areas-table th .sort-arrow {
      margin-left: 6px;
      opacity: 0.5;
    }

    .areas-table th.sorted .sort-arrow {
      opacity: 1;
    }

    .areas-table td {
      padding: 12px 16px;
      border-bottom: 1px solid var(--line);
      font-size: 0.9rem;
    }

    .areas-table tr:last-child td {
      border-bottom: none;
    }

    .areas-table tr:hover td {
      background: rgba(255, 255, 255, 0.02);
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 48px 24px;
      color: var(--muted);
    }

    .empty-state-title {
      font-size: 1.1rem;
      margin-bottom: 8px;
      color: var(--text);
    }

    .empty-state-text {
      font-size: 0.9rem;
    }

    /* Loading State */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 48px;
      color: var(--muted);
    }

    /* Status badges */
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 500;
    }

    .status-on {
      background: rgba(34, 197, 94, 0.15);
      color: var(--success);
    }

    .status-off {
      background: rgba(148, 163, 184, 0.15);
      color: var(--muted);
    }

    .status-frozen {
      background: rgba(99, 179, 237, 0.15);
      color: #63b3ed;
    }

    /* Header with filter */
    .th-with-filter {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .th-title-row {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .header-filter {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--text);
      font-size: 0.75rem;
      font-weight: normal;
      cursor: pointer;
      width: 100%;
    }

    .header-filter:focus {
      outline: none;
      border-color: var(--accent);
    }

    /* Brightness/Color display */
    .lighting-info {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
    }

    .brightness-value,
    .kelvin-value {
      /* Inherit color from row */
    }

    /* Buttons */
    .btn {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-secondary {
      background: var(--card);
      border: 1px solid var(--line);
      color: var(--text);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Clickable rows */
    .areas-table tbody tr {
      cursor: pointer;
    }

    /* Modal */
    .modal-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background: rgba(0, 0, 0, 0.7);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 200;
      opacity: 0;
      visibility: hidden;
      transition: all 0.2s;
    }

    .modal-overlay.visible {
      opacity: 1;
      visibility: visible;
    }

    .modal {
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 24px;
      min-width: 460px;
      max-width: 90%;
      max-height: 90vh;
      overflow-y: auto;
    }

    .modal-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      margin-bottom: 20px;
    }

    .modal-title {
      font-size: 1.2rem;
      font-weight: 600;
    }

    .modal-close {
      background: transparent;
      border: none;
      color: var(--muted);
      font-size: 1.5rem;
      cursor: pointer;
      padding: 4px 8px;
      line-height: 1;
    }

    .modal-close:hover {
      color: var(--text);
    }

    /* Area state display - with dynamic shading */
    .area-state {
      --state-bg: var(--panel);
      --state-fill: 0;
      background: var(--state-bg);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 12px;
      position: relative;
      overflow: hidden;
    }

    .area-state::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.5));
      opacity: 0.6;
      transform-origin: left center;
      transform: scaleX(var(--state-fill));
      pointer-events: none;
    }

    .area-state-row {
      display: flex;
      align-items: center;
      gap: 16px;
      position: relative;
      z-index: 1;
    }

    .area-state-info {
      flex: 1;
      min-width: 0;
      display: flex;
      align-items: center;
    }

    .area-state-values {
      font-size: 1.4rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      height: 100%;
      gap: 6px;
    }

    .area-state-controls {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
      background: rgba(0,0,0,0.5);
      padding: 6px;
      border-radius: 10px;
    }

    .area-state-controls-left {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
      background: rgba(0,0,0,0.5);
      padding: 6px;
      border-radius: 10px;
      margin-right: 12px;
    }

    /* Toggle switch styles */
    .toggle-btn {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(30,30,30,0.9);
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      font-size: 1.1rem;
    }

    .toggle-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: rgba(50,50,50,0.9);
    }

    .toggle-btn.active {
      background: rgba(60,60,60,0.9);
      color: var(--text);
      border-color: var(--accent);
    }

    .toggle-btn svg {
      width: 18px;
      height: 18px;
    }

    /* Reset button - prominent */
    .reset-section {
      display: flex;
      justify-content: center;
      margin-bottom: 12px;
    }

    .reset-btn {
      padding: 10px 32px;
      border-radius: 6px;
      font-size: 0.9rem;
      font-weight: 600;
      cursor: pointer;
      background: var(--panel);
      border: 1px solid var(--line);
      color: var(--text);
      transition: all 0.2s;
    }

    .reset-btn:hover {
      background: rgba(255,255,255,0.1);
      border-color: var(--accent);
    }

    /* Modal context info (Glo zone + Rhythm) */
    .modal-context-info {
      display: flex;
      gap: 20px;
      padding: 6px 0;
      font-size: 0.85rem;
    }

    .context-line {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .context-label {
      color: var(--muted);
    }

    .context-link {
      color: var(--accent);
      text-decoration: none;
      transition: color 0.2s;
    }

    .context-link:hover {
      color: var(--accent-hover);
      text-decoration: underline;
    }

    /* Timer status row (motion + boost between header and chart) */
    .modal-timer-status {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
      font-size: 0.8rem;
      min-height: 0;
    }

    .modal-timer-status:empty {
      display: none;
    }

    .timer-motion {
      color: var(--muted);
    }

    .timer-boost {
      color: var(--muted);
      margin-left: auto;
    }

    .timer-arrow {
      color: var(--muted2);
      margin: 0 3px;
    }

    .timer-warning {
      color: #e6a817;
      animation: timer-pulse 1s ease-in-out infinite;
    }

    @keyframes timer-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    /* Action buttons */
    .action-section {
      margin-bottom: 16px;
    }

    .action-section-title {
      font-size: 0.8rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
      margin-bottom: 8px;
    }

    .action-buttons {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }

    .action-btn {
      padding: 10px 16px;
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
      background: var(--panel);
      border: 1px solid var(--line);
      color: var(--text);
    }

    .action-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--accent);
    }

    .action-btn:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .action-btn.primary {
      background: var(--accent);
      border-color: var(--accent);
      color: #000;
    }

    .action-btn.primary:hover {
      background: var(--accent-hover);
    }

    .action-btn.success {
      background: rgba(34, 197, 94, 0.15);
      border-color: var(--success);
      color: var(--success);
    }

    .action-btn.danger {
      background: rgba(239, 68, 68, 0.15);
      border-color: var(--danger);
      color: var(--danger);
    }

    /* Adjust buttons - styled like glo-designer */
    .adjust-section {
      margin-bottom: 16px;
    }
    .adjust-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 12px;
    }
    .adjust-stack {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 6px;
    }
    .adjust-stack-label {
      font-size: 0.75rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    .adjust-btn-col {
      display: flex;
      flex-direction: column;
      gap: 6px;
      width: 100%;
    }
    .adjust-btn {
      --btn-bg: rgba(255,255,255,0.06);
      --btn-text: #fff;
      --btn-fill: 0;
      --btn-fill-opacity: 0;
      border: 1px solid rgba(255,255,255,0.25);
      background: var(--btn-bg);
      color: var(--btn-text);
      font-size: 1.1rem;
      font-weight: 600;
      padding: 10px 16px;
      border-radius: 999px;
      cursor: pointer;
      transition: border-color 0.15s, opacity 0.15s;
      position: relative;
      overflow: hidden;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    .adjust-btn::after {
      content: '';
      position: absolute;
      inset: 2px;
      border-radius: 999px;
      background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0.95));
      opacity: var(--btn-fill-opacity);
      transform-origin: left center;
      transform: scaleX(var(--btn-fill));
      transition: transform 0.2s ease, opacity 0.2s ease;
      pointer-events: none;
    }
    .adjust-btn .btn-arrow {
      position: relative;
      z-index: 1;
      font-size: 1.1rem;
      line-height: 1;
    }
    .adjust-btn:hover {
      border-color: rgba(255,255,255,0.45);
    }
    .adjust-btn:disabled {
      opacity: 0.4;
      cursor: not-allowed;
    }

    /* Mini chart container */
    #modal-mini-chart {
      width: 100%;
      height: 280px;
      margin: 8px 0;
    }

    /* Area row - div-based for proper shading like modal header */
    .area-row {
      --row-bg: var(--card);
      --row-text: var(--text);
      --row-fill: 0;
      display: flex;
      align-items: center;
      padding: 2px 16px 2px 28px;
      gap: 16px;
      background: var(--row-bg);
      color: var(--row-text);
      border-bottom: 1px solid var(--line);
      cursor: pointer;
      position: relative;
      overflow: hidden;
    }

    .area-row:last-child {
      border-bottom: none;
    }

    .area-row:hover {
      background: color-mix(in srgb, var(--row-bg), white 3%);
    }

    /* Fill overlay - identical to modal header ::before */
    .area-row::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.5));
      opacity: 0.6;
      transform-origin: left center;
      transform: scaleX(var(--row-fill));
      pointer-events: none;
    }

    .area-row > * {
      position: relative;
      z-index: 1;
    }

    .area-row-name {
      flex: 1;
      min-width: 0;
      font-size: 0.82rem;
    }

    .area-row-lighting {
      font-size: 0.85rem;
      white-space: nowrap;
    }

    .area-row-timer {
      font-size: 0.75rem;
      white-space: nowrap;
      opacity: 0.7;
    }

    /* Row control buttons - dark container like modal header */
    .row-controls {
      display: inline-flex;
      gap: 4px;
      background: rgba(0,0,0,0.5);
      padding: 4px;
      border-radius: 8px;
    }

    .row-controls-left {
      display: inline-flex;
      gap: 4px;
      background: rgba(0,0,0,0.5);
      padding: 4px;
      border-radius: 8px;
      margin-right: 8px;
    }

    .row-btn {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(30,30,30,0.9);
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      padding: 0;
    }

    .row-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: rgba(50,50,50,0.9);
    }

    .row-btn.active {
      background: rgba(60,60,60,0.9);
      color: var(--text);
      border-color: var(--accent);
    }

    .row-btn svg {
      width: 14px;
      height: 14px;
    }

    /* On/Off section headers */
    .onoff-section-header {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--muted);
      padding: 10px 16px 6px;
      letter-spacing: 0.03em;
    }

    /* Zone group headers */
    .zone-group {
      margin-bottom: 16px;
    }

    .zone-group:last-child {
      margin-bottom: 0;
    }

    .zone-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 14px 16px;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      user-select: none;
      transition: background 0.15s;
      position: relative;
    }

    .zone-header::before {
      content: '';
      position: absolute;
      inset: 0;
      background: linear-gradient(90deg, rgba(255,255,255,0.03), rgba(255,255,255,0.5));
      opacity: 0.6;
      transform-origin: left center;
      transform: scaleX(var(--header-fill, 0));
      pointer-events: none;
      border-radius: 8px 8px 0 0;
      overflow: hidden;
    }

    .zone-header > * {
      position: relative;
      z-index: 1;
    }

    .zone-header:hover {
      background: rgba(255,255,255,0.05);
    }

    .zone-header.collapsed {
      border-radius: 8px;
    }

    .zone-chevron {
      width: 16px;
      height: 16px;
      color: var(--muted);
      transition: transform 0.2s;
      background: rgba(0,0,0,0.45);
      border-radius: 50%;
      padding: 2px;
      box-sizing: content-box;
      box-shadow: 0 0 0 1.5px rgba(255,255,255,0.25);
    }

    .zone-header.collapsed .zone-chevron {
      transform: rotate(-90deg);
    }

    .zone-name {
      font-weight: 700;
      font-size: 1.05rem;
      letter-spacing: 0.01em;
      color: var(--text);
    }

    .zone-count {
      font-size: 0.8rem;
      color: var(--muted);
      margin-left: auto;
    }

    .zone-content {
      background: var(--card);
      border: 1px solid var(--line);
      border-top: none;
      border-radius: 0 0 8px 8px;
      overflow: hidden;
    }

    .zone-content.hidden {
      display: none;
    }

    /* Zone rhythm dropdown in header */
    .zone-rhythm-display {
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      margin-left: 4px;
    }

    .zone-rhythm-label {
      font-size: 0.75rem;
      opacity: 0.6;
    }

    .zone-rhythm-btn {
      background: transparent;
      border: none;
      padding: 0;
      font-size: 0.8rem;
      font-weight: 600;
      color: inherit;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .zone-rhythm-btn::after {
      content: ' ▾';
      font-size: 0.7rem;
      opacity: 0.6;
    }

    .zone-rhythm-btn:hover {
      opacity: 0.8;
    }

    .zone-rhythm-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      min-width: 160px;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      z-index: 50;
      display: none;
      margin-top: 4px;
    }

    .zone-rhythm-dropdown.visible {
      display: block;
    }

    .zone-rhythm-dropdown-item {
      padding: 8px 14px;
      font-size: 0.85rem;
      cursor: pointer;
      border-bottom: 1px solid var(--line);
      color: var(--text);
    }

    .zone-rhythm-dropdown-item:last-child {
      border-bottom: none;
    }

    .zone-rhythm-dropdown-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .zone-rhythm-dropdown-item.selected {
      color: var(--accent);
    }

    a.zone-rhythm-dropdown-item {
      display: block;
      text-decoration: none;
      color: var(--muted);
    }

    /* Solar display */
    .solar-display {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 8px 16px 12px;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .solar-icon {
      flex-shrink: 0;
    }

    .solar-times {
      display: flex;
      gap: 14px;
      align-items: center;
    }

    .solar-times span {
      white-space: nowrap;
    }

    /* Red dot: area doesn't match zone */
    .mismatch-dot-area {
      position: absolute;
      left: 8px;
      top: 50%;
      transform: translateY(-50%);
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: rgba(239, 68, 68, 0.8);
      z-index: 2;
      /* contrast ring set via inline box-shadow using row text color */
    }

    /* Red dot: zone doesn't match rhythm */
    .mismatch-dot-zone {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      background: rgba(239, 68, 68, 0.85);
      flex-shrink: 0;
      /* contrast ring set via inline box-shadow using header text color */
    }

    /* Zone reset button */
    .zone-reset-btn {
      width: 24px;
      height: 24px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(30,30,30,0.9);
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      padding: 0;
      flex-shrink: 0;
    }

    .zone-reset-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: rgba(50,50,50,0.9);
    }

    .zone-reset-btn svg {
      width: 14px;
      height: 14px;
    }
  </style>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <script src="./shared.js"></script>
</head>
<body>
  <!-- Navigation -->
  <nav class="nav">
    <a href="./" class="nav-brand active">Circadian Light</a>
    <div class="nav-links">
      <a href="./glo" class="nav-link">Rhythms</a>
      <a href="./zones" class="nav-link">Glo zones</a>
      <a href="./switches" class="nav-link">Controls</a>
      <a href="./settings" class="nav-link">Settings</a>
    </div>
  </nav>

  <!-- Main Content -->
  <main class="main">
    <div class="solar-display" id="solar-display">
      <svg id="solar-icon" class="solar-icon" width="28" height="28" viewBox="0 0 28 28"></svg>
      <div class="solar-times">
        <span id="sunrise-label">↑ --</span>
        <span id="sunset-label">↓ --</span>
      </div>
    </div>

    <!-- Areas grouped by zone -->
    <div id="areas-container">
      <div class="loading">Loading areas...</div>
    </div>
  </main>

  <!-- Area Modal -->
  <div class="modal-overlay" id="area-modal">
    <div class="modal">
      <div class="modal-header">
        <h3 class="modal-title" id="modal-area-name">Area Name</h3>
        <button class="modal-close" onclick="closeModal()">&times;</button>
      </div>

      <div class="modal-context-info" id="modal-context-info">
        <div class="context-line"><span class="context-label">Glo zone:</span> <a href="./zones" class="context-link" id="modal-zone-link">—</a></div>
        <div class="context-line"><span class="context-label">Rhythm:</span> <a href="./glo" class="context-link" id="modal-rhythm-link">—</a></div>
      </div>

      <div class="area-state" id="modal-area-state">
        <div class="area-state-row">
          <div class="area-state-controls-left">
            <button class="toggle-btn" id="toggle-circadian" onclick="toggleCircadian()" title="Circadian">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <circle cx="12" cy="12" r="5"/>
                <line x1="12" y1="1" x2="12" y2="3"/>
                <line x1="12" y1="21" x2="12" y2="23"/>
                <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
                <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
                <line x1="1" y1="12" x2="3" y2="12"/>
                <line x1="21" y1="12" x2="23" y2="12"/>
                <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
                <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
              </svg>
            </button>
            <button class="toggle-btn" id="toggle-power" onclick="executeAction('lights_toggle')" title="Power">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <path d="M18.36 6.64a9 9 0 1 1-12.73 0M12 2v10"/>
              </svg>
            </button>
          </div>
          <div class="area-state-info">
            <div class="area-state-values" id="modal-values"></div>
          </div>
          <div class="area-state-controls">
            <button class="toggle-btn" id="toggle-reset" onclick="executeAction('reset')" title="Pull Area's light from Glo Zone's">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
                <path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/>
                <path d="M3 3v5h5"/>
              </svg>
            </button>
            <button class="toggle-btn" id="toggle-freeze" onclick="executeAction('freeze_toggle')" title="Freeze">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
                <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
              </svg>
            </button>
            <button class="toggle-btn" id="toggle-boost" onclick="executeAction('boost')" title="Boost">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
              </svg>
            </button>
          </div>
        </div>
      </div>

      <div class="modal-timer-status" id="modal-timer-status"></div>

      <div id="modal-mini-chart"></div>

      <div class="adjust-section">
        <div class="adjust-grid">
          <div class="adjust-stack">
            <span class="adjust-stack-label">Step</span>
            <div class="adjust-btn-col">
              <button class="adjust-btn" id="btn-step-up" onclick="executeAction('step_up')"><span class="btn-arrow">&#9650;</span></button>
              <button class="adjust-btn" id="btn-step-down" onclick="executeAction('step_down')"><span class="btn-arrow">&#9660;</span></button>
            </div>
          </div>
          <div class="adjust-stack">
            <span class="adjust-stack-label">Brightness</span>
            <div class="adjust-btn-col">
              <button class="adjust-btn" id="btn-bright-up" onclick="executeAction('bright_up')"><span class="btn-arrow">&#9650;</span></button>
              <button class="adjust-btn" id="btn-bright-down" onclick="executeAction('bright_down')"><span class="btn-arrow">&#9660;</span></button>
            </div>
          </div>
          <div class="adjust-stack">
            <span class="adjust-stack-label">Color</span>
            <div class="adjust-btn-col">
              <button class="adjust-btn" id="btn-color-up" onclick="executeAction('color_up')"><span class="btn-arrow">&#9650;</span></button>
              <button class="adjust-btn" id="btn-color-down" onclick="executeAction('color_down')"><span class="btn-arrow">&#9660;</span></button>
            </div>
          </div>
        </div>
      </div>

    </div>
  </div>

  <script>
    // State
    let areas = [];
    let areaStatus = {};
    let zoneStates = {};
    let cachedPresets = {};
    let sortMode = 'onoff';  // 'onoff', 'alpha', 'rhythm'
    let groupMode = 'zone';  // 'zone', 'onoff'
    let selectedArea = null;
    let cachedConfig = null;
    let cachedSunTimes = null; // { sunrise, sunset, solarNoon, solarMid } in local hours
    let modalTickInterval = null;   // 1s local countdown tick
    let modalRefreshInterval = null; // 1s modal API refresh (single area)
    let homeRefreshTimer = null;     // Home page card refresh timer
    let homeTickTimer = null;        // 1s home page timer countdown tick

    // ============================================================
    // Mini Circadian Graph — Calculation Functions
    // ============================================================

    const SPEED_TO_SLOPE = [0, 0.4, 0.6, 0.8, 1.0, 1.3, 1.7, 2.3, 3.0, 4.0, 5.5];

    function logistic(x, midpoint, slope, y0, y1) {
      try {
        const expVal = Math.exp(-slope * (x - midpoint));
        return y0 + (y1 - y0) / (1 + expVal);
      } catch {
        return slope * (x - midpoint) > 0 ? y1 : y0;
      }
    }

    function wrap24(x) {
      return ((x % 24) + 24) % 24;
    }

    function getWindowWeight(hour, windowStart, windowEnd, fadeHrs) {
      const h = wrap24(hour);
      let inWindow = false;
      let distFromStart = 0;
      let distToEnd = 0;

      if (windowStart > windowEnd) {
        inWindow = h >= windowStart || h <= windowEnd;
        if (inWindow) {
          distFromStart = h >= windowStart ? (h - windowStart) : (h + 24 - windowStart);
          distToEnd = h <= windowEnd ? (windowEnd - h) : (windowEnd + 24 - h);
        }
      } else {
        inWindow = h >= windowStart && h <= windowEnd;
        if (inWindow) {
          distFromStart = h - windowStart;
          distToEnd = windowEnd - h;
        }
      }

      if (!inWindow) {
        return { inWindow: false, weight: 0 };
      }

      let weight = 1;
      if (fadeHrs > 0.01) {
        if (distFromStart < fadeHrs) {
          weight = Math.min(weight, distFromStart / fadeHrs);
        }
        if (distToEnd < fadeHrs) {
          weight = Math.min(weight, distToEnd / fadeHrs);
        }
      }

      return { inWindow: true, weight };
    }

    function rad(d) { return d * Math.PI / 180; }

    /**
     * Client-side sun time calculation (matches glo-designer.html).
     * Returns { sunrise, sunset, solarNoon, solarMid } as local hour values.
     */
    function getSunTimes(lat, lon) {
      const date = new Date();
      const n = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
      const J = n + ((lon < 0 ? 360 + lon : lon) / 360);
      const M = (357.5291 + 0.9856 * J) % 360;
      const C = 1.9148 * Math.sin(rad(M)) + 0.02 * Math.sin(rad(2 * M)) + 0.0003 * Math.sin(rad(3 * M));
      const L = (M + 102.9372 + C + 180) % 360;
      const D = Math.asin(Math.sin(rad(L)) * Math.sin(rad(23.44)));
      const cosH0 = (Math.cos(rad(90.833)) - Math.sin(rad(lat)) * Math.sin(D)) / (Math.cos(rad(lat)) * Math.cos(D));

      if (cosH0 < -1 || cosH0 > 1) {
        const sn = 12 - date.getTimezoneOffset() / 60 - (lon / 15);
        return { sunrise: sn - 6, sunset: sn + 6, solarNoon: sn, solarMid: (sn + 12) % 24 };
      }

      const H0 = Math.acos(cosH0);
      const dl = (2 * H0 * 180 / Math.PI) / 15;
      const tz = -date.getTimezoneOffset() / 60;
      const sn = 12 + tz - (lon / 15);
      return { sunrise: sn - dl / 2, sunset: sn + dl / 2, solarNoon: sn, solarMid: (sn + 12) % 24 };
    }

    function liftMidpointToPhase(midpoint, phaseStart, phaseEnd) {
      const phaseCenter = (phaseStart + phaseEnd) / 2;
      let mid = midpoint;
      while (mid < phaseCenter - 12) mid += 24;
      while (mid > phaseCenter + 12) mid -= 24;
      const margin = 0.01;
      return Math.max(phaseStart + margin, Math.min(phaseEnd - margin, mid));
    }

    function applySolarRule(baseCCT, hour, cfg, sunTimes, colorOverride) {
      if (!sunTimes) return baseCCT;

      let cct = baseCCT;
      const sunrise = sunTimes.sunrise;
      const sunset = sunTimes.sunset;
      const solarNoon = sunTimes.solarNoon;
      const solarMid = sunTimes.solarMid;

      // Warm night — ceiling
      if (cfg.warm_night_enabled) {
        let warmTarget = cfg.warm_night_target;
        if (colorOverride && colorOverride > 0) {
          warmTarget += colorOverride;
        }

        if (cct > warmTarget) {
          const fadeHrs = cfg.warm_night_fade / 60;
          const startOffsetHrs = cfg.warm_night_start / 60;
          const endOffsetHrs = cfg.warm_night_end / 60;
          const mode = cfg.warm_night_mode;

          let windowStart, windowEnd;
          if (mode === 'sunrise') {
            windowStart = wrap24(solarMid);
            windowEnd = wrap24(sunrise + endOffsetHrs);
          } else if (mode === 'sunset') {
            windowStart = wrap24(sunset + startOffsetHrs);
            windowEnd = wrap24(solarMid);
          } else {
            windowStart = wrap24(sunset + startOffsetHrs);
            windowEnd = wrap24(sunrise + endOffsetHrs);
          }

          const { inWindow, weight } = getWindowWeight(hour, windowStart, windowEnd, fadeHrs);
          if (inWindow && weight > 0) {
            cct = cct + (warmTarget - cct) * weight;
          }
        }
      }

      // Cool day — floor
      if (cfg.cool_day_enabled) {
        let coolTarget = cfg.cool_day_target;
        if (colorOverride && colorOverride < 0) {
          coolTarget += colorOverride;
        }

        if (cct < coolTarget) {
          const fadeHrs = cfg.cool_day_fade / 60;
          const startOffsetHrs = cfg.cool_day_start / 60;
          const endOffsetHrs = cfg.cool_day_end / 60;
          const mode = cfg.cool_day_mode;

          let windowStart, windowEnd;
          if (mode === 'sunrise') {
            windowStart = wrap24(sunrise + startOffsetHrs);
            windowEnd = wrap24(solarNoon);
          } else if (mode === 'sunset') {
            windowStart = wrap24(solarNoon);
            windowEnd = wrap24(sunset + endOffsetHrs);
          } else {
            windowStart = wrap24(sunrise + startOffsetHrs);
            windowEnd = wrap24(sunset + endOffsetHrs);
          }

          const { inWindow, weight } = getWindowWeight(hour, windowStart, windowEnd, fadeHrs);
          if (inWindow && weight > 0) {
            cct = cct + (coolTarget - cct) * weight;
          }
        }
      }

      return cct;
    }

    /**
     * Calculate brightness (0-1) at a given hour using the area's state overrides.
     * cfg = cachedConfig, state = { brightness_mid, color_mid, color_override, frozen_at }
     * currentHour = the hour used to determine which phase runtimeState applies to
     */
    function calcMiniBrightness(hour, cfg, state, currentHour) {
      const tAscend = cfg.ascend_start;
      let tDescend = cfg.descend_start;
      if (tDescend <= tAscend) tDescend += 24;

      const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, cfg.wake_speed))];
      const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, cfg.bed_speed))];
      const bMin = cfg.min_brightness / 100;
      const bMax = cfg.max_brightness / 100;

      // Determine which phase the current time (cursor) is in
      const cursorH48 = currentHour < tAscend ? currentHour + 24 : currentHour;
      const cursorInAscend = cursorH48 >= tAscend && cursorH48 < tDescend;

      const wakeMid = cursorInAscend ? (state.brightness_mid ?? cfg.wake_time) : cfg.wake_time;
      const bedMid = !cursorInAscend ? (state.brightness_mid ?? cfg.bed_time) : cfg.bed_time;

      // Phase detection for this sample hour
      const h48 = hour < tAscend ? hour + 24 : hour;
      const inAscend = h48 >= tAscend && h48 < tDescend;

      const mid48 = inAscend
        ? liftMidpointToPhase(wakeMid, tAscend, tDescend)
        : liftMidpointToPhase(bedMid, tDescend, tDescend + 24);

      let value;
      if (inAscend) {
        value = logistic(h48, mid48, kAscend, bMin, bMax);
      } else {
        const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
        value = logistic(hDescend48, mid48, -kDescend, bMin, bMax);
      }

      return Math.max(bMin, Math.min(bMax, value));
    }

    /**
     * Calculate CCT (Kelvin) at a given hour, with solar rules applied.
     */
    function calcMiniColor(hour, cfg, state, sunTimes, currentHour) {
      const tAscend = cfg.ascend_start;
      let tDescend = cfg.descend_start;
      if (tDescend <= tAscend) tDescend += 24;

      const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, cfg.wake_speed))];
      const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, cfg.bed_speed))];
      const cLow = cfg.min_color_temp;
      const cHigh = cfg.max_color_temp;

      const cursorH48 = currentHour < tAscend ? currentHour + 24 : currentHour;
      const cursorInAscend = cursorH48 >= tAscend && cursorH48 < tDescend;

      const colorWakeMid = cursorInAscend ? (state.color_mid ?? cfg.wake_time) : cfg.wake_time;
      const colorBedMid = !cursorInAscend ? (state.color_mid ?? cfg.bed_time) : cfg.bed_time;

      const h48 = hour < tAscend ? hour + 24 : hour;
      const inAscend = h48 >= tAscend && h48 < tDescend;

      const mid48 = inAscend
        ? liftMidpointToPhase(colorWakeMid, tAscend, tDescend)
        : liftMidpointToPhase(colorBedMid, tDescend, tDescend + 24);

      let normalized;
      if (inAscend) {
        normalized = logistic(h48, mid48, kAscend, 0, 1);
      } else {
        const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
        normalized = logistic(hDescend48, mid48, -kDescend, 0, 1);
      }
      normalized = Math.max(0, Math.min(1, normalized));

      let cct = cLow + (cHigh - cLow) * normalized;

      // Apply solar rules
      cct = applySolarRule(cct, hour, cfg, sunTimes, state.color_override);

      return cct;
    }

    /**
     * Generate 240 samples of brightness% and CCT across 24 hours.
     */
    function calcMiniCurveData(cfg, state, sunTimes, currentHour) {
      const numSamples = 240;
      const hours = [];
      const brightnessPct = [];
      const cct = [];

      for (let i = 0; i < numSamples; i++) {
        const h = (i / numSamples) * 24;
        hours.push(h);
        brightnessPct.push(calcMiniBrightness(h, cfg, state, currentHour) * 100);
        cct.push(calcMiniColor(h, cfg, state, sunTimes, currentHour));
      }

      return { hours, brightnessPct, cct };
    }

    // ============================================================
    // Mini Circadian Graph — Rendering
    // ============================================================

    function formatHourLabel(h) {
      const h24 = ((h % 24) + 24) % 24;
      let hr = Math.floor(h24);
      let min = Math.round((h24 - hr) * 60);
      if (min === 60) { min = 0; hr = (hr + 1) % 24; }
      const suffix = hr < 12 ? 'a' : 'p';
      const hr12 = hr === 0 ? 12 : (hr > 12 ? hr - 12 : hr);
      return min === 0 ? `${hr12}${suffix}` : `${hr12}:${min.toString().padStart(2, '0')}${suffix}`;
    }

    function formatCountdown(isoTimestamp) {
      if (!isoTimestamp) return null;
      const expires = new Date(isoTimestamp);
      if (isNaN(expires.getTime())) return null;  // Invalid date (e.g. "motion" sentinel)
      const now = new Date();
      const diffMs = expires - now;
      if (diffMs <= 0) return null;
      const totalSec = Math.floor(diffMs / 1000);
      if (totalSec < 60) return `${totalSec}s`;
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      if (min < 60) return sec > 0 ? `${min}m ${sec}s` : `${min}m`;
      const hr = Math.floor(min / 60);
      const remMin = min % 60;
      return remMin > 0 ? `${hr}h ${remMin}m` : `${hr}h`;
    }

    function renderMiniChart(cfg, state, sunTimes, currentHour, isActive) {
      if (!cfg || !sunTimes) return;

      const data = calcMiniCurveData(cfg, state, sunTimes, currentHour);
      const { hours, brightnessPct, cct } = data;

      const traces = [];

      // Color-gradient brightness curve (filled + line segments)
      const step = 2;
      for (let i = step; i < hours.length; i += step) {
        const color = cctToRGB(cct[i]);
        const fillColor = colorWithAlpha(color, 0.5);
        const x0 = hours[i - step];
        const x1 = hours[i];
        const y0 = brightnessPct[i - step];
        const y1 = brightnessPct[i];

        // Filled area under curve
        traces.push({
          type: 'scatter', mode: 'lines',
          x: [x0, x1, x1, x0], y: [y0, y1, 0, 0],
          fill: 'toself', line: { width: 0 }, fillcolor: fillColor,
          hoverinfo: 'skip', showlegend: false
        });

        // Colored line segment
        traces.push({
          type: 'scatter', mode: 'lines',
          x: [x0, x1], y: [y0, y1],
          line: { width: 3, color },
          hoverinfo: 'skip', showlegend: false
        });
      }

      // Hover trace — CCT-colored tooltips
      const hoverDetails = brightnessPct.map((v, i) =>
        `${Math.round(v)}% • ${Math.round(cct[i])}K`
      );
      const hoverBgColors = cct.map(k => colorWithAlpha(cctToRGB(k), 0.92));
      const hoverTextColors = cct.map(k => readableTextColor(cctToRGB(k)));
      const hoverBorderColors = cct.map(k => colorWithAlpha(cctToRGB(k), 0.65));

      traces.push({
        type: 'scatter', mode: 'lines',
        x: hours, y: brightnessPct,
        line: { width: 0 }, showlegend: false,
        text: hoverDetails,
        hovertemplate: '%{text}<extra></extra>',
        hoverlabel: {
          bgcolor: hoverBgColors,
          bordercolor: hoverBorderColors,
          font: { color: hoverTextColors, size: 13 }
        }
      });

      // Live position marker (large size, outline color depends on active state)
      const markerBri = calcMiniBrightness(currentHour, cfg, state, currentHour) * 100;
      const markerCCT = calcMiniColor(currentHour, cfg, state, sunTimes, currentHour);
      const markerColor = cctToRGB(markerCCT);
      const markerOutline = isActive ? '#fff' : '#000';

      traces.push({
        x: [currentHour], y: [markerBri],
        mode: 'markers',
        marker: { size: 22, color: markerColor, line: { width: 3, color: markerOutline } },
        hoverinfo: 'skip', showlegend: false
      });

      // Shapes and annotations
      const shapes = [];
      const annotations = [];

      // Wake/bed vertical dashed lines (glo-designer colors)
      const wakeTime = wrap24(cfg.wake_time);
      const bedTime = wrap24(cfg.bed_time);

      shapes.push({
        type: 'line', xref: 'x', yref: 'paper',
        x0: wakeTime, x1: wakeTime, y0: -0.18, y1: 1,
        line: { color: 'rgba(92, 179, 255, 0.35)', width: 1.5, dash: 'dot' }
      });
      shapes.push({
        type: 'line', xref: 'x', yref: 'paper',
        x0: bedTime, x1: bedTime, y0: -0.18, y1: 1,
        line: { color: 'rgba(255, 230, 128, 0.35)', width: 1.5, dash: 'dot' }
      });

      // Sunrise/sunset vertical ticks (partial height, from below axis to ~30% of graph)
      const sunrise = sunTimes.sunrise;
      const sunset = sunTimes.sunset;
      const sunTickStyle = { color: 'rgba(215,215,215,0.4)', width: 1, dash: 'dot' };
      if (Number.isFinite(sunrise)) {
        shapes.push({
          type: 'line', xref: 'x', yref: 'paper',
          x0: sunrise, x1: sunrise, y0: -0.26, y1: 0,
          line: sunTickStyle
        });
      }
      if (Number.isFinite(sunset)) {
        shapes.push({
          type: 'line', xref: 'x', yref: 'paper',
          x0: sunset, x1: sunset, y0: -0.26, y1: 0,
          line: sunTickStyle
        });
      }

      // Layer 1: Wake/bed labels (below x-axis labels) — hover shows time
      annotations.push({
        x: wakeTime, y: -0.22, xref: 'x', yref: 'paper',
        text: 'wake', showarrow: false,
        font: { size: 10, color: '#5cb3ff' },
        hovertext: formatHourLabel(wakeTime),
        hoverlabel: { bgcolor: '#7fc7ff', bordercolor: '#7fc7ff', font: { color: '#000', size: 12 } }
      });
      annotations.push({
        x: bedTime, y: -0.22, xref: 'x', yref: 'paper',
        text: 'bed', showarrow: false,
        font: { size: 10, color: '#ffe680' },
        hovertext: formatHourLabel(bedTime),
        hoverlabel: { bgcolor: '#ffe680', bordercolor: '#ffe680', font: { color: '#000', size: 12 } }
      });

      // Layer 2: Sunrise/sunset labels (below wake/bed) — hover shows time
      if (Number.isFinite(sunrise)) {
        annotations.push({
          x: sunrise, y: -0.30, xref: 'x', yref: 'paper',
          text: 'sunrise', showarrow: false,
          font: { size: 9, color: 'rgba(215,215,215,0.6)' },
          hovertext: formatHourLabel(sunrise),
          hoverlabel: { bgcolor: '#3a3a3a', bordercolor: '#3a3a3a', font: { color: '#fff', size: 12 } }
        });
      }
      if (Number.isFinite(sunset)) {
        annotations.push({
          x: sunset, y: -0.30, xref: 'x', yref: 'paper',
          text: 'sunset', showarrow: false,
          font: { size: 9, color: 'rgba(215,215,215,0.6)' },
          hovertext: formatHourLabel(sunset),
          hoverlabel: { bgcolor: '#3a3a3a', bordercolor: '#3a3a3a', font: { color: '#fff', size: 12 } }
        });
      }

      // "Now" cursor vertical line (prominent, with gap around marker)
      const now = new Date();
      const nowHour = now.getHours() + now.getMinutes() / 60;
      const nowLineStyle = { color: '#fdfdfd', width: 2, dash: 'dot' };
      const gap = 5;  // Gap around marker in y-units
      const lowerEnd = Math.max(0, markerBri - gap);
      const upperStart = Math.min(110, markerBri + gap);

      // Lower segment (0 to just below marker)
      shapes.push({
        type: 'line', xref: 'x', yref: 'y',
        x0: nowHour, x1: nowHour, y0: 0, y1: lowerEnd,
        line: nowLineStyle, layer: 'above'
      });
      // Upper segment (just above marker to top)
      shapes.push({
        type: 'line', xref: 'x', yref: 'y',
        x0: nowHour, x1: nowHour, y0: upperStart, y1: 110,
        line: nowLineStyle, layer: 'above'
      });
      // Line from x-axis down to above label (stops before text)
      shapes.push({
        type: 'line', xref: 'x', yref: 'paper',
        x0: nowHour, x1: nowHour, y0: -0.42, y1: 0,
        line: nowLineStyle, layer: 'above'
      });

      // Layer 3 (lowest): "Now" label with time
      const nowTimeStr = formatHourLabel(nowHour);
      annotations.push({
        x: nowHour, y: -0.48, xref: 'x', yref: 'paper',
        text: `now<br>${nowTimeStr}`, showarrow: false,
        font: { size: 10, color: '#fdfdfd' },
        align: 'center'
      });

      const layout = {
        paper_bgcolor: '#0a0a0a',
        plot_bgcolor: '#0a0a0a',
        margin: { t: 24, r: 12, l: 36, b: 115 },
        hovermode: 'closest',
        xaxis: {
          range: [0, 24],
          dtick: 3,
          tickvals: [0, 3, 6, 9, 12, 15, 18, 21, 24],
          ticktext: ['12a', '3a', '6a', '9a', '12p', '3p', '6p', '9p', '12a'],
          gridcolor: 'rgba(80,100,130,0.22)',
          tickfont: { color: '#c8c8c8', size: 10 },
          ticklen: 3,
          tickcolor: 'rgba(160,190,220,0.2)'
        },
        yaxis: {
          range: [0, 110],
          gridcolor: 'rgba(80,100,130,0.22)',
          tickfont: { color: '#c8c8c8', size: 10 },
          ticklen: 3,
          title: '',
          showticklabels: true,
          dtick: 25
        },
        shapes,
        annotations,
        showlegend: false
      };

      Plotly.react('modal-mini-chart', traces, layout, {
        displayModeBar: false,
        responsive: true
      });
    }

    // ============================================================
    // Adjust Button Styling (glo-designer style)
    // ============================================================

    function styleAdjustButtons(areaId) {
      const status = areaStatus[areaId] || {};
      if (!cachedConfig || !cachedSunTimes) return;

      // Use the area's specific preset config
      const presetName = status.preset_name;
      const cfg = (presetName && cachedPresets[presetName])
        ? { ...cachedConfig, ...cachedPresets[presetName] }
        : cachedConfig;
      const state = {
        brightness_mid: status.brightness_mid ?? null,
        color_mid: status.color_mid ?? null,
        color_override: status.color_override ?? null,
        frozen_at: status.frozen_at ?? null
      };

      // Get current hour
      let currentHour;
      if (status.frozen && status.frozen_at != null) {
        currentHour = status.frozen_at;
      } else {
        const now = new Date();
        currentHour = now.getHours() + now.getMinutes() / 60;
      }

      const currentBri = calcMiniBrightness(currentHour, cfg, state, currentHour) * 100;
      const currentCCT = calcMiniColor(currentHour, cfg, state, cachedSunTimes, currentHour);

      // Calculate step preview values
      const bMin = cfg.min_brightness;
      const bMax = cfg.max_brightness;
      const cMin = cfg.min_color_temp;
      const cMax = cfg.max_color_temp;
      const steps = cfg.step_increments ?? cfg.max_dim_steps ?? 10;
      const briSteps = cfg.brightness_increments ?? cfg.max_dim_steps ?? 10;
      const colorSteps = cfg.color_increments ?? cfg.max_dim_steps ?? 10;

      const briStep = (bMax - bMin) / steps;
      const briOnlyStep = (bMax - bMin) / briSteps;
      const cctStep = (cMax - cMin) / steps;
      const cctOnlyStep = (cMax - cMin) / colorSteps;

      // Step up/down preview
      const stepUpBri = Math.min(bMax, currentBri + briStep);
      const stepDownBri = Math.max(bMin, currentBri - briStep);
      const stepUpCCT = Math.min(cMax, currentCCT + cctStep);
      const stepDownCCT = Math.max(cMin, currentCCT - cctStep);

      // Brightness only preview
      const briUpVal = Math.min(bMax, currentBri + briOnlyStep);
      const briDownVal = Math.max(bMin, currentBri - briOnlyStep);

      // Color only preview
      const colorUpVal = Math.min(cMax, currentCCT + cctOnlyStep);
      const colorDownVal = Math.max(cMin, currentCCT - cctOnlyStep);

      // Helper to style a button
      function styleBtn(btn, targetBri, targetColor, mode) {
        if (!btn) return;

        // Brightness fill (for brightness and combo modes)
        if ((mode === 'brightness' || mode === 'combo') && Number.isFinite(targetBri)) {
          const frac = Math.max(0, Math.min(1, targetBri / 100));
          btn.style.setProperty('--btn-fill', frac.toFixed(3));
          btn.style.setProperty('--btn-fill-opacity', frac > 0 ? '0.55' : '0');
        } else {
          btn.style.removeProperty('--btn-fill');
          btn.style.removeProperty('--btn-fill-opacity');
        }

        // Color background (for color and combo modes)
        if ((mode === 'color' || mode === 'combo') && Number.isFinite(targetColor)) {
          let color = cctToRGB(targetColor);
          if (mode === 'combo' && Number.isFinite(targetBri)) {
            color = tintColorByBrightness(color, targetBri);
          }
          btn.style.setProperty('--btn-bg', color);
          btn.style.setProperty('--btn-text', readableTextColor(color));
        } else {
          btn.style.removeProperty('--btn-bg');
          btn.style.removeProperty('--btn-text');
        }
      }

      // Get button elements
      const stepUp = document.getElementById('btn-step-up');
      const stepDown = document.getElementById('btn-step-down');
      const brightUp = document.getElementById('btn-bright-up');
      const brightDown = document.getElementById('btn-bright-down');
      const colorUp = document.getElementById('btn-color-up');
      const colorDown = document.getElementById('btn-color-down');

      // Style buttons
      styleBtn(stepUp, stepUpBri, stepUpCCT, 'combo');
      styleBtn(stepDown, stepDownBri, stepDownCCT, 'combo');
      styleBtn(brightUp, briUpVal, null, 'brightness');
      styleBtn(brightDown, briDownVal, null, 'brightness');
      styleBtn(colorUp, null, colorUpVal, 'color');
      styleBtn(colorDown, null, colorDownVal, 'color');
    }

    // ============================================================
    // Page Logic
    // ============================================================

    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      await loadPreferences();
      loadData();
      setupEventListeners();
    });

    async function loadPreferences() {
      try {
        const configRes = await fetch('./api/config');

        if (configRes.ok) {
          cachedConfig = await configRes.json();
          const prefs = cachedConfig.areas_ui || {};
          sortMode = prefs.sort_mode || 'onoff';
          groupMode = prefs.group_mode || 'zone';

          // Compute sun times client-side from config lat/lon
          const lat = cachedConfig.latitude || 35.0;
          const lon = cachedConfig.longitude || -78.6;
          cachedSunTimes = getSunTimes(lat, lon);
        }
      } catch (err) {
        console.error('Error loading preferences:', err);
      }
    }

    async function savePreferences() {
      try {
        await fetch('./api/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            areas_ui: {
              sort_mode: sortMode,
              group_mode: groupMode
            }
          })
        });
      } catch (err) {
        console.error('Error saving preferences:', err);
      }
    }

    function getHomeRefreshInterval() {
      if (cachedConfig) {
        const val = cachedConfig.home_refresh_interval;
        if (val && val >= 2 && val <= 60) return val;
      }
      return 10;
    }

    function updateHomeTimers() {
      // Update all timer spans in-place without re-rendering (no API calls)
      document.querySelectorAll('[data-area-timer]').forEach(el => {
        const areaId = el.getAttribute('data-area-timer');
        const status = areaStatus[areaId] || {};
        const hasMotion = status.motion_expires_at && status.motion_expires_at !== 'forever';
        const isBoosted = status.boosted || false;
        const isMotionCoupled = status.is_motion_coupled || false;
        const warnClass = status.motion_warning_active ? ' timer-warning' : '';

        if (hasMotion && isBoosted && isMotionCoupled) {
          const remaining = formatCountdown(status.motion_expires_at);
          el.innerHTML = remaining
            ? `<span class="timer-motion${warnClass}">M+${status.boost_brightness}% ${remaining}</span>`
            : '';
          return;
        }

        const parts = [];
        if (hasMotion) {
          const remaining = formatCountdown(status.motion_expires_at);
          if (remaining) parts.push(`<span class="timer-motion${warnClass}">M ${remaining}</span>`);
        }
        if (isBoosted && status.boost_brightness && !isMotionCoupled) {
          let text = `B+${status.boost_brightness}%`;
          if (status.boost_expires_at !== 'forever' && status.boost_expires_at) {
            const remaining = formatCountdown(status.boost_expires_at);
            if (remaining) text += ` ${remaining}`;
          }
          parts.push(`<span class="timer-boost">${text}</span>`);
        }
        el.innerHTML = parts.join(' ');
      });
    }

    function startHomeRefresh() {
      stopHomeRefresh();
      const interval = getHomeRefreshInterval() * 1000;
      homeRefreshTimer = setInterval(async () => {
        try {
          const [res, zsRes] = await Promise.all([
            fetch('./api/area-status'),
            fetch('./api/zone-states')
          ]);
          if (res.ok) {
            areaStatus = await res.json();
          }
          if (zsRes.ok) {
            const zs = await zsRes.json();
            zoneStates = zs.zone_states || {};
          }
          renderAreas();
        } catch (err) {
          console.error('Error refreshing home page:', err);
        }
      }, interval);
      // 1s tick for timer countdowns (no API calls)
      homeTickTimer = setInterval(updateHomeTimers, 1000);
    }

    function stopHomeRefresh() {
      if (homeRefreshTimer) { clearInterval(homeRefreshTimer); homeRefreshTimer = null; }
      if (homeTickTimer) { clearInterval(homeTickTimer); homeTickTimer = null; }
    }

    async function loadData() {
      const container = document.getElementById('areas-container');
      container.innerHTML = '<div class="loading">Loading areas...</div>';

      try {
        const [areasRes, statusRes, zoneStatesRes, presetsRes] = await Promise.all([
          fetch('./api/areas'),
          fetch('./api/area-status'),
          fetch('./api/zone-states'),
          fetch('./api/circadian-presets')
        ]);

        if (areasRes.ok) {
          areas = await areasRes.json();
        }

        if (statusRes.ok) {
          areaStatus = await statusRes.json();
        }

        if (zoneStatesRes.ok) {
          const zs = await zoneStatesRes.json();
          zoneStates = zs.zone_states || {};
        }

        if (presetsRes.ok) {
          const p = await presetsRes.json();
          cachedPresets = p.presets || {};
        }

        renderAreas();
        updateSunDisplay();
        startHomeRefresh();
      } catch (err) {
        console.error('Error loading data:', err);
        container.innerHTML = '<div class="loading">Error loading data</div>';
      }
    }

    // ============================================================
    // Moon position calculation (simplified)
    // ============================================================
    function getMoonTimes(lat, lon) {
      // Approximate moon position using simplified algorithm
      const now = new Date();
      const JD = now.getTime() / 86400000 + 2440587.5;
      const T = (JD - 2451545.0) / 36525;

      // Moon's mean longitude
      const L0 = (218.3165 + 481267.8813 * T) % 360;
      // Moon's mean anomaly
      const M = (134.9634 + 477198.8676 * T) % 360;
      // Moon's mean elongation
      const D = (297.8502 + 445267.1115 * T) % 360;

      const r = Math.PI / 180;
      // Moon's ecliptic longitude (simplified)
      const lng = L0 + 6.289 * Math.sin(M * r) + 1.274 * Math.sin((2 * D - M) * r) +
                  0.658 * Math.sin(2 * D * r) + 0.214 * Math.sin(2 * M * r);
      // Moon's ecliptic latitude (simplified)
      const B = 5.128 * Math.sin((93.272 + 483202.0175 * T) * r);
      // Declination (simplified)
      const eps = 23.439 - 0.00000036 * (JD - 2451545.0);
      const dec = Math.asin(Math.sin(B * r) * Math.cos(eps * r) +
                  Math.cos(B * r) * Math.sin(eps * r) * Math.sin(lng * r));
      // Right ascension
      const ra = Math.atan2(
        Math.sin(lng * r) * Math.cos(eps * r) - Math.tan(B * r) * Math.sin(eps * r),
        Math.cos(lng * r)
      );

      // Hour angle at rise/set (moon apparent radius ~0.27°, refraction ~0.57°)
      const latR = lat * r;
      const cosH = (Math.sin(-0.83 * r) - Math.sin(latR) * Math.sin(dec)) /
                   (Math.cos(latR) * Math.cos(dec));

      if (cosH < -1 || cosH > 1) {
        // Moon always above or below horizon
        return { moonrise: null, moonset: null, phase: getMoonPhase(JD) };
      }

      const H = Math.acos(cosH) / r / 15; // in hours
      // LST at Greenwich midnight
      const GMST = (280.46061837 + 360.98564736629 * (JD - 2451545.0)) % 360;
      const LST = (GMST + lon) % 360;
      const raH = (ra / r) / 15; // RA in hours
      const transit = ((raH - LST / 15 + 24) % 24);
      const tz = -now.getTimezoneOffset() / 60;
      const transitLocal = (transit + tz + 24) % 24;

      return {
        moonrise: (transitLocal - H + 24) % 24,
        moonset: (transitLocal + H + 24) % 24,
        phase: getMoonPhase(JD)
      };
    }

    function getMoonPhase(JD) {
      // Returns 0-1: 0=new, 0.25=first quarter, 0.5=full, 0.75=last quarter
      const synodicMonth = 29.53059;
      const knownNew = 2451550.1; // Jan 6, 2000 new moon
      const daysSince = JD - knownNew;
      return ((daysSince % synodicMonth) + synodicMonth) % synodicMonth / synodicMonth;
    }

    function getMoonPhaseSVG(phase, cx, cy, radius) {
      // Draw a moon icon showing the current phase
      // phase: 0=new, 0.25=first quarter, 0.5=full, 0.75=last quarter
      const r = radius;
      // Illumination curve: how much of the face is lit
      // k goes from 0 (new) to 1 (full) and back
      const k = phase <= 0.5 ? phase * 2 : (1 - phase) * 2;
      // Which side is lit
      const waxing = phase <= 0.5;

      // Moon body (dark side)
      let svg = `<circle cx="${cx}" cy="${cy}" r="${r}" fill="#334" stroke="#8899bb" stroke-width="0.8"/>`;

      if (k < 0.01) {
        // New moon - just the dark circle with a faint outline
        return svg;
      }

      if (k > 0.99) {
        // Full moon - fully lit
        svg = `<circle cx="${cx}" cy="${cy}" r="${r}" fill="#eee8cc" stroke="#ffd050" stroke-width="0.8"/>`;
        // Craters
        svg += `<circle cx="${cx - r * 0.3}" cy="${cy - r * 0.2}" r="${r * 0.12}" fill="#ddd0aa" stroke="none"/>`;
        svg += `<circle cx="${cx + r * 0.2}" cy="${cy + r * 0.25}" r="${r * 0.09}" fill="#ddd0aa" stroke="none"/>`;
        return svg;
      }

      // Partial phase: draw lit portion using a path
      // The terminator is an ellipse squished by illumination
      const bulge = (2 * k - 1) * r; // ranges from -r to +r
      const litSide = waxing ? 1 : -1; // 1 = right lit, -1 = left lit

      // Build the lit area as a path:
      // Arc from top to bottom on the lit edge, then terminator curve back
      const top = cy - r;
      const bot = cy + r;

      // Lit edge arc (semicircle on the lit side)
      const litArcSweep = litSide > 0 ? 1 : 0;
      // Terminator curve (elliptical)
      const termSweep = bulge * litSide >= 0 ? 1 : 0;

      svg += `<path d="M ${cx} ${top} A ${r} ${r} 0 0 ${litArcSweep} ${cx} ${bot} A ${Math.abs(bulge) || 0.1} ${r} 0 0 ${termSweep} ${cx} ${top} Z" fill="#eee8cc" stroke="none"/>`;
      // Crater on lit part
      const craterX = cx + litSide * r * 0.2 * k;
      if (k > 0.3) {
        svg += `<circle cx="${craterX}" cy="${cy}" r="${r * 0.1}" fill="#ddd0aa" stroke="none"/>`;
      }

      return svg;
    }

    // ============================================================
    // Solar Display Renderer
    // ============================================================
    function updateSunDisplay() {
      if (!cachedSunTimes || !cachedConfig) return;
      const { sunrise, sunset } = cachedSunTimes;
      const lat = cachedConfig.latitude || 35.0;
      const lon = cachedConfig.longitude || -78.6;
      const moon = getMoonTimes(lat, lon);

      const container = document.getElementById('solar-display');
      if (!container) return;

      const now = new Date();
      const nowHour = now.getHours() + now.getMinutes() / 60;
      const dayLength = ((sunset - sunrise) + 24) % 24 || 12;
      const elapsed = ((nowHour - sunrise) + 24) % 24;
      const isDaytime = elapsed < dayLength;

      // Update text labels
      const riseLabel = document.getElementById('sunrise-label');
      const setLabel = document.getElementById('sunset-label');
      if (riseLabel) riseLabel.textContent = '↑ ' + formatHourLabel(sunrise);
      if (setLabel) setLabel.textContent = '↓ ' + formatHourLabel(sunset);

      // Build contextual icon
      const icon = document.getElementById('solar-icon');
      if (!icon) return;
      const cx = 14, cy = 14, r = 7;
      let svg = '';

      // How close to sunrise/sunset? (within ~40 min)
      const nearRise = elapsed < 0.67;                         // just after sunrise
      const beforeRise = ((sunrise - nowHour + 24) % 24) < 0.67; // just before sunrise
      const nearSet = (dayLength - elapsed) < 0.67 && isDaytime; // just before sunset
      const justAfterSet = !isDaytime && ((nowHour - sunset + 24) % 24) < 0.67;

      if (nearRise || beforeRise || nearSet || justAfterSet) {
        // Partial sun on horizon
        const horizY = cy + 2;
        const sunColor = (nearRise || beforeRise) ? '#f0a040' : '#e07030';
        // Horizon line
        svg += `<line x1="${cx - 11}" y1="${horizY}" x2="${cx + 11}" y2="${horizY}" stroke="rgba(255,255,255,0.2)" stroke-width="1"/>`;
        // Half sun peeking above horizon
        svg += `<clipPath id="above-hz"><rect x="0" y="0" width="28" height="${horizY}"/></clipPath>`;
        // Glow
        svg += `<circle cx="${cx}" cy="${horizY}" r="${r + 4}" fill="${sunColor}" opacity="0.15"/>`;
        // Sun body clipped to above horizon
        svg += `<circle cx="${cx}" cy="${horizY}" r="${r}" fill="${sunColor}" clip-path="url(#above-hz)"/>`;
        // Rays (above horizon only)
        for (let i = 0; i < 5; i++) {
          const a = (180 + i * 36) * Math.PI / 180; // 180° to 324° (upper semicircle)
          svg += `<line x1="${cx + (r + 2) * Math.cos(a)}" y1="${horizY + (r + 2) * Math.sin(a)}" x2="${cx + (r + 5) * Math.cos(a)}" y2="${horizY + (r + 5) * Math.sin(a)}" stroke="${sunColor}" stroke-width="1.5" stroke-linecap="round" opacity="0.5"/>`;
        }
        // Arrow indicating rise or set
        if (nearRise || beforeRise) {
          svg += `<path d="M ${cx} ${cy - 10} l -3 3 h 6 z" fill="${sunColor}" opacity="0.7"/>`;
        } else {
          svg += `<path d="M ${cx} ${horizY + 6} l -3 -3 h 6 z" fill="${sunColor}" opacity="0.7"/>`;
        }
      } else if (isDaytime) {
        // Full sun
        svg += `<circle cx="${cx}" cy="${cy}" r="${r + 5}" fill="#ffd050" opacity="0.12"/>`;
        svg += `<circle cx="${cx}" cy="${cy}" r="${r}" fill="#ffd050"/>`;
        for (let i = 0; i < 8; i++) {
          const a = i * 45 * Math.PI / 180;
          svg += `<line x1="${cx + (r + 2) * Math.cos(a)}" y1="${cy + (r + 2) * Math.sin(a)}" x2="${cx + (r + 5) * Math.cos(a)}" y2="${cy + (r + 5) * Math.sin(a)}" stroke="#ffd050" stroke-width="1.5" stroke-linecap="round" opacity="0.5"/>`;
        }
      } else {
        // Night — show moon with phase
        svg += `<circle cx="${cx}" cy="${cy}" r="${r + 4}" fill="#8899bb" opacity="0.08"/>`;
        svg += getMoonPhaseSVG(moon.phase, cx, cy, r);
      }

      icon.innerHTML = svg;
    }

    // Collapsed zone state (persisted in localStorage)
    function getCollapsedZones() {
      try {
        return JSON.parse(localStorage.getItem('areas_collapsed_zones') || '{}');
      } catch { return {}; }
    }

    function setZoneCollapsed(zoneName, collapsed) {
      const state = getCollapsedZones();
      state[zoneName] = collapsed;
      localStorage.setItem('areas_collapsed_zones', JSON.stringify(state));
    }

    function toggleZone(zoneName) {
      const state = getCollapsedZones();
      const isCollapsed = !state[zoneName];
      setZoneCollapsed(zoneName, isCollapsed);

      const header = document.querySelector(`[data-zone="${zoneName}"]`);
      const table = document.querySelector(`[data-zone-table="${zoneName}"]`);
      if (header && table) {
        header.classList.toggle('collapsed', isCollapsed);
        table.classList.toggle('hidden', isCollapsed);
      }
    }

    function zoneReset(zoneName) {
      // Find the first area_id in this zone
      for (const area of areas) {
        const status = areaStatus[area.area_id] || {};
        if (status.zone_name === zoneName) {
          rowAction(area.area_id, 'glo_reset');
          return;
        }
      }
    }

    function toggleRhythmDropdown(el) {
      const display = el.closest('.zone-rhythm-display');
      if (!display) return;
      const dropdown = display.querySelector('.zone-rhythm-dropdown');
      // Close other rhythm dropdowns
      document.querySelectorAll('.zone-rhythm-dropdown.visible').forEach(d => {
        if (d !== dropdown) d.classList.remove('visible');
      });
      dropdown.classList.toggle('visible');
    }

    function selectRhythm(item) {
      event.stopPropagation();
      const zoneName = item.dataset.zone;
      const preset = item.dataset.preset;
      item.closest('.zone-rhythm-dropdown').classList.remove('visible');

      if (preset === '__new__') {
        const newName = prompt('New rhythm name:');
        if (newName && newName.trim()) {
          createAndAssignRhythm(zoneName, newName.trim());
        }
      } else {
        changeZoneRhythm(zoneName, preset);
      }
    }

    async function changeZoneRhythm(zoneName, presetName) {
      try {
        await fetch(`./api/glozones/${encodeURIComponent(zoneName)}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ preset: presetName })
        });
        await loadData();
      } catch (err) {
        console.error('Error changing rhythm:', err);
      }
    }

    async function createAndAssignRhythm(zoneName, rhythmName) {
      try {
        // Create new preset (copy from current zone's preset as base)
        const zs = zoneStates[zoneName];
        const sourcePreset = zs?.preset;
        const baseConfig = sourcePreset && cachedPresets[sourcePreset]
          ? { ...cachedPresets[sourcePreset] }
          : {};

        await fetch('./api/circadian-presets', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: rhythmName, settings: baseConfig })
        });

        // Assign it to the zone
        await changeZoneRhythm(zoneName, rhythmName);
      } catch (err) {
        console.error('Error creating rhythm:', err);
      }
    }

    /**
     * Compute pure rhythm brightness/kelvin at current hour for a specific preset.
     * Uses the preset's own curve config (from cachedPresets) merged with global settings.
     * Returns { brightness, kelvin } or null if config not available.
     */
    function getPureRhythmValues(presetName) {
      if (!cachedSunTimes) return null;

      // Build config: start with cachedConfig (which has the effective first preset's
      // settings flattened by /api/config), then overlay the specific preset's settings.
      // Once the server-side glozone.py fix propagates complete preset configs via
      // /api/circadian-presets, the overlay will contain all keys directly.
      let cfg;
      if (presetName && cachedPresets[presetName]) {
        cfg = { ...cachedConfig, ...cachedPresets[presetName] };
      } else if (cachedConfig) {
        cfg = cachedConfig;
      } else {
        return null;
      }

      const now = new Date();
      const currentHour = now.getHours() + now.getMinutes() / 60;
      const emptyState = { brightness_mid: null, color_mid: null, color_override: null, frozen_at: null };
      const brightness = calcMiniBrightness(currentHour, cfg, emptyState, currentHour) * 100;
      const kelvin = calcMiniColor(currentHour, cfg, emptyState, cachedSunTimes, currentHour);
      return { brightness, kelvin };
    }

    function renderAreas() {
      const container = document.getElementById('areas-container');

      // Merge area data with status
      const mergedAreas = areas.map(area => {
        const status = areaStatus[area.area_id] || {};
        return {
          ...area,
          is_on: status.is_on || false,
          brightness: status.brightness || 0,
          kelvin: status.kelvin || 4000,
          frozen: status.frozen || false,
          boosted: status.boosted || false,
          boost_brightness: status.boost_brightness || null,
          boost_expires_at: status.boost_expires_at || null,
          boost_started_from_off: status.boost_started_from_off || false,
          is_motion_coupled: status.is_motion_coupled || false,
          motion_expires_at: status.motion_expires_at || null,
          motion_warning_active: status.motion_warning_active || false,
          zone_name: status.zone_name || null,
          brightness_mid: status.brightness_mid ?? null,
          color_mid: status.color_mid ?? null,
          color_override: status.color_override ?? null,
          frozen_at: status.frozen_at ?? null
        };
      });

      // Sort areas within each zone group
      const sortAreas = (list) => [...list].sort((a, b) => {
        switch (sortMode) {
          case 'onoff': {
            // On areas first, then alphabetic within each group
            if (a.is_on !== b.is_on) return a.is_on ? -1 : 1;
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
          }
          case 'alpha': {
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
          }
          case 'rhythm': {
            // Out of sync first, then on/off, then alphabetic
            const aMismatch = isAreaMismatched(a);
            const bMismatch = isAreaMismatched(b);
            if (aMismatch !== bMismatch) return aMismatch ? -1 : 1;
            if (a.is_on !== b.is_on) return a.is_on ? -1 : 1;
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
          }
          default:
            return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        }
      });

      function isAreaMismatched(area) {
        if (!area.zone_name || !zoneStates[area.zone_name]) return false;
        const rs = zoneStates[area.zone_name].runtime_state || {};
        const tol = 0.1;
        const differs = (a, b) => {
          if (a == null && b == null) return false;
          if (a == null || b == null) return true;
          return Math.abs(a - b) >= tol;
        };
        return differs(area.brightness_mid, rs.brightness_mid) ||
               differs(area.color_mid, rs.color_mid) ||
               differs(area.frozen_at, rs.frozen_at) ||
               area.color_override != null;
      }

      const filtered = mergedAreas;

      // Group by zone
      const zoneGroups = {};
      const unassigned = [];
      for (const area of filtered) {
        if (area.zone_name) {
          if (!zoneGroups[area.zone_name]) zoneGroups[area.zone_name] = [];
          zoneGroups[area.zone_name].push(area);
        } else {
          unassigned.push(area);
        }
      }

      // Sort zone names, put Unassigned at end
      const zoneNames = Object.keys(zoneGroups).sort();

      // Collapsed state
      const collapsedState = getCollapsedZones();

      // Sort dropdown HTML
      const sortOptions = `
        <option value="onoff" ${sortMode === 'onoff' ? 'selected' : ''}>On / Off</option>
        <option value="alpha" ${sortMode === 'alpha' ? 'selected' : ''}>Alphabetic</option>
        <option value="rhythm" ${sortMode === 'rhythm' ? 'selected' : ''}>In Rhythm</option>
      `;

      // Group dropdown HTML
      const groupOptions = `
        <option value="zone" ${groupMode === 'zone' ? 'selected' : ''}>Glo Zone</option>
        <option value="onoff" ${groupMode === 'onoff' ? 'selected' : ''}>On / Off</option>
      `;

      // Chevron icon
      const chevronIcon = `<svg class="zone-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>`;

      // Reset icon (double-down chevron)
      const zoneResetIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="6 4 12 10 18 4"/><polyline points="6 10 12 16 18 10"/></svg>`;

      // Build zone groups HTML
      let html = `
        <div style="display: flex; align-items: center; gap: 16px; margin-bottom: 16px; flex-wrap: wrap;">
          <span style="font-size: 0.85rem; color: var(--muted);">Group:</span>
          <select class="header-filter" id="group-dropdown" style="width: auto; padding: 6px 12px;">${groupOptions}</select>
          <span style="font-size: 0.85rem; color: var(--muted);">Sort:</span>
          <select class="header-filter" id="sort-dropdown" style="width: auto; padding: 6px 12px;">${sortOptions}</select>
          <span style="flex: 1;"></span>
          <a href="./zones" style="font-size: 0.85rem; color: var(--muted); text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Edit Glo Zones</a>
          <a href="#" id="refresh-link" style="font-size: 0.85rem; color: var(--muted); text-decoration: none;" onmouseover="this.style.textDecoration='underline'" onmouseout="this.style.textDecoration='none'">Refresh</a>
        </div>
      `;

      const renderZoneGroup = (zoneName, areasInZone) => {
        const isCollapsed = collapsedState[zoneName] || false;
        const sorted = sortAreas(areasInZone);

        // Use zone's own brightness/kelvin from zoneStates
        let zoneHeaderStyle = '';
        let zoneTextColor = 'var(--text)';
        let zoneLightingInfo = '';
        let zoneMismatchDot = '';
        let zoneRhythmLink = '';

        const zs = zoneStates[zoneName];
        if (zs) {
          const zoneBri = zs.brightness;
          const zoneKelvin = zs.kelvin;
          const cctColor = cctToRGB(zoneKelvin);
          const tintedColor = tintColorByBrightness(cctColor, zoneBri);
          zoneTextColor = readableTextColor(tintedColor);
          zoneHeaderStyle = `background: ${tintedColor}; color: ${zoneTextColor}; --header-fill: ${zoneBri / 100};`;
          zoneLightingInfo = `<span style="font-size: 0.8rem; opacity: 0.85;">${Math.round(zoneBri)}% · ${Math.round(zoneKelvin)}K</span>`;

          // Rhythm dropdown + wake/bed times combined pill
          if (zs.preset) {
            const presetNames = Object.keys(cachedPresets).filter(p => p !== zs.preset);
            const dropdownItems =
              `<a href="./glo/${encodeURIComponent(zs.preset)}" class="zone-rhythm-dropdown-item" onclick="event.stopPropagation();">Edit ${zs.preset}</a>` +
              presetNames.map(p =>
                `<div class="zone-rhythm-dropdown-item" data-zone="${zoneName}" data-preset="${p}" onclick="selectRhythm(this)">${p}</div>`
              ).join('') +
              `<div class="zone-rhythm-dropdown-item" data-zone="${zoneName}" data-preset="__new__" onclick="selectRhythm(this)">+ New Rhythm...</div>`;

            // Wake/bed times inline (same size as rhythm label/btn)
            let wakeBedSpan = '';
            const pr = cachedPresets[zs.preset];
            if (pr && pr.wake_time != null && pr.bed_time != null) {
              const alarmIcon = `<svg style="width:12px;height:12px;vertical-align:-1px;margin-right:2px;" viewBox="0 0 24 24" fill="none" stroke="#5cb3ff" stroke-width="2"><circle cx="12" cy="13" r="7"/><line x1="12" y1="10" x2="12" y2="13"/><line x1="12" y1="13" x2="14.5" y2="13"/><line x1="1" y1="8" x2="5" y2="4"/><line x1="23" y1="8" x2="19" y2="4"/></svg>`;
              const bedIcon = `<svg style="width:12px;height:12px;vertical-align:-1px;margin-right:2px;" viewBox="0 0 24 24" fill="none" stroke="#ffe080" stroke-width="2"><path d="M3 21V7h18v14"/><path d="M3 11h18"/><path d="M7 11V8"/><rect x="7" y="11" width="14" height="4" rx="1"/></svg>`;
              wakeBedSpan = `<span style="margin-left: 6px; white-space: nowrap; font-size: 0.8rem;"><span style="color: #5cb3ff;">${alarmIcon}${formatHourLabel(pr.wake_time)}</span> <span style="opacity: 0.5;">·</span> <span style="color: #ffe080;">${bedIcon}${formatHourLabel(pr.bed_time)}</span></span>`;
            }

            zoneRhythmLink = `
              <div class="zone-rhythm-display" style="background: rgba(0,0,0,0.45); border-radius: 6px; padding: 2px 10px; gap: 6px; cursor: pointer;" onclick="event.stopPropagation(); toggleRhythmDropdown(this);">
                <span class="zone-rhythm-label" style="color: ${zoneTextColor};">Rhythm:</span>
                <span class="zone-rhythm-btn" style="color: ${zoneTextColor};">${zs.preset}</span>
                <div class="zone-rhythm-dropdown">${dropdownItems}</div>
                ${wakeBedSpan}
              </div>`;
          }

          // Red dot: zone has been stepped or frozen away from pure rhythm
          const rs = zs.runtime_state;
          if (rs && (rs.brightness_mid != null || rs.color_mid != null || rs.frozen_at != null)) {
            zoneMismatchDot = `<span class="mismatch-dot-zone" style="box-shadow: 0 0 0 1.5px ${zoneTextColor};"></span>`;
          }
        }

        const escapedZoneName = zoneName.replace(/'/g, "\\'");

        return `
          <div class="zone-group">
            <div class="zone-header ${isCollapsed ? 'collapsed' : ''}" data-zone="${zoneName}" onclick="toggleZone('${escapedZoneName}')" style="${zoneHeaderStyle}">
              ${zoneMismatchDot}
              ${chevronIcon}
              <span style="font-size: 0.8rem; opacity: 0.6; color: ${zoneTextColor};">Glo zone:</span>
              <span class="zone-name" style="color: ${zoneTextColor};">${zoneName}</span>
              ${zoneRhythmLink}
              <span style="flex: 1;"></span>
              ${zoneLightingInfo}
              <button class="zone-reset-btn" onclick="event.stopPropagation(); zoneReset('${escapedZoneName}')" title="Reset Glo Zone: reset all areas in Glo Zone to rhythm">${zoneResetIcon}</button>
            </div>
            <div class="zone-content ${isCollapsed ? 'hidden' : ''}" data-zone-table="${zoneName}">
              ${sorted.map(area => renderAreaRow(area)).join('')}
            </div>
          </div>
        `;
      };

      if (groupMode === 'onoff') {
        // Group by on/off first, then by zone within each
        const onAreas = filtered.filter(a => a.is_on);
        const offAreas = filtered.filter(a => !a.is_on);

        const renderOnOffSection = (label, sectionAreas, icon) => {
          if (sectionAreas.length === 0) return '';
          // Sub-group by zone
          const subGroups = {};
          const subUnassigned = [];
          for (const area of sectionAreas) {
            if (area.zone_name) {
              if (!subGroups[area.zone_name]) subGroups[area.zone_name] = [];
              subGroups[area.zone_name].push(area);
            } else {
              subUnassigned.push(area);
            }
          }
          const subNames = Object.keys(subGroups).sort();
          let sectionHtml = `<div class="onoff-section-header">${icon} ${label} <span style="opacity: 0.5; font-weight: 400;">(${sectionAreas.length})</span></div>`;
          for (const zn of subNames) {
            sectionHtml += renderZoneGroup(zn, subGroups[zn]);
          }
          if (subUnassigned.length > 0) {
            sectionHtml += renderZoneGroup('Unassigned', subUnassigned);
          }
          return sectionHtml;
        };

        html += renderOnOffSection('On', onAreas, '●');
        html += renderOnOffSection('Off', offAreas, '○');
      } else {
        // Default: group by zone
        for (const zoneName of zoneNames) {
          html += renderZoneGroup(zoneName, zoneGroups[zoneName]);
        }

        // Render unassigned areas (no zone) at the end
        if (unassigned.length > 0) {
          html += renderZoneGroup('Unassigned', unassigned);
        }
      }

      // Handle empty state
      if (filtered.length === 0) {
        html = `
          <div style="text-align: center; padding: 48px; color: var(--muted);">
            ${mergedAreas.length > 0 ? 'No areas match the current filter.' : 'No areas found in Home Assistant.'}
          </div>
        `;
      }

      container.innerHTML = html;
    }

    function renderAreaRow(area) {
      const style = getRowStyle(area);
      const lightingInfo = getLightingInfo(area);
      const timerInfo = getRowTimerInfo(area);
      const { leftControls, rightControls } = getRowControls(area);

      // Red dot: area's state differs from zone's state (stepped or frozen independently)
      let mismatchDot = '';
      if (area.zone_name && zoneStates[area.zone_name]) {
        const rs = zoneStates[area.zone_name].runtime_state || {};
        const tol = 0.1;  // ~6 minutes, matches server SYNC_TOLERANCE
        const differs = (a, b) => {
          if (a == null && b == null) return false;
          if (a == null || b == null) return true;
          return Math.abs(a - b) >= tol;
        };
        if (differs(area.brightness_mid, rs.brightness_mid) ||
            differs(area.color_mid, rs.color_mid) ||
            differs(area.frozen_at, rs.frozen_at) ||
            area.color_override != null) {
          mismatchDot = `<span class="mismatch-dot-area" style="box-shadow: 0 0 0 1.5px ${style.textColor};"></span>`;
        }
      }

      return `
        <div class="area-row" style="--row-bg: ${style.bg}; --row-text: ${style.textColor}; --row-fill: ${style.fill.toFixed(3)};" onclick="openAreaModal('${area.area_id}')">
          ${mismatchDot}
          ${leftControls}
          <span class="area-row-name">${area.name}</span>
          ${timerInfo}
          <span class="area-row-lighting">${lightingInfo}</span>
          ${rightControls}
        </div>
      `;
    }

    function getStatusBadge(area) {
      if (!area.is_on) {
        return '<span class="status-badge status-off">Off</span>';
      }
      if (area.frozen) {
        return '<span class="status-badge status-frozen">Frozen</span>';
      }
      return '<span class="status-badge status-on">On</span>';
    }

    function getRowTimerInfo(area) {
      const status = areaStatus[area.area_id] || {};
      const hasMotion = status.motion_expires_at && status.motion_expires_at !== 'forever';
      const isBoosted = status.boosted || false;
      const isMotionCoupled = status.is_motion_coupled || false;
      const warnClass = status.motion_warning_active ? ' timer-warning' : '';

      if (hasMotion && isBoosted && isMotionCoupled) {
        const remaining = formatCountdown(status.motion_expires_at);
        if (remaining) {
          return `<span class="area-row-timer" data-area-timer="${area.area_id}"><span class="timer-motion${warnClass}">M+${status.boost_brightness}% ${remaining}</span></span>`;
        }
      }

      const parts = [];
      if (hasMotion) {
        const remaining = formatCountdown(status.motion_expires_at);
        if (remaining) {
          parts.push(`<span class="timer-motion${warnClass}">M ${remaining}</span>`);
        }
      }
      if (isBoosted && status.boost_brightness && !isMotionCoupled) {
        let text = `B+${status.boost_brightness}%`;
        if (status.boost_expires_at === 'forever') {
          // No countdown needed
        } else if (status.boost_expires_at) {
          const remaining = formatCountdown(status.boost_expires_at);
          if (remaining) text += ` ${remaining}`;
        }
        parts.push(`<span class="timer-boost">${text}</span>`);
      }

      if (parts.length === 0) return '';
      return `<span class="area-row-timer" data-area-timer="${area.area_id}">${parts.join(' ')}</span>`;
    }

    function getLightingInfo(area) {
      // Always use backend-calculated values (accounts for area state modifiers)
      const brightness = area.brightness || 0;
      const kelvin = area.kelvin || 4000;
      return `
        <div class="lighting-info">
          <span class="brightness-value">${Math.round(brightness)}%</span>
          <span class="bullet">&bull;</span>
          <span class="kelvin-value">${Math.round(kelvin)}K</span>
        </div>
      `;
    }

    function getRowStyle(area) {
      if (!area.is_on) {
        return { bg: 'var(--card)', fill: 0, textColor: 'var(--muted)' };
      }
      const cctColor = cctToRGB(area.kelvin);
      const tintedColor = tintColorByBrightness(cctColor, area.brightness);
      const textColor = readableTextColor(tintedColor);
      const fill = area.brightness / 100;
      return { bg: tintedColor, fill, textColor };
    }

    function getRowControls(area) {
      const status = areaStatus[area.area_id] || {};
      const isCircadian = status.is_circadian || false;
      const isOn = area.is_on;
      const isFrozen = area.frozen;
      const isBoosted = area.boosted;

      // Sun icon for circadian
      const sunIconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="5"/>
        <line x1="12" y1="1" x2="12" y2="3"/>
        <line x1="12" y1="21" x2="12" y2="23"/>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
        <line x1="1" y1="12" x2="3" y2="12"/>
        <line x1="21" y1="12" x2="23" y2="12"/>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
      </svg>`;

      // Power icon
      const powerIconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M18.36 6.64a9 9 0 1 1-12.73 0M12 2v10"/>
      </svg>`;

      // Lock icon for freeze
      const lockIconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
        <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
      </svg>`;

      // Star icon for boost
      const boostIconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polygon points="12 2 15.09 8.26 22 9.27 17 14.14 18.18 21.02 12 17.77 5.82 21.02 7 14.14 2 9.27 8.91 8.26 12 2"/>
      </svg>`;

      // GloDown icon (single down chevron — pull from zone)
      const resetIconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
        <polyline points="6 9 12 15 18 9"/>
      </svg>`;

      // GloUp icon (one up arrow + two down arrows — push to zone)
      const pushIconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5">
        <polyline points="6 9 12 3 18 9"/>
        <polyline points="6 14 12 20 18 14"/>
        <polyline points="6 18 12 24 18 18"/>
      </svg>`;

      const leftControls = `
        <div class="row-controls-left">
          <button class="row-btn ${isCircadian ? 'active' : ''}" onclick="event.stopPropagation(); rowAction('${area.area_id}', 'circadian_toggle')" title="Circadian">${sunIconSvg}</button>
          <button class="row-btn ${isOn ? 'active' : ''}" onclick="event.stopPropagation(); rowAction('${area.area_id}', 'lights_toggle')" title="Power">${powerIconSvg}</button>
        </div>
      `;

      const rightControls = `
        <div class="row-controls">
          <button class="row-btn" onclick="event.stopPropagation(); rowAction('${area.area_id}', 'glo_up')" title="GloUp: push area's settings to all areas in Glo Zone">${pushIconSvg}</button>
          <button class="row-btn" onclick="event.stopPropagation(); rowAction('${area.area_id}', 'reset')" title="GloDown: pull Glo Zone light to this area">${resetIconSvg}</button>
        </div>
      `;

      return { leftControls, rightControls };
    }

    function setupEventListeners() {
      document.getElementById('areas-container').addEventListener('click', (e) => {
        if (e.target.id === 'refresh-link') { e.preventDefault(); loadData(); }
      });

      // Use event delegation for dynamically created dropdowns
      document.getElementById('areas-container').addEventListener('change', (e) => {
        if (e.target.id === 'sort-dropdown') {
          sortMode = e.target.value;
          savePreferences();
          renderAreas();
        }
        if (e.target.id === 'group-dropdown') {
          groupMode = e.target.value;
          savePreferences();
          renderAreas();
        }
      });

      // Close modal on overlay click
      document.getElementById('area-modal').addEventListener('click', (e) => {
        if (e.target.classList.contains('modal-overlay')) {
          closeModal();
        }
      });

      // Close modal on Escape key
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') {
          closeModal();
        }
      });

      // Close rhythm dropdowns when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.zone-rhythm-display')) {
          document.querySelectorAll('.zone-rhythm-dropdown.visible').forEach(d => {
            d.classList.remove('visible');
          });
        }
      });
    }

    // Modal functions
    function updateModalContent(areaId, renderChart = true) {
      const area = areas.find(a => a.area_id === areaId);
      const status = areaStatus[areaId] || {};

      if (!area) return;

      selectedArea = {
        ...area,
        is_on: status.is_on || false,
        brightness: status.brightness || 0,
        kelvin: status.kelvin || 4000,
        frozen: status.frozen || false,
        boosted: status.boosted || false,
        zone_name: status.zone_name || null,
        preset_name: status.preset_name || null,
        is_circadian: status.is_circadian || false,
        boost_brightness: status.boost_brightness || null,
        boost_expires_at: status.boost_expires_at || null,
        boost_started_from_off: status.boost_started_from_off || false,
        is_motion_coupled: status.is_motion_coupled || false,
        motion_expires_at: status.motion_expires_at || null,
        motion_warning_active: status.motion_warning_active || false
      };

      // Update modal content
      document.getElementById('modal-area-name').textContent = area.name;

      // Header area shading based on CCT and brightness
      const stateEl = document.getElementById('modal-area-state');
      if (selectedArea.is_on) {
        const cctColor = cctToRGB(selectedArea.kelvin);
        const tintedColor = tintColorByBrightness(cctColor, selectedArea.brightness);
        stateEl.style.setProperty('--state-bg', tintedColor);
        stateEl.style.setProperty('--state-fill', (selectedArea.brightness / 100).toFixed(3));
      } else {
        stateEl.style.setProperty('--state-bg', 'var(--panel)');
        stateEl.style.setProperty('--state-fill', '0');
      }

      // Values - always show CT and brightness from server-calculated values
      const valuesEl = document.getElementById('modal-values');
      const displayBri = selectedArea.brightness;
      const displayKelvin = selectedArea.kelvin;
      if (selectedArea.is_on) {
        const cctColor = cctToRGB(displayKelvin);
        const tintedColor = tintColorByBrightness(cctColor, displayBri);
        valuesEl.style.color = readableTextColor(tintedColor);
      } else {
        valuesEl.style.color = 'var(--muted)';
      }

      valuesEl.textContent = `${Math.round(displayBri)}% • ${Math.round(displayKelvin)}K`;

      // Context info (Glo zone + Rhythm)
      const zoneLinkEl = document.getElementById('modal-zone-link');
      const rhythmLinkEl = document.getElementById('modal-rhythm-link');
      if (selectedArea.zone_name) {
        zoneLinkEl.textContent = selectedArea.zone_name;
        zoneLinkEl.href = './zones';
      } else {
        zoneLinkEl.textContent = 'Unassigned';
        zoneLinkEl.href = './zones';
      }
      if (selectedArea.preset_name) {
        rhythmLinkEl.textContent = selectedArea.preset_name;
        rhythmLinkEl.href = `./glo/${encodeURIComponent(selectedArea.preset_name)}`;
      } else {
        rhythmLinkEl.textContent = '—';
        rhythmLinkEl.href = './glo';
      }

      // Timer status (motion + boost)
      updateTimerStatus();

      // Update toggle button states
      const powerBtn = document.getElementById('toggle-power');
      const circadianBtn = document.getElementById('toggle-circadian');
      const freezeBtn = document.getElementById('toggle-freeze');
      const boostBtn = document.getElementById('toggle-boost');

      if (powerBtn) {
        powerBtn.classList.toggle('active', selectedArea.is_on);
      }
      if (circadianBtn) {
        circadianBtn.classList.toggle('active', selectedArea.is_circadian);
      }
      if (freezeBtn) {
        freezeBtn.classList.toggle('active', selectedArea.frozen);
      }
      if (boostBtn) {
        boostBtn.classList.toggle('active', selectedArea.boosted);
      }

      // Render mini chart (if requested)
      if (renderChart) {
        renderMiniChartForArea(areaId);
      }
    }

    function renderMiniChartForArea(areaId) {
      const status = areaStatus[areaId] || {};
      if (!cachedConfig || !cachedSunTimes) return;

      // Use the area's specific preset config (same pattern as getPureRhythmValues)
      const presetName = status.preset_name;
      let cfg;
      if (presetName && cachedPresets[presetName]) {
        cfg = { ...cachedConfig, ...cachedPresets[presetName] };
      } else {
        cfg = cachedConfig;
      }

      const areaState = {
        brightness_mid: status.brightness_mid ?? null,
        color_mid: status.color_mid ?? null,
        color_override: status.color_override ?? null,
        frozen_at: status.frozen_at ?? null
      };

      // Current hour: use frozen_at if frozen, otherwise current time
      let currentHour;
      if (status.frozen && status.frozen_at != null) {
        currentHour = status.frozen_at;
      } else {
        const now = new Date();
        currentHour = now.getHours() + now.getMinutes() / 60;
      }

      // isActive = lights are on AND being controlled by Circadian Light
      const isActive = (status.is_on || false) && (status.is_circadian || false);

      renderMiniChart(cfg, areaState, cachedSunTimes, currentHour, isActive);
      styleAdjustButtons(areaId);
    }

    function updateTimerStatus() {
      if (!selectedArea) return;
      const timerEl = document.getElementById('modal-timer-status');
      if (!timerEl) return;
      const parts = [];

      const hasMotion = selectedArea.motion_expires_at && selectedArea.motion_expires_at !== 'forever';
      const hasBoostedMotion = selectedArea.boosted && selectedArea.is_motion_coupled;
      const warnClass = selectedArea.motion_warning_active ? ' timer-warning' : '';

      if (hasMotion && hasBoostedMotion) {
        // Motion-coupled boost: show as single combined line
        const remaining = formatCountdown(selectedArea.motion_expires_at);
        if (remaining) {
          parts.push(`<span class="timer-motion${warnClass}">Motion +${selectedArea.boost_brightness}%: ${remaining}<span class="timer-arrow">→</span>off</span>`);
        }
      } else {
        // Motion: only show timed expirations (not "forever")
        if (hasMotion) {
          const remaining = formatCountdown(selectedArea.motion_expires_at);
          if (remaining) {
            parts.push(`<span class="timer-motion${warnClass}">Motion: ${remaining}<span class="timer-arrow">→</span>off</span>`);
          }
        }

        // Boost: show amount + countdown + outcome (skip if coupled to motion, already shown above)
        if (selectedArea.boosted && selectedArea.boost_brightness) {
          let text = `+${selectedArea.boost_brightness}%`;
          if (selectedArea.boost_expires_at === 'forever') {
            text += ' · forever';
          } else if (selectedArea.boost_expires_at === 'motion') {
            // Motion-coupled boost without combined display (edge case)
            if (selectedArea.motion_expires_at) {
              const remaining = formatCountdown(selectedArea.motion_expires_at);
              if (remaining) {
                text += ` · ${remaining}<span class="timer-arrow">→</span>rhythm`;
              } else {
                text += ' · ending';
              }
            } else {
              text += ' · until motion ends';
            }
          } else if (selectedArea.boost_expires_at) {
            const remaining = formatCountdown(selectedArea.boost_expires_at);
            if (remaining) {
              const outcome = selectedArea.boost_started_from_off ? 'off' : 'rhythm';
              text += ` · ${remaining}<span class="timer-arrow">→</span>${outcome}`;
            }
          }
          parts.push(`<span class="timer-boost">Boost: ${text}</span>`);
        }
      }

      timerEl.innerHTML = parts.join('');
    }

    async function openAreaModal(areaId) {
      // Stop home refresh while modal is open
      stopHomeRefresh();

      // Fetch all data fresh before rendering modal
      try {
        const [res, zsRes, pRes] = await Promise.all([
          fetch('./api/area-status'),
          fetch('./api/zone-states'),
          fetch('./api/circadian-presets')
        ]);
        if (res.ok) {
          areaStatus = await res.json();
        }
        if (zsRes.ok) {
          const zs = await zsRes.json();
          zoneStates = zs.zone_states || {};
        }
        if (pRes.ok) {
          const p = await pRes.json();
          cachedPresets = p.presets || {};
        }
      } catch (err) {
        console.error('Error fetching modal data:', err);
      }

      updateModalContent(areaId, false);  // Update content but don't render chart yet

      // Show modal first, then render chart after it's visible
      const modal = document.getElementById('area-modal');
      modal.classList.add('visible');

      // Small delay to let modal transition complete and element get dimensions
      setTimeout(() => {
        renderMiniChartForArea(areaId);
      }, 50);

      // Start live countdown tick (1s) and single-area API refresh (1s)
      clearModalIntervals();
      modalTickInterval = setInterval(updateTimerStatus, 1000);
      modalRefreshInterval = setInterval(async () => {
        if (!selectedArea) return;
        try {
          const res = await fetch(`./api/area-status?area_id=${encodeURIComponent(selectedArea.area_id)}`);
          if (res.ok) {
            const singleStatus = await res.json();
            Object.assign(areaStatus, singleStatus);
          }
          updateModalContent(selectedArea.area_id, false);
        } catch (err) {
          console.error('Error refreshing modal:', err);
        }
      }, 1000);
    }

    function clearModalIntervals() {
      if (modalTickInterval) { clearInterval(modalTickInterval); modalTickInterval = null; }
      if (modalRefreshInterval) { clearInterval(modalRefreshInterval); modalRefreshInterval = null; }
    }

    function closeModal() {
      clearModalIntervals();
      document.getElementById('area-modal').classList.remove('visible');
      selectedArea = null;
      // Resume home page refresh
      startHomeRefresh();
    }

    function toggleCircadian() {
      if (!selectedArea) return;
      // Toggle based on current state
      const action = selectedArea.is_circadian ? 'circadian_off' : 'circadian_on';
      executeAction(action);
    }

    async function executeAction(action) {
      if (!selectedArea) return;

      const areaId = selectedArea.area_id;

      try {
        const response = await fetch('./api/area/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            area_id: areaId,
            action: action
          })
        });

        if (response.ok) {
          // Re-fetch single area status, then update modal in place
          setTimeout(async () => {
            try {
              const res = await fetch(`./api/area-status?area_id=${encodeURIComponent(areaId)}`);
              if (res.ok) {
                const singleStatus = await res.json();
                Object.assign(areaStatus, singleStatus);
              }
              // Re-render modal content without closing
              if (selectedArea && selectedArea.area_id === areaId) {
                updateModalContent(areaId);
              }
            } catch (err) {
              console.error('Error refreshing after action:', err);
            }
          }, 500);
        } else {
          const error = await response.json();
          console.error('Action failed:', error);
          alert(`Action failed: ${error.error || 'Unknown error'}`);
        }
      } catch (err) {
        console.error('Error executing action:', err);
        alert('Error executing action');
      }
    }

    async function rowAction(areaId, action) {
      // Handle circadian toggle - need to check current state
      if (action === 'circadian_toggle') {
        const status = areaStatus[areaId] || {};
        action = status.is_circadian ? 'circadian_off' : 'circadian_on';
      }

      try {
        const response = await fetch('./api/area/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            area_id: areaId,
            action: action
          })
        });

        if (response.ok) {
          // Re-fetch area status + zone states and update table
          setTimeout(async () => {
            try {
              const [statusRes, zsRes] = await Promise.all([
                fetch('./api/area-status'),
                fetch('./api/zone-states')
              ]);
              if (statusRes.ok) {
                areaStatus = await statusRes.json();
              }
              if (zsRes.ok) {
                const zs = await zsRes.json();
                zoneStates = zs.zone_states || {};
              }
              renderAreas();
              // Also update modal if it's open for this area
              if (selectedArea && selectedArea.area_id === areaId) {
                updateModalContent(areaId);
              }
            } catch (err) {
              console.error('Error refreshing after row action:', err);
            }
          }, 500);
        } else {
          const error = await response.json();
          console.error('Row action failed:', error);
        }
      } catch (err) {
        console.error('Error executing row action:', err);
      }
    }

  </script>
</body>
</html>
