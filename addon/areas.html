<!DOCTYPE html>
<html lang="en">
<head>
  <script>
    // Ensure trailing slash so ./relative links resolve correctly in HA dashboard iframes
    if (!window.location.pathname.endsWith('/')) {
      window.history.replaceState(null, '', window.location.pathname + '/' + window.location.search + window.location.hash);
    }
  </script>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Circadian Light - Home</title>
  <style>
    :root {
      --bg: #000;
      --panel: #111;
      --card: #1a1a1a;
      --accent: #feac60;
      --accent-hover: #ffc078;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --muted2: #64748b;
      --line: #334155;
      --success: #22c55e;
      --warning: #f59e0b;
      --danger: #ef4444;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    /* Navigation */
    .nav {
      background: var(--panel);
      border-bottom: 1px solid var(--line);
      padding: 0 24px;
      display: flex;
      align-items: center;
      height: 56px;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .nav-brand {
      font-weight: 600;
      font-size: 1.1rem;
      color: var(--text);
      margin-right: 16px;
      text-decoration: none;
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .nav-brand.active {
      color: var(--accent);
    }

    .nav-logo {
      width: 24px;
      height: 24px;
      flex-shrink: 0;
    }

    .nav-links {
      display: flex;
      gap: 8px;
      flex: 1;
      min-width: 0;
      overflow: hidden;
    }

    .nav-link {
      padding: 8px 10px;
      color: var(--muted);
      text-decoration: none;
      border-radius: 6px;
      font-size: 0.9rem;
      transition: all 0.2s;
    }

    .nav-link:hover {
      color: var(--text);
      background: rgba(255, 255, 255, 0.05);
    }

    .nav-link.active {
      color: var(--accent);
    }


    /* Main Content */
    .main {
      max-width: 1000px;
      margin: 0 auto;
      padding: 12px 24px 24px;
    }

    .page-header {
      margin-bottom: 24px;
    }

    .page-title {
      font-size: 1.5rem;
      font-weight: 600;
    }

    /* Areas Table */
    .areas-table {
      width: 100%;
      border-collapse: collapse;
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: 8px;
      overflow: hidden;
    }

    .areas-table th {
      text-align: left;
      padding: 12px 16px;
      background: var(--panel);
      border-bottom: 1px solid var(--line);
      font-weight: 600;
      font-size: 0.85rem;
      color: var(--muted);
      cursor: pointer;
      user-select: none;
      transition: color 0.2s;
    }

    .areas-table th:hover {
      color: var(--text);
    }

    .areas-table th.sorted {
      color: var(--accent);
    }

    .areas-table th .sort-arrow {
      margin-left: 6px;
      opacity: 0.5;
    }

    .areas-table th.sorted .sort-arrow {
      opacity: 1;
    }

    .areas-table td {
      padding: 12px 16px;
      border-bottom: 1px solid var(--line);
      font-size: 0.9rem;
    }

    .areas-table tr:last-child td {
      border-bottom: none;
    }

    .areas-table tr:hover td {
      background: rgba(255, 255, 255, 0.02);
    }

    /* Empty State */
    .empty-state {
      text-align: center;
      padding: 48px 24px;
      color: var(--muted);
    }

    .empty-state-title {
      font-size: 1.1rem;
      margin-bottom: 8px;
      color: var(--text);
    }

    .empty-state-text {
      font-size: 0.9rem;
    }

    /* Loading State */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 48px;
      color: var(--muted);
    }

    /* Status badges */
    .status-badge {
      display: inline-flex;
      align-items: center;
      gap: 4px;
      padding: 2px 8px;
      border-radius: 4px;
      font-size: 0.75rem;
      font-weight: 500;
    }

    .status-on {
      background: rgba(34, 197, 94, 0.15);
      color: var(--success);
    }

    .status-off {
      background: rgba(148, 163, 184, 0.15);
      color: var(--muted);
    }

    .status-frozen {
      background: rgba(99, 179, 237, 0.15);
      color: #63b3ed;
    }

    /* Header with filter */
    .th-with-filter {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .th-title-row {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .header-filter {
      padding: 4px 8px;
      border-radius: 4px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--text);
      font-size: 0.75rem;
      font-weight: normal;
      cursor: pointer;
      width: 100%;
    }

    .header-filter:focus {
      outline: none;
      border-color: dodgerblue;
    }

    /* Brightness/Color display */
    .lighting-info {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.85rem;
    }

    .brightness-value,
    .kelvin-value {
      /* Inherit color from row */
    }

    /* Buttons */
    .btn {
      padding: 8px 16px;
      border-radius: 6px;
      font-size: 0.85rem;
      cursor: pointer;
      transition: all 0.2s;
    }

    .btn-secondary {
      background: var(--card);
      border: 1px solid var(--line);
      color: var(--text);
    }

    .btn-secondary:hover {
      background: rgba(255, 255, 255, 0.1);
    }

    /* Clickable rows */
    .areas-table tbody tr {
      cursor: pointer;
    }


    /* Timer styles (shared with homepage) */
    .timer-motion {
      color: #e2e8f0;
      opacity: 0.9;
    }

    .timer-boost {
      color: #e2e8f0;
      opacity: 0.9;
      margin-left: auto;
    }

    .timer-frozen {
      color: #63b3ed;
      opacity: 1;
    }

    .timer-arrow {
      color: inherit;
      margin: 0 3px;
    }

    .timer-warning {
      color: #e6a817;
      animation: timer-pulse 1s ease-in-out infinite;
    }

    @keyframes timer-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    /* Area row - div-based for proper shading like modal header */
    .area-row {
      --row-bg: var(--card);
      --row-text: var(--text);
      --row-fill: 0;
      display: flex;
      align-items: center;
      padding: 2px 8px 2px 8px;
      gap: 8px;
      background: var(--row-bg);
      color: var(--row-text);
      border-bottom: 1px solid var(--line);
      position: relative;
      overflow: hidden;
    }

    .area-row:last-child {
      border-bottom: none;
    }

    .area-row:hover {
      background: color-mix(in srgb, var(--row-bg), white 3%);
    }

    /* Uniform glow overlay */
    .area-row::before {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.12);
      opacity: var(--row-fill);
      pointer-events: none;
    }

    .area-row > * {
      position: relative;
      z-index: 1;
    }

    /* Circadian-off row state */
    .area-row.circadian-off {
      cursor: pointer;
      color: var(--muted2);
    }

    .area-row.circadian-off .area-row-name {
      opacity: 0.45;
    }

    .circadian-enable-cta {
      display: inline-flex;
      align-items: center;
      gap: 5px;
      margin-left: auto;
      color: var(--accent);
      font-size: 0.78rem;
      white-space: nowrap;
      opacity: 0.6;
      transition: opacity 0.2s;
      padding: 6px 10px;
      border: 1px dashed rgba(254, 172, 96, 0.3);
      border-radius: 6px;
    }

    .area-row.circadian-off:hover .circadian-enable-cta {
      opacity: 1;
    }

    .circadian-enable-cta svg {
      width: 14px;
      height: 14px;
    }

    .area-row-name {
      min-width: 0;
      font-size: 0.95rem;
      line-height: 1.3;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      cursor: pointer;
    }

    /* Row middle: stacked name + slider column */
    .row-middle {
      flex: 1;
      display: flex;
      flex-direction: column;
      gap: 2px;
      min-width: 0;
    }

    .row-middle-top {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .row-status-sym {
      font-size: 0.6rem;
      opacity: 0.7;
      padding: 0 3px;
      border-radius: 3px;
      background: rgba(0,0,0,0.3);
      white-space: nowrap;
      flex-shrink: 0;
    }

    /* Horizontal slider track — margin for horizontal inset, padding for vertical touch */
    .row-slider-track {
      height: 0;
      position: relative;
      cursor: pointer;
      touch-action: none;
      padding: 12px 0;
      margin: 0 16px;
    }

    .row-slider-track::before {
      content: '';
      position: absolute;
      left: 0;
      right: 0;
      top: 50%;
      height: 4px;
      transform: translateY(-50%);
      border-radius: 2px;
      background: rgba(0,0,0,0.35);
      box-shadow: 0 0.5px 0 rgba(255,255,255,0.15);
      pointer-events: none;
    }

    .row-slider-fill {
      display: none;
    }

    .row-slider-thumb {
      position: absolute;
      top: 50%;
      transform: translate(-50%, -50%);
      width: 30px;
      height: 16px;
      border-radius: 8px 8px 5px 5px;
      background: rgba(255,255,255,0.9);
      box-shadow: 0 1px 4px rgba(0,0,0,0.4);
      pointer-events: none;
      transition: left 0.15s;
    }

    .row-slider-track.dragging .row-slider-thumb {
      transition: none;
    }

    /* Row control buttons - dark container like modal header */
    .row-controls {
      display: inline-flex;
      gap: 4px;
      background: rgba(0,0,0,0.5);
      padding: 4px;
      border-radius: 8px;
    }

    .row-controls-left {
      display: inline-flex;
      gap: 4px;
      background: rgba(0,0,0,0.5);
      padding: 4px;
      border-radius: 8px;
    }

    .row-btn {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(30,30,30,0.9);
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.15s;
      padding: 0;
    }

    .row-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: rgba(50,50,50,0.9);
    }

    .row-btn.active {
      background: rgba(60,60,60,0.9);
      color: var(--text);
      border-color: var(--accent);
    }

    .row-btn svg {
      width: 14px;
      height: 14px;
    }

    /* On/Off section headers */
    /* Zone group headers */
    .zone-group {
      margin-bottom: 16px;
      position: relative;
      z-index: 1;
    }

    .zone-group:has(.zone-rhythm-dropdown.visible) {
      z-index: 10;
    }

    .zone-group:last-child {
      margin-bottom: 0;
    }

    .zone-header {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 6px 8px;
      background: var(--panel);
      cursor: pointer;
      border: 1px solid var(--line);
      border-radius: 8px 8px 0 0;
      user-select: none;
      transition: background 0.15s;
      position: relative;
      z-index: 2;
    }

    .zone-header::before {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.12);
      opacity: var(--header-fill, 0);
      pointer-events: none;
      border-radius: 8px 8px 0 0;
    }

    .zone-header > * {
      position: relative;
      z-index: 1;
    }

    .zone-header:hover {
      background: rgba(255,255,255,0.05);
    }

    .zone-header.collapsed {
      border-radius: 8px;
    }

    .zone-header.no-tint {
      background: var(--bg);
    }

    .zone-header.no-tint::before {
      display: none;
    }

    .zone-header.no-tint:hover {
      background: rgba(255,255,255,0.03);
    }

    .zone-chevron-tap {
      cursor: pointer;
      padding: 4px;
      margin: -4px;
      display: inline-flex;
      align-items: center;
      justify-content: center;
      border-radius: 50%;
    }

    .zone-chevron {
      width: 16px;
      height: 16px;
      color: var(--muted);
      transition: transform 0.2s;
      background: rgba(0,0,0,0.45);
      border-radius: 50%;
      padding: 2px;
      box-sizing: content-box;
      box-shadow: 0 0 0 1.5px rgba(255,255,255,0.25);
    }

    .zone-header.collapsed .zone-chevron {
      transform: rotate(-90deg);
    }

    .zone-name {
      font-weight: 700;
      font-size: 0.95rem;
      letter-spacing: 0.01em;
      color: var(--text);
      line-height: 1.3;
      min-width: 0;
    }

    .zone-count {
      font-size: 0.8rem;
      color: var(--muted);
      margin-left: auto;
    }

    .zone-content {
      background: var(--card);
      border: 1px solid var(--line);
      border-top: none;
      border-radius: 0 0 8px 8px;
    }

    .zone-content.hidden {
      display: none;
    }

    /* Zone rhythm dropdown in header */
    .zone-rhythm-display {
      position: relative;
      display: inline-flex;
      align-items: center;
      gap: 4px;
      align-self: center;
      box-shadow: 0 0 0 1.5px rgba(255,255,255,0.15), 0 1px 4px rgba(0,0,0,0.3);
      border-radius: 6px;
    }

    .zone-rhythm-pill-tinted::before {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.12);
      opacity: var(--pill-fill, 0);
      pointer-events: none;
      border-radius: 6px;
    }

    .zone-rhythm-pill-tinted > * {
      position: relative;
      z-index: 1;
    }

    .zone-rhythm-label {
      font-size: 0.8rem;
      opacity: 0.6;
    }

    .zone-rhythm-btn {
      background: transparent;
      border: none;
      padding: 0;
      font-size: 0.85rem;
      font-weight: 600;
      color: inherit;
      cursor: pointer;
      transition: opacity 0.2s;
    }

    .zone-rhythm-btn::after {
      content: ' ▾';
      font-size: 0.7rem;
      opacity: 0.6;
    }

    .zone-rhythm-btn:hover {
      opacity: 0.8;
    }

    .zone-rhythm-dropdown {
      position: absolute;
      top: 100%;
      left: 0;
      min-width: 160px;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 8px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.4);
      z-index: 100;
      display: none;
      margin-top: 4px;
    }

    .zone-rhythm-display:has(.zone-rhythm-dropdown.visible) {
      z-index: 50;
    }

    .zone-rhythm-dropdown.visible {
      display: block;
    }

    .zone-rhythm-dropdown-item {
      padding: 8px 14px;
      font-size: 0.85rem;
      cursor: pointer;
      border-bottom: 1px solid var(--line);
      color: var(--text);
    }

    .zone-rhythm-dropdown-item:last-child {
      border-bottom: none;
    }

    .zone-rhythm-dropdown-item:hover {
      background: rgba(255, 255, 255, 0.05);
    }

    .zone-rhythm-dropdown-item.selected {
      color: var(--accent);
    }

    a.zone-rhythm-dropdown-item {
      display: block;
      text-decoration: none;
      color: var(--text);
    }

    /* Red dot: area doesn't match zone (inline after power button) */
    .mismatch-dot-area {
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: rgba(239, 68, 68, 0.9);
      box-shadow: 0 0 0 1px rgba(0,0,0,0.6);
      flex-shrink: 0;
    }

    /* Placeholder to keep layout stable when no dot */
    .mismatch-dot-placeholder {
      width: 5px;
      height: 5px;
      flex-shrink: 0;
    }

    /* Red dot: zone doesn't match rhythm */
    .mismatch-dot-zone {
      width: 5px;
      height: 5px;
      border-radius: 50%;
      background: rgba(239, 68, 68, 0.9);
      box-shadow: 0 0 0 1px rgba(0,0,0,0.6);
      flex-shrink: 0;
    }

    /* Toolbar menu */
    .toolbar-menu { position: relative; }
    .toolbar-menu-btn { background: none; border: none; color: var(--muted); font-size: 1.2rem; cursor: pointer; padding: 4px 8px; border-radius: 4px; }
    .toolbar-menu-btn:hover { color: var(--text); background: rgba(255,255,255,0.05); }
    .toolbar-menu-dropdown { display: none; position: absolute; right: 0; top: 100%; min-width: 140px; background: var(--panel); border: 1px solid var(--line); border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.4); z-index: 50; overflow: hidden; }
    .toolbar-menu-dropdown.visible { display: block; }
    .toolbar-menu-item { display: block; padding: 8px 16px; color: var(--muted); text-decoration: none; font-size: 0.85rem; }
    .toolbar-menu-item:hover { color: var(--text); background: rgba(255,255,255,0.05); }

    /* Zone reset button — spans full width of row-controls container (2 btn slots) */
    .zone-reset-btn {
      width: 100%;
      height: 28px;
      border-radius: 4px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(30,30,30,0.9);
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 4px;
      transition: all 0.15s;
      padding: 0;
      flex-shrink: 0;
    }

    .zone-reset-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: rgba(50,50,50,0.9);
    }

    .zone-reset-btn svg {
      flex-shrink: 0;
    }

    /* Nav overflow menu */
    .nav-more { background: none; border: none; color: var(--muted); font-size: 1.2rem; cursor: pointer; padding: 4px 8px; border-radius: 6px; display: none; flex-shrink: 0; letter-spacing: 2px; line-height: 1; }
    .nav-more:hover { color: var(--text); background: rgba(255,255,255,0.05); }
    .nav-overflow { display: none; position: absolute; top: 100%; right: 12px; background: var(--card); border: 1px solid var(--line); border-radius: 8px; padding: 4px 0; min-width: 140px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); z-index: 200; }
    .nav-overflow.open { display: block; }
    .nav-overflow-item { display: block; padding: 10px 16px; color: var(--muted); text-decoration: none; font-size: 0.9rem; white-space: nowrap; }
    .nav-overflow-item:hover { color: var(--text); background: rgba(255,255,255,0.05); }
    .nav-overflow-item.active { color: var(--accent); }

    /* View mode links */
    .view-links { display: flex; align-items: center; gap: 6px; font-size: 0.7rem; }
    .view-link {
      color: var(--muted);
      background: none;
      border: none;
      cursor: pointer;
      transition: color 0.15s;
      padding: 0;
    }
    .view-link:hover { color: var(--text); }
    .view-link.active { color: var(--accent); }
    .view-sep { color: var(--muted2); }

    /* Edit mode styles */
    .edit-toolbar { display: flex; align-items: center; gap: 16px; margin-bottom: 16px; }
    .edit-toolbar-link { font-size: 0.85rem; color: var(--muted); text-decoration: none; cursor: pointer; }
    .edit-toolbar-link:hover { text-decoration: underline; color: var(--text); }

    .edit-zone-header {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 14px 16px;
      background: var(--panel);
      border: 1px solid var(--line);
      border-radius: 8px 8px 0 0;
      cursor: pointer;
      user-select: none;
    }
    .edit-zone-header.collapsed { border-radius: 8px; }

    .edit-zone-arrows {
      display: flex;
      flex-direction: column;
      gap: 2px;
    }
    .edit-zone-arrow {
      width: 22px;
      height: 16px;
      border-radius: 3px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.6rem;
      line-height: 1;
      padding: 0;
    }
    .edit-zone-arrow:hover { background: rgba(255,255,255,0.1); color: var(--accent); border-color: var(--accent); }
    .edit-zone-arrow:disabled { opacity: 0.3; cursor: not-allowed; }

    .edit-zone-name {
      font-weight: 700;
      font-size: 1.05rem;
      color: var(--text);
      flex: 1;
    }

    .edit-zone-actions { display: flex; gap: 6px; }
    .edit-icon-btn {
      width: 28px;
      height: 28px;
      border-radius: 4px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 0.85rem;
      padding: 0;
    }
    .edit-icon-btn:hover { background: rgba(255,255,255,0.1); color: var(--text); border-color: var(--accent); }
    .edit-icon-btn.danger:hover { color: var(--danger); border-color: var(--danger); }
    .edit-icon-btn.default-star { font-size: 1rem; border: none; background: none; width: auto; height: auto; color: var(--muted2); }
    .edit-icon-btn.default-star.active { color: var(--accent); }
    .edit-icon-btn.default-star:hover { color: var(--accent); }

    .edit-rename-input {
      font-weight: 700;
      font-size: 1.05rem;
      background: var(--card);
      border: 1px solid var(--accent);
      color: var(--text);
      border-radius: 4px;
      padding: 2px 8px;
      flex: 1;
      outline: none;
    }

    .edit-mode-row {
      display: flex;
      align-items: center;
      padding: 8px 16px;
      gap: 12px;
      background: var(--card);
      border-bottom: 1px solid var(--line);
      cursor: grab;
    }
    .edit-mode-row:last-child { border-bottom: none; }
    .edit-mode-row.dragging { opacity: 0.4; }
    .edit-mode-row.moving-out {
      opacity: 0;
      max-height: 0;
      padding: 0 16px;
      overflow: hidden;
      transition: opacity 0.25s, max-height 0.3s ease 0.1s, padding 0.3s ease 0.1s;
    }

    .move-zone-select {
      font-size: 0.78rem;
      padding: 2px 6px;
      border-radius: 5px;
      border: 1px solid var(--line);
      background: var(--panel);
      color: var(--muted);
      cursor: pointer;
    }
    .move-zone-select:focus { border-color: dodgerblue; color: var(--text); }

    .home-name-heading {
      font-size: 1.1rem;
      font-weight: 500;
      color: var(--muted);
    }

    .drag-handle { color: var(--muted2); font-size: 1.1rem; cursor: grab; user-select: none; }
    .drag-handle:active { cursor: grabbing; }

    .zone-content.drag-over { outline: 2px dashed var(--accent); outline-offset: -2px; }
    .zone-header.drag-over-target,
    .edit-zone-header.drag-over-target { outline: 2px solid var(--accent); background: rgba(254,172,96,0.1); }

    .drag-indicator {
      height: 2px;
      background: var(--accent);
      margin: 0 16px;
      pointer-events: none;
    }
  </style>
  <script src="./shared.js"></script>
</head>
<body>
  <!-- Navigation -->
  <nav class="nav">
    <a href="./" class="nav-brand active">
      <svg class="nav-logo" viewBox="0 0 40 40" fill="none">
        <circle cx="20" cy="20" r="19" fill="#555"/>
        <path d="M20 1 A19 19 0 0 1 20 39 Q20 28 8 20 Q20 12 20 1" fill="#ccc"/>
        <circle cx="20" cy="12" r="5" fill="#fff"/>
        <line x1="20" y1="3" x2="20" y2="5" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
        <line x1="27" y1="6" x2="25.5" y2="7.5" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
        <line x1="29" y1="12" x2="27" y2="12" stroke="#fff" stroke-width="2" stroke-linecap="round"/>
        <path d="M16 30 A6 6 0 1 1 24 30 A4.5 4.5 0 1 0 16 30" fill="#fff"/>
      </svg>
      Home
    </a>
    <div class="nav-links">
      <a href="./switches" class="nav-link">Control</a>
      <a href="./rhythm" class="nav-link">Rhythm</a>
      <a href="./moments" class="nav-link">Magic</a>
      <a href="./tuning" class="nav-link">Tune</a>
      <a href="./settings" class="nav-link">Settings</a>
    </div>
    <button class="nav-more" aria-label="More pages">&middot;&middot;&middot;</button>
    <div class="nav-overflow"></div>
  </nav>

  <!-- Main Content -->
  <main class="main">
    <!-- Areas grouped by zone -->
    <div id="areas-container">
      <div class="loading">Loading areas...</div>
    </div>
  </main>


  <script>
    // State
    let areas = [];
    let areaStatus = {};
    let zoneStates = {};
    let cachedRhythms = {};
    let viewMode = 'custom'; // 'custom', 'alpha', 'onoff'
    let cachedConfig = null;
    let cachedSunTimes = null; // { sunrise, sunset, solarNoon, solarMid } in local hours
    let editMode = false;
    let cachedGlozones = null; // raw glozone data for edit mode ordering
    let homeRefreshTimer = null;     // Home page card refresh timer
    let homeTickTimer = null;        // 1s home page timer countdown tick
    let sliderDragging = false;      // Suppress renderAreas during slider drag

    // ============================================================
    // Circadian Calculation Functions (for row shading)
    // ============================================================

    const SPEED_TO_SLOPE = [0, 0.4, 0.6, 0.8, 1.0, 1.3, 1.7, 2.3, 3.0, 4.0, 5.5];

    function logistic(x, midpoint, slope, y0, y1) {
      try {
        const expVal = Math.exp(-slope * (x - midpoint));
        return y0 + (y1 - y0) / (1 + expVal);
      } catch {
        return slope * (x - midpoint) > 0 ? y1 : y0;
      }
    }

    function wrap24(x) {
      return ((x % 24) + 24) % 24;
    }

    function getWindowWeight(hour, windowStart, windowEnd, fadeHrs) {
      const h = wrap24(hour);
      let inWindow = false;
      let distFromStart = 0;
      let distToEnd = 0;

      if (windowStart > windowEnd) {
        inWindow = h >= windowStart || h <= windowEnd;
        if (inWindow) {
          distFromStart = h >= windowStart ? (h - windowStart) : (h + 24 - windowStart);
          distToEnd = h <= windowEnd ? (windowEnd - h) : (windowEnd + 24 - h);
        }
      } else {
        inWindow = h >= windowStart && h <= windowEnd;
        if (inWindow) {
          distFromStart = h - windowStart;
          distToEnd = windowEnd - h;
        }
      }

      if (!inWindow) {
        return { inWindow: false, weight: 0 };
      }

      let weight = 1;
      if (fadeHrs > 0.01) {
        if (distFromStart < fadeHrs) {
          weight = Math.min(weight, distFromStart / fadeHrs);
        }
        if (distToEnd < fadeHrs) {
          weight = Math.min(weight, distToEnd / fadeHrs);
        }
      }

      return { inWindow: true, weight };
    }

    function rad(d) { return d * Math.PI / 180; }

    /**
     * Client-side sun time calculation (matches glo-designer.html).
     * Returns { sunrise, sunset, solarNoon, solarMid } as local hour values.
     */
    function getSunTimes(lat, lon) {
      const date = new Date();
      const n = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
      const J = n + ((lon < 0 ? 360 + lon : lon) / 360);
      const M = (357.5291 + 0.9856 * J) % 360;
      const C = 1.9148 * Math.sin(rad(M)) + 0.02 * Math.sin(rad(2 * M)) + 0.0003 * Math.sin(rad(3 * M));
      const L = (M + 102.9372 + C + 180) % 360;
      const D = Math.asin(Math.sin(rad(L)) * Math.sin(rad(23.44)));
      const cosH0 = (Math.cos(rad(90.833)) - Math.sin(rad(lat)) * Math.sin(D)) / (Math.cos(rad(lat)) * Math.cos(D));

      if (cosH0 < -1 || cosH0 > 1) {
        const sn = 12 - date.getTimezoneOffset() / 60 - (lon / 15);
        return { sunrise: sn - 6, sunset: sn + 6, solarNoon: sn, solarMid: (sn + 12) % 24 };
      }

      const H0 = Math.acos(cosH0);
      const dl = (2 * H0 * 180 / Math.PI) / 15;
      const tz = -date.getTimezoneOffset() / 60;
      const sn = 12 + tz - (lon / 15);
      return { sunrise: sn - dl / 2, sunset: sn + dl / 2, solarNoon: sn, solarMid: (sn + 12) % 24 };
    }

    function liftMidpointToPhase(midpoint, phaseStart, phaseEnd) {
      const phaseCenter = (phaseStart + phaseEnd) / 2;
      let mid = midpoint;
      while (mid < phaseCenter - 12) mid += 24;
      while (mid > phaseCenter + 12) mid -= 24;
      const margin = 0.01;
      return Math.max(phaseStart + margin, Math.min(phaseEnd - margin, mid));
    }

    function applySolarRule(baseCCT, hour, cfg, sunTimes, colorOverride) {
      if (!sunTimes) return baseCCT;

      let cct = baseCCT;
      const sunrise = sunTimes.sunrise;
      const sunset = sunTimes.sunset;
      const solarNoon = sunTimes.solarNoon;
      const solarMid = sunTimes.solarMid;

      // Warm night — ceiling
      if (cfg.warm_night_enabled) {
        let warmTarget = cfg.warm_night_target;
        if (colorOverride && colorOverride > 0) {
          warmTarget += colorOverride;
        }

        if (cct > warmTarget) {
          const fadeHrs = cfg.warm_night_fade / 60;
          const startOffsetHrs = cfg.warm_night_start / 60;
          const endOffsetHrs = cfg.warm_night_end / 60;
          const mode = cfg.warm_night_mode;

          let windowStart, windowEnd;
          if (mode === 'sunrise') {
            windowStart = wrap24(solarMid);
            windowEnd = wrap24(sunrise + endOffsetHrs);
          } else if (mode === 'sunset') {
            windowStart = wrap24(sunset + startOffsetHrs);
            windowEnd = wrap24(solarMid);
          } else {
            windowStart = wrap24(sunset + startOffsetHrs);
            windowEnd = wrap24(sunrise + endOffsetHrs);
          }

          const { inWindow, weight } = getWindowWeight(hour, windowStart, windowEnd, fadeHrs);
          if (inWindow && weight > 0) {
            cct = cct + (warmTarget - cct) * weight;
          }
        }
      }

      // Daylight color blend (intensity-based)
      const daylightCct = cfg.daylight_cct || 0;
      const colorSensitivity = cfg.color_sensitivity ?? 1.50;
      if (daylightCct > 0) {
        let blend = Math.min(1.0, 1.0 * colorSensitivity);
        // Apply daylight fade
        const daylightFade = cfg.daylight_fade ?? 60;
        if (daylightFade > 0 && sunTimes) {
          const fadeHrs = daylightFade / 60;
          const h = ((hour % 24) + 24) % 24;
          const sr = sunTimes.sunrise, ss = sunTimes.sunset;
          const distSunrise = ((h - sr) % 24 + 24) % 24;
          const distSunset = ((ss - h) % 24 + 24) % 24;
          let tw = 1.0;
          if (distSunrise < fadeHrs) tw = Math.min(tw, distSunrise / fadeHrs);
          if (distSunset < fadeHrs) tw = Math.min(tw, distSunset / fadeHrs);
          blend *= tw;
        }
        let daylightTarget = daylightCct;
        if (colorOverride && colorOverride < 0) {
          daylightTarget += colorOverride;
        }
        if (daylightTarget > cct) {
          cct += (daylightTarget - cct) * blend;
        }
      }

      return cct;
    }

    /**
     * Calculate brightness (0-1) at a given hour using the area's state overrides.
     * cfg = cachedConfig, state = { brightness_mid, color_mid, color_override, frozen_at }
     * currentHour = the hour used to determine which phase runtimeState applies to
     */
    function calcMiniBrightness(hour, cfg, state, currentHour) {
      const tAscend = cfg.ascend_start;
      let tDescend = cfg.descend_start;
      if (tDescend <= tAscend) tDescend += 24;

      const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, cfg.wake_speed))];
      const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, cfg.bed_speed))];
      const bMin = cfg.min_brightness / 100;
      const bMax = cfg.max_brightness / 100;

      // Determine which phase the current time (cursor) is in
      const cursorH48 = currentHour < tAscend ? currentHour + 24 : currentHour;
      const cursorInAscend = cursorH48 >= tAscend && cursorH48 < tDescend;

      const wakeMid = cursorInAscend ? (state.brightness_mid ?? cfg.wake_time) : cfg.wake_time;
      const bedMid = !cursorInAscend ? (state.brightness_mid ?? cfg.bed_time) : cfg.bed_time;

      // Phase detection for this sample hour
      const h48 = hour < tAscend ? hour + 24 : hour;
      const inAscend = h48 >= tAscend && h48 < tDescend;

      const mid48 = inAscend
        ? liftMidpointToPhase(wakeMid, tAscend, tDescend)
        : liftMidpointToPhase(bedMid, tDescend, tDescend + 24);

      let value;
      if (inAscend) {
        value = logistic(h48, mid48, kAscend, bMin, bMax);
      } else {
        const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
        value = logistic(hDescend48, mid48, -kDescend, bMin, bMax);
      }

      return Math.max(bMin, Math.min(bMax, value));
    }

    /**
     * Calculate CCT (Kelvin) at a given hour, with solar rules applied.
     */
    function calcMiniColor(hour, cfg, state, sunTimes, currentHour) {
      const tAscend = cfg.ascend_start;
      let tDescend = cfg.descend_start;
      if (tDescend <= tAscend) tDescend += 24;

      const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, cfg.wake_speed))];
      const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, cfg.bed_speed))];
      const cLow = cfg.min_color_temp;
      const cHigh = cfg.max_color_temp;

      const cursorH48 = currentHour < tAscend ? currentHour + 24 : currentHour;
      const cursorInAscend = cursorH48 >= tAscend && cursorH48 < tDescend;

      const colorWakeMid = cursorInAscend ? (state.color_mid ?? cfg.wake_time) : cfg.wake_time;
      const colorBedMid = !cursorInAscend ? (state.color_mid ?? cfg.bed_time) : cfg.bed_time;

      const h48 = hour < tAscend ? hour + 24 : hour;
      const inAscend = h48 >= tAscend && h48 < tDescend;

      const mid48 = inAscend
        ? liftMidpointToPhase(colorWakeMid, tAscend, tDescend)
        : liftMidpointToPhase(colorBedMid, tDescend, tDescend + 24);

      let normalized;
      if (inAscend) {
        normalized = logistic(h48, mid48, kAscend, 0, 1);
      } else {
        const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
        normalized = logistic(hDescend48, mid48, -kDescend, 0, 1);
      }
      normalized = Math.max(0, Math.min(1, normalized));

      let cct = cLow + (cHigh - cLow) * normalized;

      // Apply solar rules
      cct = applySolarRule(cct, hour, cfg, sunTimes, state.color_override);

      return cct;
    }

    function formatCountdown(isoTimestamp) {
      if (!isoTimestamp) return null;
      const expires = new Date(isoTimestamp);
      if (isNaN(expires.getTime())) return null;  // Invalid date (e.g. "motion" sentinel)
      const now = new Date();
      const diffMs = expires - now;
      if (diffMs <= 0) return null;
      const totalSec = Math.floor(diffMs / 1000);
      if (totalSec < 60) return `${totalSec}s`;
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      if (min < 60) return sec > 0 ? `${min}m ${sec}s` : `${min}m`;
      const hr = Math.floor(min / 60);
      const remMin = min % 60;
      return remMin > 0 ? `${hr}h ${remMin}m` : `${hr}h`;
    }

    // ============================================================
    // Page Logic
    // ============================================================

    // Initialize
    document.addEventListener('DOMContentLoaded', async () => {
      await loadPreferences();
      loadData();
      setupEventListeners();
    });

    async function loadPreferences() {
      try {
        const configRes = await fetch('./api/config');

        if (configRes.ok) {
          cachedConfig = await configRes.json();
          const prefs = cachedConfig.areas_ui || {};
          viewMode = prefs.view_mode || prefs.sort_mode || 'custom';

          // Compute sun times client-side from config lat/lon
          const lat = cachedConfig.latitude || 35.0;
          const lon = cachedConfig.longitude || -78.6;
          cachedSunTimes = getSunTimes(lat, lon);
        }
      } catch (err) {
        console.error('Error loading preferences:', err);
      }
    }

    async function savePreferences() {
      try {
        await fetch('./api/config', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            areas_ui: {
              view_mode: viewMode
            }
          })
        });
      } catch (err) {
        console.error('Error saving preferences:', err);
      }
    }

    function getHomeRefreshInterval() {
      if (cachedConfig) {
        const val = cachedConfig.home_refresh_interval;
        if (val && val >= 2 && val <= 60) return val;
      }
      return 10;
    }

    function updateHomeTimers() {
      // Update all timer spans in-place without re-rendering (no API calls)
      document.querySelectorAll('[data-area-timer]').forEach(el => {
        const areaId = el.getAttribute('data-area-timer');
        const status = areaStatus[areaId] || {};
        const hasMotion = status.motion_expires_at && status.motion_expires_at !== 'forever';
        const isBoosted = status.boosted || false;
        const isMotionCoupled = status.is_motion_coupled || false;
        const warnClass = status.motion_warning_active ? ' timer-warning' : '';

        if (hasMotion && isBoosted && isMotionCoupled) {
          const remaining = formatCountdown(status.motion_expires_at);
          const frozenPart = status.frozen ? ` <span class="timer-frozen">❄</span>` : '';
          el.innerHTML = remaining
            ? `<span class="timer-motion${warnClass}">M+${status.boost_brightness}% ${remaining}</span>${frozenPart}`
            : '';
          return;
        }

        const parts = [];
        if (hasMotion) {
          const remaining = formatCountdown(status.motion_expires_at);
          if (remaining) parts.push(`<span class="timer-motion${warnClass}">M ${remaining}</span>`);
        }
        if (isBoosted && status.boost_brightness && !isMotionCoupled) {
          let text = `B+${status.boost_brightness}%`;
          if (status.boost_expires_at !== 'forever' && status.boost_expires_at) {
            const remaining = formatCountdown(status.boost_expires_at);
            if (remaining) text += ` ${remaining}`;
          }
          parts.push(`<span class="timer-boost">${text}</span>`);
        }
        if (status.frozen) {
          parts.push(`<span class="timer-frozen">❄</span>`);
        }
        el.innerHTML = parts.join(' ');
      });
    }

    function startHomeRefresh() {
      stopHomeRefresh();
      const interval = getHomeRefreshInterval() * 1000;
      homeRefreshTimer = setInterval(async () => {
        try {
          const [res, zsRes] = await Promise.all([
            fetch('./api/area-status'),
            fetch('./api/zone-states')
          ]);
          if (res.ok) {
            areaStatus = await res.json();
          }
          if (zsRes.ok) {
            const zs = await zsRes.json();
            zoneStates = zs.zone_states || {};
          }
          renderAreas();
        } catch (err) {
          console.error('Error refreshing home page:', err);
        }
      }, interval);
      // 1s tick for timer countdowns (no API calls)
      homeTickTimer = setInterval(updateHomeTimers, 1000);
    }

    function stopHomeRefresh() {
      if (homeRefreshTimer) { clearInterval(homeRefreshTimer); homeRefreshTimer = null; }
      if (homeTickTimer) { clearInterval(homeTickTimer); homeTickTimer = null; }
    }

    async function loadData() {
      const container = document.getElementById('areas-container');
      container.innerHTML = '<div class="loading">Loading areas...</div>';

      try {
        const [areasRes, statusRes, zoneStatesRes, rhythmsRes, glozonesRes] = await Promise.all([
          fetch('./api/areas'),
          fetch('./api/area-status'),
          fetch('./api/zone-states'),
          fetch('./api/circadian-rhythms'),
          fetch('./api/glozones')
        ]);

        if (areasRes.ok) {
          areas = await areasRes.json();
        }

        if (statusRes.ok) {
          areaStatus = await statusRes.json();
        }

        if (zoneStatesRes.ok) {
          const zs = await zoneStatesRes.json();
          zoneStates = zs.zone_states || {};
        }

        if (rhythmsRes.ok) {
          const p = await rhythmsRes.json();
          cachedRhythms = p.rhythms || {};
        }

        if (glozonesRes.ok) {
          cachedGlozones = await glozonesRes.json();
        }

        renderAreas();
        startHomeRefresh();
      } catch (err) {
        console.error('Error loading data:', err);
        container.innerHTML = '<div class="loading">Error loading data</div>';
      }
    }

    // Collapsed zone state (persisted in localStorage)
    function getCollapsedZones() {
      try {
        return JSON.parse(localStorage.getItem('areas_collapsed_zones') || '{}');
      } catch { return {}; }
    }

    function setZoneCollapsed(zoneName, collapsed) {
      const state = getCollapsedZones();
      state[zoneName] = collapsed;
      localStorage.setItem('areas_collapsed_zones', JSON.stringify(state));
    }

    function toggleZone(zoneName, el) {
      // Use clicked element's parent .zone-group to find the correct header/table
      // (avoids querySelector hitting the wrong duplicate in On first view)
      const zoneGroup = el ? el.closest('.zone-group') : null;
      const header = zoneGroup
        ? zoneGroup.querySelector(`[data-zone="${zoneName}"]`)
        : document.querySelector(`[data-zone="${zoneName}"]`);
      const table = zoneGroup
        ? zoneGroup.querySelector(`[data-zone-table="${zoneName}"]`)
        : document.querySelector(`[data-zone-table="${zoneName}"]`);

      const isCurrentlyCollapsed = header ? header.classList.contains('collapsed') : false;
      const isCollapsed = !isCurrentlyCollapsed;

      if (header && table) {
        header.classList.toggle('collapsed', isCollapsed);
        table.classList.toggle('hidden', isCollapsed);
        setZoneCollapsed(zoneName, isCollapsed);
      }
    }

    async function zoneAction(zoneName, action, value, mode) {
      try {
        const body = { zone_name: zoneName, action: action };
        if (value !== undefined) { body.value = value; body.mode = mode || 'step'; }
        const response = await fetch('./api/zone/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });
        if (response.ok) {
          // Refresh after action
          setTimeout(async () => {
            const [statusRes, zsRes] = await Promise.all([
              fetch('./api/area-status'),
              fetch('./api/zone-states')
            ]);
            if (statusRes.ok) areaStatus = await statusRes.json();
            if (zsRes.ok) {
              const zs = await zsRes.json();
              zoneStates = zs.zone_states || {};
            }
            renderAreas();
          }, 500);
        }
      } catch (err) {
        console.error('Error executing zone action:', err);
      }
    }

    function glozoneReset(zoneName) {
      zoneAction(zoneName, 'glozone_reset');
    }

    async function confirmZonePowerOff(zoneName) {
      const onAreas = areas.filter(a => {
        const s = areaStatus[a.area_id] || {};
        return s.zone_name === zoneName && s.is_on;
      });
      if (onAreas.length === 0) return;
      const areaList = onAreas.map(a => a.name).join('\n');
      const msg = `Turn off lights in these areas?\n\n${areaList}`;
      if (!confirm(msg)) return;
      for (const area of onAreas) {
        await fetch('./api/area/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ area_id: area.area_id, action: 'lights_off' })
        });
      }
      setTimeout(async () => {
        try {
          const [statusRes, zsRes] = await Promise.all([
            fetch('./api/area-status'),
            fetch('./api/zone-states')
          ]);
          if (statusRes.ok) areaStatus = await statusRes.json();
          if (zsRes.ok) {
            const zs = await zsRes.json();
            zoneStates = zs.zone_states || {};
          }
          renderAreas();
        } catch (err) {
          console.error('Error refreshing after zone power off:', err);
        }
      }, 500);
    }

    function glozoneDown(zoneName) {
      const zs = zoneStates[zoneName] || {};
      const bri = Math.round(zs.brightness ?? 0);
      const kelvin = Math.round(zs.kelvin ?? 4000);
      const affectedAreas = areas.filter(a => {
        const s = areaStatus[a.area_id] || {};
        if ((s.zone_name || a.zone_name) !== zoneName || !s.is_on) return false;
        return Math.round(s.brightness || 0) !== bri || Math.round(s.kelvin || 4000) !== kelvin;
      });
      if (affectedAreas.length > 0) {
        const areaList = affectedAreas.map(a => a.name).join('\n');
        const msg = `Send ${bri}% / ${kelvin}K to "${zoneName}"? These areas will adjust:\n\n${areaList}`;
        if (!confirm(msg)) return;
      }
      zoneAction(zoneName, 'glozone_down');
    }

    function rowFullSend(areaId) {
      const area = areas.find(a => a.area_id === areaId);
      if (!area) return;
      const status = areaStatus[areaId] || {};
      const zoneName = status.zone_name || area.zone_name;
      if (!zoneName) return;
      const bri = Math.round(status.brightness || 0);
      const kelvin = Math.round(status.kelvin || 4000);
      const affectedAreas = areas.filter(a => {
        const s = areaStatus[a.area_id] || {};
        if ((s.zone_name || a.zone_name) !== zoneName || !s.is_on) return false;
        return Math.round(s.brightness || 0) !== bri || Math.round(s.kelvin || 4000) !== kelvin;
      });
      if (affectedAreas.length > 0) {
        const areaList = affectedAreas.map(a => a.name).join('\n');
        const msg = `Full Send ${bri}% / ${kelvin}K to "${zoneName}"? These areas will adjust:\n\n${areaList}`;
        if (!confirm(msg)) return;
      }
      rowAction(areaId, 'full_send');
    }

    function toggleRhythmDropdown(el) {
      const display = el.closest('.zone-rhythm-display');
      if (!display) return;
      const dropdown = display.querySelector('.zone-rhythm-dropdown');
      // Close other rhythm dropdowns
      document.querySelectorAll('.zone-rhythm-dropdown.visible').forEach(d => {
        if (d !== dropdown) d.classList.remove('visible');
      });
      dropdown.classList.toggle('visible');
    }

    function selectRhythm(item) {
      event.stopPropagation();
      const zoneName = item.dataset.zone;
      const rhythm = item.dataset.rhythm;
      item.closest('.zone-rhythm-dropdown').classList.remove('visible');

      if (rhythm === '__new__') {
        const newName = prompt('New rhythm name:');
        if (newName && newName.trim()) {
          createAndAssignRhythm(zoneName, newName.trim());
        }
      } else {
        changeZoneRhythm(zoneName, rhythm);
      }
    }

    async function changeZoneRhythm(zoneName, rhythmName) {
      try {
        await fetch(`./api/glozones/${encodeURIComponent(zoneName)}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ rhythm: rhythmName })
        });
        await loadData();
      } catch (err) {
        console.error('Error changing rhythm:', err);
      }
    }

    async function createAndAssignRhythm(zoneName, rhythmName) {
      try {
        // Create new rhythm (copy from current zone's rhythm as base)
        const zs = zoneStates[zoneName];
        const sourceRhythm = zs?.rhythm;
        const baseConfig = sourceRhythm && cachedRhythms[sourceRhythm]
          ? { ...cachedRhythms[sourceRhythm] }
          : {};

        await fetch('./api/circadian-rhythms', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: rhythmName, settings: baseConfig })
        });

        // Assign it to the zone
        await changeZoneRhythm(zoneName, rhythmName);
      } catch (err) {
        console.error('Error creating rhythm:', err);
      }
    }

    /**
     * Compute pure rhythm brightness/kelvin at current hour for a specific rhythm.
     * Uses the rhythm's own curve config (from cachedRhythms) merged with global settings.
     * Returns { brightness, kelvin } or null if config not available.
     */
    function getPureRhythmValues(rhythmName) {
      if (!cachedSunTimes) return null;

      // Build config: start with cachedConfig (which has the effective first rhythm's
      // settings flattened by /api/config), then overlay the specific rhythm's settings.
      // Once the server-side glozone.py fix propagates complete rhythm configs via
      // /api/circadian-rhythms, the overlay will contain all keys directly.
      let cfg;
      if (rhythmName && cachedRhythms[rhythmName]) {
        cfg = { ...cachedConfig, ...cachedRhythms[rhythmName] };
      } else if (cachedConfig) {
        cfg = cachedConfig;
      } else {
        return null;
      }

      const now = new Date();
      const currentHour = now.getHours() + now.getMinutes() / 60;
      const emptyState = { brightness_mid: null, color_mid: null, color_override: null, frozen_at: null };
      const brightness = calcMiniBrightness(currentHour, cfg, emptyState, currentHour) * 100;
      const kelvin = calcMiniColor(currentHour, cfg, emptyState, cachedSunTimes, currentHour);
      return { brightness, kelvin };
    }

    // ============================================================
    // Edit Mode Functions
    // ============================================================

    function enterEditMode() {
      editMode = true;
      stopHomeRefresh();
      renderAreas();
    }

    function exitEditMode() {
      editMode = false;
      loadData();
      startHomeRefresh();
    }

    async function moveZone(zoneName, direction) {
      if (!cachedGlozones || !cachedGlozones.zones) return;
      const zoneNames = Object.keys(cachedGlozones.zones);
      const idx = zoneNames.indexOf(zoneName);
      if (idx < 0) return;
      const newIdx = idx + direction;
      if (newIdx < 0 || newIdx >= zoneNames.length) return;

      // Swap
      [zoneNames[idx], zoneNames[newIdx]] = [zoneNames[newIdx], zoneNames[idx]];

      try {
        const res = await fetch('./api/glozones/reorder', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ order: zoneNames })
        });
        if (res.ok) {
          // Re-fetch glozone data and re-render
          const gzRes = await fetch('./api/glozones');
          if (gzRes.ok) cachedGlozones = await gzRes.json();
          renderAreas();
        }
      } catch (err) {
        console.error('Error reordering zones:', err);
      }
    }

    async function createZoneFromEdit() {
      const name = prompt('New zone name:');
      if (!name || !name.trim()) return;

      try {
        const res = await fetch('./api/glozones', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ name: name.trim() })
        });
        if (res.ok) {
          const gzRes = await fetch('./api/glozones');
          if (gzRes.ok) cachedGlozones = await gzRes.json();
          // Also reload zone states
          const zsRes = await fetch('./api/zone-states');
          if (zsRes.ok) {
            const zs = await zsRes.json();
            zoneStates = zs.zone_states || {};
          }
          renderAreas();
        } else {
          const err = await res.json();
          alert(err.error || 'Error creating zone');
        }
      } catch (err) {
        console.error('Error creating zone:', err);
      }
    }

    async function deleteZoneFromEdit(zoneName) {
      // Count areas in this zone
      const zoneData = cachedGlozones?.zones?.[zoneName];
      const areaCount = zoneData?.areas?.length || 0;
      let msg;
      if (areaCount > 0) {
        // Find the default zone (where areas will be moved)
        const defaultZone = Object.entries(cachedGlozones?.zones || {})
          .find(([zn, zc]) => zc.is_default && zn !== zoneName)?.[0]
          || Object.keys(cachedGlozones?.zones || {}).find(zn => zn !== zoneName);
        msg = `Move ${areaCount} area(s) to "${defaultZone}" and delete "${zoneName}"?`;
      } else {
        msg = `Delete "${zoneName}"?`;
      }
      if (!confirm(msg)) return;

      try {
        const res = await fetch(`./api/glozones/${encodeURIComponent(zoneName)}`, {
          method: 'DELETE'
        });
        if (res.ok) {
          const [gzRes, zsRes, statusRes] = await Promise.all([
            fetch('./api/glozones'),
            fetch('./api/zone-states'),
            fetch('./api/area-status')
          ]);
          if (gzRes.ok) cachedGlozones = await gzRes.json();
          if (zsRes.ok) {
            const zs = await zsRes.json();
            zoneStates = zs.zone_states || {};
          }
          if (statusRes.ok) areaStatus = await statusRes.json();
          renderAreas();
        } else {
          const err = await res.json();
          alert(err.error || 'Error deleting zone');
        }
      } catch (err) {
        console.error('Error deleting zone:', err);
      }
    }

    async function setDefaultZone(zoneName) {
      try {
        await fetch(`./api/glozones/${encodeURIComponent(zoneName)}`, {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ is_default: true })
        });
        const gzRes = await fetch('./api/glozones');
        if (gzRes.ok) cachedGlozones = await gzRes.json();
        renderAreas();
      } catch (err) {
        console.error('Error setting default zone:', err);
      }
    }

    function startRenameZone(zoneName) {
      const nameEl = document.querySelector(`[data-edit-zone-name="${zoneName}"]`);
      if (!nameEl) return;
      const input = document.createElement('input');
      input.type = 'text';
      input.value = zoneName;
      input.className = 'edit-rename-input';

      async function doRename() {
        const newName = input.value.trim();
        if (!newName || newName === zoneName) {
          // Revert
          input.replaceWith(nameEl);
          return;
        }
        try {
          const res = await fetch(`./api/glozones/${encodeURIComponent(zoneName)}`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ name: newName })
          });
          if (res.ok) {
            const gzRes = await fetch('./api/glozones');
            if (gzRes.ok) cachedGlozones = await gzRes.json();
            const zsRes = await fetch('./api/zone-states');
            if (zsRes.ok) {
              const zs = await zsRes.json();
              zoneStates = zs.zone_states || {};
            }
            renderAreas();
          } else {
            const err = await res.json();
            alert(err.error || 'Error renaming zone');
            input.replaceWith(nameEl);
          }
        } catch (err) {
          console.error('Error renaming zone:', err);
          input.replaceWith(nameEl);
        }
      }

      input.addEventListener('blur', doRename);
      input.addEventListener('keydown', (e) => {
        if (e.key === 'Enter') { e.preventDefault(); input.blur(); }
        if (e.key === 'Escape') { input.removeEventListener('blur', doRename); input.replaceWith(nameEl); }
      });

      nameEl.replaceWith(input);
      input.focus();
      input.select();
    }

    // ============================================================
    // Drag and Drop for Edit Mode
    // ============================================================

    let dragState = { areaId: null, sourceZone: null };

    function onDragStart(e, areaId, zoneName) {
      dragState = { areaId, sourceZone: zoneName };
      e.dataTransfer.effectAllowed = 'move';
      e.dataTransfer.setData('text/plain', areaId);
      e.target.classList.add('dragging');
    }

    function onDragEnd(e) {
      e.target.classList.remove('dragging');
      // Clean up all drag-over indicators
      document.querySelectorAll('.drag-over, .drag-over-target').forEach(el => {
        el.classList.remove('drag-over', 'drag-over-target');
      });
      document.querySelectorAll('.drag-indicator').forEach(el => el.remove());
      dragState = { areaId: null, sourceZone: null };
    }

    function onZoneContentDragOver(e, zoneName) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      const content = e.currentTarget;
      content.classList.add('drag-over');

      // Show insertion indicator
      document.querySelectorAll('.drag-indicator').forEach(el => el.remove());
      const rows = [...content.querySelectorAll('.edit-mode-row')];
      let insertBefore = null;
      for (const row of rows) {
        const rect = row.getBoundingClientRect();
        if (e.clientY < rect.top + rect.height / 2) {
          insertBefore = row;
          break;
        }
      }
      const indicator = document.createElement('div');
      indicator.className = 'drag-indicator';
      if (insertBefore) {
        content.insertBefore(indicator, insertBefore);
      } else {
        content.appendChild(indicator);
      }
    }

    function onZoneContentDragLeave(e) {
      // Only remove if actually leaving the container (not entering a child)
      if (!e.currentTarget.contains(e.relatedTarget)) {
        e.currentTarget.classList.remove('drag-over');
        e.currentTarget.querySelectorAll('.drag-indicator').forEach(el => el.remove());
      }
    }

    function onZoneHeaderDragOver(e) {
      e.preventDefault();
      e.dataTransfer.dropEffect = 'move';
      e.currentTarget.classList.add('drag-over-target');
    }

    function onZoneHeaderDragLeave(e) {
      e.currentTarget.classList.remove('drag-over-target');
    }

    async function onZoneContentDrop(e, targetZone) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over');
      document.querySelectorAll('.drag-indicator').forEach(el => el.remove());

      const areaId = dragState.areaId;
      const sourceZone = dragState.sourceZone;
      if (!areaId) return;

      if (sourceZone === targetZone) {
        // Reorder within zone: compute new order from DOM position
        const content = e.currentTarget;
        const rows = [...content.querySelectorAll('.edit-mode-row')];
        const currentIds = rows.map(r => r.dataset.areaId).filter(id => id !== areaId);

        // Find insertion index
        let insertIdx = currentIds.length;
        for (let i = 0; i < rows.length; i++) {
          if (rows[i].dataset.areaId === areaId) continue;
          const rect = rows[i].getBoundingClientRect();
          if (e.clientY < rect.top + rect.height / 2) {
            insertIdx = currentIds.indexOf(rows[i].dataset.areaId);
            break;
          }
        }
        currentIds.splice(insertIdx, 0, areaId);

        try {
          await fetch(`./api/glozones/${encodeURIComponent(targetZone)}/reorder-areas`, {
            method: 'PUT',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ area_ids: currentIds })
          });
          const gzRes = await fetch('./api/glozones');
          if (gzRes.ok) cachedGlozones = await gzRes.json();
          renderAreas();
        } catch (err) {
          console.error('Error reordering areas:', err);
        }
      } else {
        // Cross-zone move: remove from source, add to target
        await crossZoneMove(areaId, sourceZone, targetZone);
      }
    }

    async function onZoneHeaderDrop(e, targetZone) {
      e.preventDefault();
      e.currentTarget.classList.remove('drag-over-target');

      const areaId = dragState.areaId;
      const sourceZone = dragState.sourceZone;
      if (!areaId || sourceZone === targetZone) return;

      await crossZoneMove(areaId, sourceZone, targetZone);
    }

    async function crossZoneMove(areaId, sourceZone, targetZone) {
      try {
        // Find area name
        const area = areas.find(a => a.area_id === areaId);
        const areaName = area ? area.name : areaId;

        // Remove from source zone
        await fetch(`./api/glozones/${encodeURIComponent(sourceZone)}/areas/${encodeURIComponent(areaId)}`, {
          method: 'DELETE'
        });

        // Add to target zone
        await fetch(`./api/glozones/${encodeURIComponent(targetZone)}/areas`, {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ area_id: areaId, area_name: areaName })
        });

        // Refresh
        const [gzRes, statusRes] = await Promise.all([
          fetch('./api/glozones'),
          fetch('./api/area-status')
        ]);
        if (gzRes.ok) cachedGlozones = await gzRes.json();
        if (statusRes.ok) areaStatus = await statusRes.json();
        renderAreas();
      } catch (err) {
        console.error('Error moving area:', err);
      }
    }

    async function moveAreaToZone(selectEl, areaId, sourceZone) {
      const targetZone = selectEl.value;
      if (!targetZone) return;
      const row = selectEl.closest('.edit-mode-row');
      row.classList.add('moving-out');
      setTimeout(() => crossZoneMove(areaId, sourceZone, targetZone), 350);
    }

    function renderAreas() {
      if (sliderDragging) return; // Don't re-render while user is dragging
      const container = document.getElementById('areas-container');

      // Merge area data with status
      const mergedAreas = areas.map(area => {
        const status = areaStatus[area.area_id] || {};
        return {
          ...area,
          is_on: status.is_on || false,
          brightness: status.curve_brightness || status.brightness || 0,
          kelvin: status.kelvin || 4000,
          frozen: status.frozen || false,
          boosted: status.boosted || false,
          boost_brightness: status.boost_brightness || null,
          boost_expires_at: status.boost_expires_at || null,
          boost_started_from_off: status.boost_started_from_off || false,
          is_motion_coupled: status.is_motion_coupled || false,
          motion_expires_at: status.motion_expires_at || null,
          motion_warning_active: status.motion_warning_active || false,
          zone_name: status.zone_name || null,
          min_brightness: status.min_brightness ?? null,
          max_brightness: status.max_brightness ?? null,
          min_color_temp: status.min_color_temp ?? null,
          max_color_temp: status.max_color_temp ?? null,
          brightness_mid: status.brightness_mid ?? null,
          color_mid: status.color_mid ?? null,
          color_override: status.color_override ?? null,
          frozen_at: status.frozen_at ?? null
        };
      });

      // Sort areas within each zone group
      const sortAreas = (list) => {
        if (viewMode === 'custom' || viewMode === 'onoff') return list; // preserve API order
        return [...list].sort((a, b) => {
          return a.name.toLowerCase().localeCompare(b.name.toLowerCase());
        });
      };

      function isAreaMismatched(area) {
        if (!area.zone_name || !zoneStates[area.zone_name]) return false;
        const rs = zoneStates[area.zone_name].runtime_state || {};
        const tol = 0.1;
        const differs = (a, b) => {
          if (a == null && b == null) return false;
          if (a == null || b == null) return true;
          return Math.abs(a - b) >= tol;
        };
        return differs(area.brightness_mid, rs.brightness_mid) ||
               differs(area.color_mid, rs.color_mid) ||
               differs(area.frozen_at, rs.frozen_at) ||
               area.color_override != null;
      }

      const filtered = mergedAreas;

      // Group by zone
      const zoneGroups = {};
      const unassigned = [];
      for (const area of filtered) {
        if (area.zone_name) {
          if (!zoneGroups[area.zone_name]) zoneGroups[area.zone_name] = [];
          zoneGroups[area.zone_name].push(area);
        } else {
          unassigned.push(area);
        }
      }

      // Sort zone names, put Unassigned at end
      const zoneNames = Object.keys(zoneGroups).sort();

      // Collapsed state
      const collapsedState = getCollapsedZones();

      // Chevron icon
      const chevronIcon = `<svg class="zone-chevron" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="6 9 12 15 18 9"/></svg>`;

      // Power icon (shared for zone header)
      const powerIconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M18.36 6.64a9 9 0 1 1-12.73 0M12 2v10"/></svg>`;

      // GloZone Reset icon: rewind arrow
      const glozoneResetIcon = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round" style="width:14px;height:14px;"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>`;

      // GloZone Down icon: double-down chevron
      const glozoneDownIcon = `<svg viewBox="0 0 16 20" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round" style="width:12px;height:14px;"><polyline points="3 5 8 10 13 5"/><polyline points="3 11 8 16 13 11"/></svg>`;

      // Build toolbar HTML
      const homeName = cachedConfig?.home_name || 'Your home';
      let html;
      if (editMode) {
        html = `
          <div class="edit-toolbar">
            <span style="font-size: 1rem; font-weight: 600; color: var(--text);">Organize${homeName ? ': ' + homeName : ''}</span>
            <span style="flex: 1;"></span>
            <a href="#" class="edit-toolbar-link" onclick="event.preventDefault(); exitEditMode()" style="color: var(--accent); font-weight: 600;">Done</a>
          </div>
        `;
      } else {
        html = `
          <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
            <span class="home-name-heading">${homeName || ''}</span>
            <div class="view-links" style="margin-left: 8px;">
              <button class="view-link ${viewMode === 'onoff' ? 'active' : ''}" data-view="onoff">on/off</button>
              <span class="view-sep">·</span>
              <button class="view-link ${viewMode === 'custom' ? 'active' : ''}" data-view="custom">your order</button>
              <span class="view-sep">·</span>
              <button class="view-link ${viewMode === 'alpha' ? 'active' : ''}" data-view="alpha">a–z</button>
            </div>
            <span style="flex: 1;"></span>
            <div class="toolbar-menu" style="padding-left: 8px;">
              <button class="toolbar-menu-btn" onclick="toggleToolbarMenu(event)">⋮</button>
              <div class="toolbar-menu-dropdown" id="toolbar-menu-dropdown">
                <a href="#" class="toolbar-menu-item" id="organize-link">Organize</a>
                <a href="#" class="toolbar-menu-item" id="refresh-link">Refresh</a>
              </div>
            </div>
          </div>
        `;
      }

      const renderZoneGroup = (zoneName, areasInZone, zoneIndex, totalZones, { allOff = false } = {}) => {
        const isCollapsed = collapsedState[zoneName] || false;
        const sorted = editMode ? areasInZone : sortAreas(areasInZone);
        const escapedZoneName = zoneName.replace(/'/g, "\\'");

        if (editMode) {
          // Edit mode: simplified header with arrows, rename, delete
          const upDisabled = zoneIndex === 0 ? 'disabled' : '';
          const downDisabled = zoneIndex === totalZones - 1 ? 'disabled' : '';

          // Build move-to-zone options (all zones except current, sorted alpha)
          const allZoneNames = Object.keys(cachedGlozones?.zones || {});
          const otherZones = allZoneNames.filter(z => z !== zoneName).sort();
          const moveOptions = otherZones.map(z => `<option value="${z}">${z}</option>`).join('');

          const areaRows = sorted.map(area => `
            <div class="edit-mode-row" draggable="true" data-area-id="${area.area_id}"
              ondragstart="onDragStart(event, '${area.area_id}', '${escapedZoneName}')"
              ondragend="onDragEnd(event)">
              <span class="drag-handle">&#9776;</span>
              <span style="flex: 1; font-size: 0.9rem;">${area.name}</span>
              ${otherZones.length > 0 ? `<select class="move-zone-select" onchange="moveAreaToZone(this, '${area.area_id}', '${escapedZoneName}')">
                <option value="" disabled selected>Move to\u2026</option>
                ${moveOptions}
              </select>` : ''}
            </div>
          `).join('');

          return `
            <div class="zone-group">
              <div class="edit-zone-header ${isCollapsed ? 'collapsed' : ''}" data-zone="${zoneName}"
                ondragover="onZoneHeaderDragOver(event)"
                ondragleave="onZoneHeaderDragLeave(event)"
                ondrop="onZoneHeaderDrop(event, '${escapedZoneName}')">
                <div class="edit-zone-arrows">
                  <button class="edit-zone-arrow" ${upDisabled} onclick="event.stopPropagation(); moveZone('${escapedZoneName}', -1)" title="Move up">&#9650;</button>
                  <button class="edit-zone-arrow" ${downDisabled} onclick="event.stopPropagation(); moveZone('${escapedZoneName}', 1)" title="Move down">&#9660;</button>
                </div>
                <span class="edit-zone-name" data-edit-zone-name="${zoneName}" onclick="event.stopPropagation(); toggleZone('${escapedZoneName}', this)">${zoneName}</span>
                <button class="edit-icon-btn default-star ${cachedGlozones?.zones?.[zoneName]?.is_default ? 'active' : ''}" onclick="event.stopPropagation(); setDefaultZone('${escapedZoneName}')" title="Default zone">&#9733;</button>
                <div class="edit-zone-actions">
                  <button class="edit-icon-btn" onclick="event.stopPropagation(); startRenameZone('${escapedZoneName}')" title="Rename">&#9998;</button>
                  <button class="edit-icon-btn danger" onclick="event.stopPropagation(); deleteZoneFromEdit('${escapedZoneName}')" title="Delete">&#128465;</button>
                </div>
              </div>
              <div class="zone-content ${isCollapsed ? 'hidden' : ''}" data-zone-table="${zoneName}"
                ondragover="onZoneContentDragOver(event, '${escapedZoneName}')"
                ondragleave="onZoneContentDragLeave(event)"
                ondrop="onZoneContentDrop(event, '${escapedZoneName}')">
                ${areaRows}
              </div>
            </div>
          `;
        }

        // Normal mode: zone header (no slider)
        let zoneHeaderStyle = '';
        let zoneTextColor = 'var(--text)';
        let zoneMismatchDot = '';
        let zoneFrozenIndicator = '';

        const zs = zoneStates[zoneName];
        if (zs) {
          const zoneBri = zs.brightness;
          const zoneKelvin = zs.kelvin;
          const cctColor = cctToRGB(zoneKelvin);
          const tintedColor = tintColorByBrightness(cctColor, zoneBri);
          zoneTextColor = readableTextColor(tintedColor);
          zoneHeaderStyle = `background: ${tintedColor}; color: ${zoneTextColor}; --header-fill: ${zoneBri / 100};`;
          if (allOff) {
            zoneHeaderStyle = '';
            zoneTextColor = 'var(--text)';
          }

          // Red dot: zone has been stepped or frozen away from pure rhythm
          const rs = zs.runtime_state;
          if (rs && (rs.brightness_mid != null || rs.color_mid != null || rs.frozen_at != null)) {
            zoneMismatchDot = `<span class="mismatch-dot-zone"></span>`;
          }

          // Frozen indicator on zone header
          if (rs && rs.frozen_at != null) {
            zoneFrozenIndicator = `<span class="row-status-sym timer-frozen">❄</span>`;
          }
        }

        // Power button: only show if one or more areas in zone have lights on
        const zoneOnAreas = sorted.filter(a => a.is_on);
        const zonePowerBtn = zoneOnAreas.length > 0
          ? `<div class="row-controls-left"><button class="row-btn active" onclick="event.stopPropagation(); confirmZonePowerOff('${escapedZoneName}')" title="Turn off all in '${zoneName}'">${powerIconSvg}</button></div>`
          : '';

        return `
          <div class="zone-group">
            <div class="zone-header ${isCollapsed ? 'collapsed' : ''} ${allOff ? 'no-tint' : ''}" data-zone="${zoneName}" style="${zoneHeaderStyle}" onclick="openZoneModal('${escapedZoneName}')">
              <span class="zone-chevron-tap" onclick="event.stopPropagation(); toggleZone('${escapedZoneName}', this)">${chevronIcon}</span>
              ${zonePowerBtn}
              <span style="font-size: 0.65rem; opacity: 0.5; color: ${zoneTextColor};">Glo Zone</span>
              <span class="zone-name" style="font-size: 1.05rem; color: ${zoneTextColor};">${zoneName}</span>
              ${zoneFrozenIndicator}
              ${zoneMismatchDot}
              <span style="flex: 1;"></span>
              <div class="row-controls">
                <button class="row-btn" onclick="event.stopPropagation(); glozoneReset('${escapedZoneName}')" title="Reset GloZone">${glozoneResetIcon}</button>
                <button class="row-btn" onclick="event.stopPropagation(); glozoneDown('${escapedZoneName}')" title="GloZone Down: send to all areas">${glozoneDownIcon}</button>
              </div>
            </div>
            <div class="zone-content ${isCollapsed ? 'hidden' : ''}" data-zone-table="${zoneName}">
              ${sorted.map(area => renderAreaRow(area)).join('')}
            </div>
          </div>
        `;
      };

      if (editMode) {
        // Edit mode: use glozone API order (preserves user ordering)
        const gzZonesObj = cachedGlozones?.zones || {};
        const gzZoneNames = Object.keys(gzZonesObj);
        const totalZones = gzZoneNames.length;

        // Build area list per zone from glozone data (preserves area order within zone)
        for (let i = 0; i < gzZoneNames.length; i++) {
          const zoneName = gzZoneNames[i];
          const gzData = gzZonesObj[zoneName];
          const zoneAreaIds = (gzData.areas || []).map(a => typeof a === 'object' ? a.id : a);
          const areasInZone = zoneAreaIds.map(id => mergedAreas.find(a => a.area_id === id)).filter(Boolean);
          html += renderZoneGroup(zoneName, areasInZone, i, totalZones);
        }

        // Unassigned areas at the end
        if (unassigned.length > 0) {
          html += renderZoneGroup('Unassigned', unassigned, totalZones, totalZones + 1);
        }

        // + New Zone at the bottom
        html += `<div style="text-align: center; padding: 16px 0;">
          <a href="#" onclick="event.preventDefault(); createZoneFromEdit()" style="font-size: 0.85rem; color: var(--accent); text-decoration: none;">+ New Zone</a>
        </div>`;
      } else if (viewMode === 'onoff') {
        // Group by on/off first, then by zone within each
        const onAreas = filtered.filter(a => a.is_on);
        const offAreas = filtered.filter(a => !a.is_on);

        const renderOnOffSection = (sectionAreas, allOff = false) => {
          if (sectionAreas.length === 0) return '';
          // Sub-group by zone
          const subGroups = {};
          const subUnassigned = [];
          for (const area of sectionAreas) {
            if (area.zone_name) {
              if (!subGroups[area.zone_name]) subGroups[area.zone_name] = [];
              subGroups[area.zone_name].push(area);
            } else {
              subUnassigned.push(area);
            }
          }
          // Use custom zone order from cachedGlozones, then any remaining
          const gzZoneNames = Object.keys(cachedGlozones?.zones || {});
          const subNames = gzZoneNames.filter(zn => subGroups[zn]);
          // Add any zones not in cachedGlozones (shouldn't happen, but safe)
          for (const zn of Object.keys(subGroups)) {
            if (!subNames.includes(zn)) subNames.push(zn);
          }
          let sectionHtml = '';
          for (const zn of subNames) {
            // Sort areas within zone by custom order
            const gzData = (cachedGlozones?.zones || {})[zn];
            const customOrder = gzData ? (gzData.areas || []).map(a => typeof a === 'object' ? a.id : a) : [];
            const sorted = customOrder.length > 0
              ? subGroups[zn].sort((a, b) => {
                  const ai = customOrder.indexOf(a.area_id);
                  const bi = customOrder.indexOf(b.area_id);
                  return (ai === -1 ? 999 : ai) - (bi === -1 ? 999 : bi);
                })
              : subGroups[zn];
            sectionHtml += renderZoneGroup(zn, sorted, undefined, undefined, { allOff });
          }
          if (subUnassigned.length > 0) {
            sectionHtml += renderZoneGroup('Unassigned', subUnassigned, undefined, undefined, { allOff });
          }
          return sectionHtml;
        };

        html += renderOnOffSection(onAreas, false);
        html += renderOnOffSection(offAreas, true);
      } else if (viewMode === 'custom') {
        // Custom: use API zone order (preserves user arrangement from edit mode)
        const gzZonesObj = cachedGlozones?.zones || {};
        const gzZoneNames = Object.keys(gzZonesObj);

        for (const zoneName of gzZoneNames) {
          const gzData = gzZonesObj[zoneName];
          const zoneAreaIds = (gzData.areas || []).map(a => typeof a === 'object' ? a.id : a);
          const areasInZone = zoneAreaIds.map(id => mergedAreas.find(a => a.area_id === id)).filter(Boolean);
          html += renderZoneGroup(zoneName, areasInZone);
        }
        if (unassigned.length > 0) {
          html += renderZoneGroup('Unassigned', unassigned);
        }
      } else {
        // Alpha: group by zone, sorted alphabetically
        for (const zoneName of zoneNames) {
          html += renderZoneGroup(zoneName, zoneGroups[zoneName]);
        }

        if (unassigned.length > 0) {
          html += renderZoneGroup('Unassigned', unassigned);
        }
      }

      // Handle empty state
      if (filtered.length === 0) {
        html = `
          <div style="text-align: center; padding: 48px; color: var(--muted);">
            ${mergedAreas.length > 0 ? 'No areas match the current filter.' : 'No areas found in Home Assistant.'}
          </div>
        `;
      }

      container.innerHTML = html;
      initRowSliders();
    }

    function renderAreaRow(area) {
      const status = areaStatus[area.area_id] || {};
      const isCircadian = status.is_circadian !== false;  // Default true if undefined

      // Circadian-off: muted row with enable CTA
      if (!isCircadian) {
        const sunIconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg>`;
        return `
          <div class="area-row circadian-off" onclick="event.stopPropagation(); rowAction('${area.area_id}', 'circadian_on')">
            <span class="area-row-name">${area.name}</span>
            <span class="circadian-enable-cta">${sunIconSvg} Enable</span>
          </div>
        `;
      }

      const style = getRowStyle(area);
      const statusSymbols = getStatusSymbols(area);
      const { leftControls, rightControls } = getRowControls(area);
      const sliderPct = getSliderPct(area.brightness || 0, area);

      return `
        <div class="area-row" style="--row-bg: ${style.bg}; --row-text: ${style.textColor}; --row-fill: ${style.fill.toFixed(3)};">
          ${leftControls}
          <div class="row-middle">
            <div class="row-middle-top">
              <span class="area-row-name" onclick="openAreaModal('${area.area_id}')">${area.name}</span>
              ${statusSymbols}
            </div>
            <div class="row-slider-track" data-area-id="${area.area_id}" data-bmin="${area.min_brightness ?? 1}" data-bmax="${area.max_brightness ?? 100}" data-cmin="${area.min_color_temp ?? 2200}" data-cmax="${area.max_color_temp ?? 6500}">
              <div class="row-slider-fill"></div>
              <div class="row-slider-thumb" style="left: ${sliderPct.toFixed(1)}%"></div>
            </div>
          </div>
          ${rightControls}
        </div>
      `;
    }

    function getStatusBadge(area) {
      if (!area.is_on) {
        return '<span class="status-badge status-off">Off</span>';
      }
      if (area.frozen) {
        return '<span class="status-badge status-frozen">Frozen</span>';
      }
      return '<span class="status-badge status-on">On</span>';
    }

    function getStatusSymbols(area) {
      const status = areaStatus[area.area_id] || {};
      const parts = [];

      // Motion active
      const hasMotion = status.motion_expires_at && status.motion_expires_at !== 'forever';
      if (hasMotion) {
        const warnClass = status.motion_warning_active ? ' timer-warning' : '';
        parts.push(`<span class="row-status-sym${warnClass}">M</span>`);
      }

      // Boosted
      const isBoosted = status.boosted || false;
      const isMotionCoupled = status.is_motion_coupled || false;
      if (isBoosted && !isMotionCoupled) {
        parts.push(`<span class="row-status-sym">B</span>`);
      } else if (isBoosted && isMotionCoupled && hasMotion) {
        // Combined motion+boost: just show M (already shown)
      }

      // Frozen
      if (area.frozen) {
        parts.push(`<span class="row-status-sym timer-frozen">❄</span>`);
      }

      // Mismatch dot
      if (area.zone_name && zoneStates[area.zone_name]) {
        const rs = zoneStates[area.zone_name].runtime_state || {};
        const tol = 0.1;
        const differs = (a, b) => {
          if (a == null && b == null) return false;
          if (a == null || b == null) return true;
          return Math.abs(a - b) >= tol;
        };
        if (differs(area.brightness_mid, rs.brightness_mid) ||
            differs(area.color_mid, rs.color_mid) ||
            differs(area.frozen_at, rs.frozen_at) ||
            area.color_override != null) {
          parts.push(`<span class="mismatch-dot-area"></span>`);
        }
      }

      return parts.join('');
    }

    function getSliderPct(brightness, area) {
      // Use area's effective min/max from its rhythm
      const bMin = area?.min_brightness ?? 1;
      const bMax = area?.max_brightness ?? 100;
      return bMax > bMin ? Math.max(0, Math.min(100, (brightness - bMin) / (bMax - bMin) * 100)) : 0;
    }

    function getRowStyle(area) {
      if (!area.is_on) {
        return { bg: 'var(--card)', fill: 0, textColor: 'var(--muted)' };
      }
      const cctColor = cctToRGB(area.kelvin);
      const tintedColor = tintColorByBrightness(cctColor, area.brightness);
      const textColor = readableTextColor(tintedColor);
      const fill = area.brightness / 100;
      return { bg: tintedColor, fill, textColor };
    }

    function getRowControls(area) {
      const isOn = area.is_on;

      // Power icon
      const powerIconSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <path d="M18.36 6.64a9 9 0 1 1-12.73 0M12 2v10"/>
      </svg>`;

      const leftControls = `
        <div class="row-controls-left">
          <button class="row-btn ${isOn ? 'active' : ''}" onclick="event.stopPropagation(); rowAction('${area.area_id}', 'lights_toggle')" title="Power">${powerIconSvg}</button>
        </div>
      `;

      // GloUp icon (chevron up + line on bottom)
      const gloUpSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="5 13 12 6 19 13"/>
        <line x1="4" y1="19" x2="20" y2="19"/>
      </svg>`;

      // GloDown icon (line on top + chevron down)
      const gloDownSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <line x1="4" y1="5" x2="20" y2="5"/>
        <polyline points="5 11 12 18 19 11"/>
      </svg>`;

      // Reset icon (rewind arrow)
      const resetSvg = `<svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
        <polyline points="1 4 1 10 7 10"/>
        <path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/>
      </svg>`;

      const rightControls = `
        <div class="row-controls">
          <button class="row-btn" onclick="event.stopPropagation(); rowAction('${area.area_id}', 'glo_up')" title="GloUp: send to '${area.zone_name || 'Glo Zone'}'">${gloUpSvg}</button>
          <button class="row-btn" onclick="event.stopPropagation(); rowAction('${area.area_id}', 'glo_down')" title="GloDown: pull from '${area.zone_name || 'Glo Zone'}'">${gloDownSvg}</button>
          <button class="row-btn" onclick="event.stopPropagation(); rowAction('${area.area_id}', 'glo_reset')" title="Reset: return to rhythm">${resetSvg}</button>
        </div>
      `;

      return { leftControls, rightControls };
    }

    function toggleToolbarMenu(event) {
      event.stopPropagation();
      const dd = document.getElementById('toolbar-menu-dropdown');
      if (dd) dd.classList.toggle('visible');
    }

    function setupEventListeners() {
      // Close toolbar menu when clicking outside
      document.addEventListener('click', () => {
        const dd = document.getElementById('toolbar-menu-dropdown');
        if (dd) dd.classList.remove('visible');
      });
      document.getElementById('areas-container').addEventListener('click', (e) => {
        if (e.target.id === 'refresh-link') { e.preventDefault(); loadData(); }
        if (e.target.id === 'organize-link') { e.preventDefault(); enterEditMode(); }
        if (e.target.id === 'add-zone-link') { e.preventDefault(); createZoneFromEdit(); }
      });

      // View mode pill clicks
      document.getElementById('areas-container').addEventListener('click', (e) => {
        if (e.target.classList.contains('view-link') && !e.target.classList.contains('active')) {
          viewMode = e.target.dataset.view;
          savePreferences();
          renderAreas();
        }
      });

      // Close rhythm dropdowns when clicking outside
      document.addEventListener('click', (e) => {
        if (!e.target.closest('.zone-rhythm-display')) {
          document.querySelectorAll('.zone-rhythm-dropdown.visible').forEach(d => {
            d.classList.remove('visible');
          });
        }
      });
    }

    // Navigation to detail pages
    function openAreaModal(areaId) {
      window.location.href = './area/' + encodeURIComponent(areaId);
    }

    function openZoneModal(zoneName) {
      window.location.href = './zone/' + encodeURIComponent(zoneName);
    }

    async function rowAction(areaId, action, value, mode) {
      try {
        const body = { area_id: areaId, action: action };
        if (value !== undefined) { body.value = value; body.mode = mode || 'step'; }
        const response = await fetch('./api/area/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body)
        });

        if (response.ok) {
          // Re-fetch area status + zone states and update table
          setTimeout(async () => {
            try {
              const [statusRes, zsRes] = await Promise.all([
                fetch('./api/area-status'),
                fetch('./api/zone-states')
              ]);
              if (statusRes.ok) {
                areaStatus = await statusRes.json();
              }
              if (zsRes.ok) {
                const zs = await zsRes.json();
                zoneStates = zs.zone_states || {};
              }
              sliderDragging = false;
              renderAreas();
            } catch (err) {
              sliderDragging = false;
              console.error('Error refreshing after row action:', err);
            }
          }, 500);
        } else {
          sliderDragging = false;
          const error = await response.json();
          console.error('Row action failed:', error);
        }
      } catch (err) {
        sliderDragging = false;
        console.error('Error executing row action:', err);
      }
    }

    // ============================================================
    // Row Slider Pointer Handlers (with live row color preview)
    // ============================================================

    function colorAtPct(pct, track) {
      // pct is slider position 0-100; use track's per-area range
      const bMin = parseFloat(track?.dataset?.bmin) || 1;
      const bMax = parseFloat(track?.dataset?.bmax) || 100;
      const cMin = parseFloat(track?.dataset?.cmin) || 2200;
      const cMax = parseFloat(track?.dataset?.cmax) || 6500;
      const frac = pct / 100;
      const brightness = bMin + (bMax - bMin) * frac;
      const kelvin = cMin + (cMax - cMin) * frac;
      return { brightness, kelvin };
    }

    function previewRowColor(row, pct, track) {
      const { brightness, kelvin } = colorAtPct(pct, track);
      const cctColor = cctToRGB(kelvin);
      const tinted = tintColorByBrightness(cctColor, brightness);
      const textColor = readableTextColor(tinted);
      row.style.setProperty('--row-bg', tinted);
      row.style.setProperty('--row-text', textColor);
      row.style.setProperty('--row-fill', (brightness / 100).toFixed(3));
      row.style.color = textColor;
    }

    function initRowSliders() {
      document.querySelectorAll('.row-slider-track').forEach(track => {
        const row = track.closest('.area-row');
        if (!row) return;

        track.addEventListener('pointerdown', (e) => {
          e.stopPropagation();
          e.preventDefault();
          sliderDragging = true;
          track.setPointerCapture(e.pointerId);
          track.classList.add('dragging');
          updateSliderFromPointer(track, e);
          previewRowColor(row, getSliderPctFromPointer(track, e), track);
        });
        track.addEventListener('pointermove', (e) => {
          if (!track.hasPointerCapture(e.pointerId)) return;
          e.stopPropagation();
          updateSliderFromPointer(track, e);
          previewRowColor(row, getSliderPctFromPointer(track, e), track);
        });
        track.addEventListener('pointerup', (e) => {
          if (!track.hasPointerCapture(e.pointerId)) return;
          e.stopPropagation();
          // sliderDragging stays true — cleared by rowAction's refresh callback
          // so periodic refreshes don't snap the slider back to stale data
          track.classList.remove('dragging');
          const pct = getSliderPctFromPointer(track, e);
          const areaId = track.dataset.areaId;
          if (areaId) rowAction(areaId, 'set_position', Math.round(pct), 'step');
          else sliderDragging = false; // no action to clear it, clear now
        });
        track.addEventListener('pointercancel', (e) => {
          sliderDragging = false;
          track.classList.remove('dragging');
        });
        // Prevent click from bubbling to row's onclick (which opens detail page)
        track.addEventListener('click', (e) => {
          e.stopPropagation();
        });
      });
    }

    function getSliderPctFromPointer(track, e) {
      const rect = track.getBoundingClientRect();
      return Math.max(0, Math.min(100, (e.clientX - rect.left) / rect.width * 100));
    }

    function updateSliderFromPointer(track, e) {
      const pct = getSliderPctFromPointer(track, e);
      track.querySelector('.row-slider-thumb').style.left = pct + '%';
    }

  </script>
</body>
</html>
