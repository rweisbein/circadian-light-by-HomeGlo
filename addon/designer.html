<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Circadian Light by HomeGlo</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<style>
:root {
  --bg: #000;
  --panel: #181818;
  --panel2: #252525;
  --text: #e6e6e6;
  --muted: #bbb;
  --muted2: #aaa;
  --line: #333;
  --line2: #2c2c2c;
  --grid: #202020;
  --accent: #1e90ff;
  --ascend: rgba(120, 190, 255, 0.32);
  --ascend-border: rgba(120, 185, 245, 0.5);
  --descend: #111;
  --descend-border: rgba(255, 230, 128, 0.45);
}
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
body { padding: 20px; }
h1 { margin: 0 0 18px; font-size: 28px; font-weight: 600; }
h2 { margin: 0 0 12px; font-size: 1.1rem; font-weight: 600; }

.container { max-width: 1200px; margin: 0 auto; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
.header-actions { display: flex; gap: 12px; align-items: center; }

/* Activity Preset */
.activity-select { margin-bottom: 16px; }
.activity-select select {
  width: 100%;
  max-width: 300px;
  font-size: 1rem;
  padding: 10px 14px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(255,255,255,0.06);
  color: #fff;
}

/* Section Blocks */
.section-block {
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 16px;
  margin-bottom: 16px;
}
.section-block--ascend {
  background: var(--ascend);
  border-color: var(--ascend-border);
}
.section-block--ascend h2 { color: #7ec8ff; }
.section-block--descend {
  background: var(--descend);
  border-color: var(--descend-border);
}
.section-block--descend h2 { color: #ffd47a; }

/* Timing Grid */
.timing-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}
@media (max-width: 768px) {
  .timing-grid { grid-template-columns: 1fr; }
}

/* Parameter Rows */
.param-row {
  display: grid;
  grid-template-columns: 140px 80px 1fr;
  align-items: center;
  gap: 12px;
  margin: 10px 0;
}
.param-row label {
  font-size: 0.9rem;
  color: var(--muted);
  font-weight: 600;
}
.param-row .value {
  font-size: 0.95rem;
  font-weight: 600;
  color: var(--text);
  text-align: right;
}

/* Sliders */
input[type=range] {
  width: 100%;
  background: transparent;
  appearance: none;
  height: 20px;
  padding: 0;
  margin: 0;
}
input[type=range]:focus { outline: none; }
input[type=range]::-webkit-slider-runnable-track {
  height: 4px;
  background: rgba(255,255,255,0.3);
  border-radius: 2px;
}
input[type=range]::-moz-range-track {
  height: 4px;
  background: rgba(255,255,255,0.3);
  border-radius: 2px;
}
input[type=range]::-webkit-slider-thumb {
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid rgba(0,0,0,0.3);
  margin-top: -6px;
  cursor: pointer;
}
input[type=range]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid rgba(0,0,0,0.3);
  cursor: pointer;
}

/* Chart Section */
.chart-wrapper { position: relative; }
#chart { height: 450px; }
.chart-date-control {
  display: flex;
  align-items: center;
  gap: 12px;
  margin-bottom: 8px;
}
.chart-date-display {
  font-size: 0.95rem;
  color: var(--text);
  min-width: 80px;
  font-weight: 600;
}

/* Time hover label - at top of chart, shows time with phase color */
.time-hover-label {
  position: absolute;
  top: 10px;
  padding: 4px 9px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.3);
  background: rgba(5,5,5,0.88);
  color: #fff;
  font-size: 0.75rem;
  font-weight: 600;
  pointer-events: none;
  transform: translateX(-50%);
  opacity: 0;
  transition: opacity 0.12s ease, left 0.08s ease;
  white-space: nowrap;
  box-shadow: 0 4px 10px rgba(0,0,0,0.35);
  z-index: 100;
}

/* Cursor callout - shows values at cursor position */
.graph-cursor-callout {
  position: absolute;
  padding: 4px 10px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(10,10,10,0.85);
  color: #fff;
  font-size: 0.78rem;
  font-weight: 600;
  pointer-events: none;
  transform: translateX(-50%);
  opacity: 0;
  transition: opacity 0.12s ease, left 0.08s ease;
  white-space: nowrap;
  z-index: 100;
}

/* Cursor Controls */
.cursor-controls {
  display: flex;
  justify-content: center;
  gap: 60px;
  margin-top: 16px;
  padding-top: 16px;
  border-top: 1px solid var(--line);
}
.cursor-controls.hidden { display: none; }
.cursor-stack {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 8px;
}
.cursor-stack-label {
  font-size: 0.85rem;
  color: var(--muted);
  text-transform: uppercase;
  letter-spacing: 0.05em;
}
.cursor-btn-row {
  display: flex;
  gap: 8px;
}
.cursor-btn {
  border: 1px solid rgba(255,255,255,0.3);
  background: rgba(255,255,255,0.06);
  color: #fff;
  font-size: 1.1rem;
  font-weight: 600;
  padding: 8px 20px;
  border-radius: 999px;
  cursor: pointer;
  transition: all 0.15s;
}
.cursor-btn:hover {
  border-color: rgba(255,255,255,0.5);
  background: rgba(255,255,255,0.1);
}
.cursor-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}

/* Dual Range Slider */
.dual-range {
  position: relative;
  display: flex;
  align-items: center;
  gap: 8px;
}
.dual-track {
  position: relative;
  flex: 1;
  height: 6px;
  background: rgba(255,255,255,0.3);
  border-radius: 3px;
}
.dual-track.color-track {
  height: 8px;
  border-radius: 4px;
}
.dual-fill {
  position: absolute;
  top: 0;
  height: 100%;
  background: var(--accent);
  border-radius: inherit;
  pointer-events: none;
}
.dual-mask {
  position: absolute;
  top: 0;
  height: 100%;
  background: rgba(0,0,0,0.7);
  pointer-events: none;
}
.dual-range input[type=range] {
  position: absolute;
  width: 100%;
  background: transparent;
}
.dual-chip {
  font-size: 0.85rem;
  color: var(--muted);
  min-width: 60px;
}
.dual-chip.right { text-align: right; }

/* Color Value Chip Button */
.color-value-chip {
  border: none;
  border-radius: 999px;
  padding: 6px 14px;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  min-width: 80px;
  text-align: center;
}
.color-value-chip:hover {
  filter: brightness(1.1);
}

/* Color Slider Popup */
.color-controls-wrap {
  position: relative;
  display: inline-block;
}
.color-slider-popup {
  position: absolute;
  top: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: #101010;
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 10px;
  padding: 12px 14px;
  box-shadow: 0 12px 24px rgba(0,0,0,0.45);
  min-width: 280px;
  display: none;
  z-index: 50;
}
.color-slider-popup.is-open {
  display: block;
}
.color-slider-popup .dual-track {
  height: 10px;
  border-radius: 5px;
}
.color-slider-popup input[type=range] {
  height: 20px;
}

/* Offset Slider Rows */
.offset-slider-row {
  display: grid;
  grid-template-columns: 60px 1fr 140px;
  gap: 10px;
  align-items: center;
  margin: 8px 0;
}
.offset-slider-row label {
  font-size: 0.8rem;
  color: var(--muted2);
  text-transform: lowercase;
}
.offset-slider-row .offset-text {
  font-size: 0.75rem;
  color: var(--muted);
}

/* Solar Rules */
.solar-rule {
  display: flex;
  flex-direction: column;
  gap: 12px;
  padding: 16px 0;
  border-bottom: 1px solid var(--line);
}
.solar-rule:last-child { border-bottom: none; }
.solar-rule-header {
  display: flex;
  align-items: center;
  gap: 16px;
}
.solar-rule-title {
  font-size: 1rem;
  font-weight: 600;
  color: var(--text);
}
.solar-rule-toggle {
  display: flex;
  align-items: center;
  gap: 6px;
}
.solar-rule-toggle input[type=checkbox] {
  width: 16px;
  height: 16px;
  accent-color: #7CFF72;
}
.solar-rule-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 12px;
  align-items: center;
}
.solar-rule-controls select {
  padding: 6px 10px;
  border-radius: 8px;
  border: 1px solid var(--line);
  background: var(--panel2);
  color: var(--text);
  font-size: 0.9rem;
}
.solar-rule-offsets {
  display: flex;
  flex-direction: column;
  gap: 8px;
  padding-left: 12px;
  border-left: 2px solid rgba(255,255,255,0.1);
  margin-left: 8px;
}


/* Buttons */
.btn {
  border: 1px solid rgba(255,255,255,0.3);
  background: rgba(255,255,255,0.1);
  color: #fff;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.9rem;
  transition: all 0.15s;
}
.btn:hover { background: rgba(255,255,255,0.15); }
.btn-primary {
  background: var(--accent);
  border-color: var(--accent);
}
.btn-primary:hover { filter: brightness(1.1); }

/* Status Messages */
.success {
  color: #51cf66;
  font-size: 0.9rem;
  margin: 10px 0;
  padding: 12px 16px;
  background: rgba(81,207,102,0.15);
  border: 1px solid rgba(81,207,102,0.3);
  border-radius: 8px;
  font-weight: 600;
}
.error {
  color: #ff6b6b;
  font-size: 0.9rem;
  margin: 10px 0;
  padding: 12px 16px;
  background: rgba(255,107,107,0.15);
  border: 1px solid rgba(255,107,107,0.3);
  border-radius: 8px;
  font-weight: 600;
}

/* Responsive */
@media (max-width: 640px) {
  .param-row { grid-template-columns: 1fr; gap: 4px; }
  .cursor-controls { flex-wrap: wrap; gap: 24px; }
  .solar-rule { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>Circadian Light by HomeGlo</h1>
    <div class="header-actions">
      <button id="save-config" class="btn btn-primary">Save Configuration</button>
    </div>
  </div>
  <div id="save-status"></div>

  <!-- Activity Preset -->
  <div class="activity-select">
    <label for="activity-preset">Activity Preset</label>
    <select id="activity-preset">
      <option value="young">Young Child</option>
      <option value="adult" selected>Adult</option>
      <option value="nightowl">Night Owl</option>
      <option value="duskbat">Dusk Bat</option>
      <option value="shiftearly">Early Shift Worker</option>
      <option value="shiftlate">Late Shift Worker</option>
    </select>
  </div>

  <!-- Ascend/Descend Timing -->
  <div class="timing-grid">
    <div class="section-block section-block--ascend">
      <h2>Ascend</h2>
      <div class="param-row">
        <label>Ascend starts</label>
        <span class="value" id="ascend-start-display">3:00a</span>
        <input type="range" id="ascend-start" min="0" max="24" step="0.5" value="3">
      </div>
      <div class="param-row">
        <label>Wake time</label>
        <span class="value" id="wake-time-display">6:00a</span>
        <input type="range" id="wake-time" min="0" max="24" step="0.5" value="6">
      </div>
      <div class="param-row">
        <label>Wake speed</label>
        <span class="value" id="wake-speed-display">Fast (8)</span>
        <input type="range" id="wake-speed" min="1" max="10" step="1" value="8">
      </div>
    </div>

    <div class="section-block section-block--descend">
      <h2>Descend</h2>
      <div class="param-row">
        <label>Descend starts</label>
        <span class="value" id="descend-start-display">12:00p</span>
        <input type="range" id="descend-start" min="0" max="36" step="0.5" value="12">
      </div>
      <div class="param-row">
        <label>Bed time</label>
        <span class="value" id="bed-time-display">10:00p</span>
        <input type="range" id="bed-time" min="0" max="36" step="0.5" value="22">
      </div>
      <div class="param-row">
        <label>Bed speed</label>
        <span class="value" id="bed-speed-display">Crisp (6)</span>
        <input type="range" id="bed-speed" min="1" max="10" step="1" value="6">
      </div>
    </div>
  </div>

  <!-- Chart -->
  <div class="section-block">
    <div class="chart-date-control">
      <span class="chart-date-display" id="chart-date-display">Today</span>
      <input type="range" id="chart-date-slider" min="0" max="364" value="0" style="flex:1">
    </div>
    <div class="chart-wrapper">
      <div id="chart"></div>
      <div class="time-hover-label" id="time-hover-label"></div>
      <div class="graph-cursor-callout" id="cursor-callout"></div>
    </div>

    <!-- Cursor Controls -->
    <div class="cursor-controls hidden" id="cursor-controls">
      <div class="cursor-stack">
        <span class="cursor-stack-label">Step</span>
        <div class="cursor-btn-row">
          <button class="cursor-btn" id="cursor-step-up" title="Step Up">↑</button>
          <button class="cursor-btn" id="cursor-step-down" title="Step Down">↓</button>
        </div>
      </div>
      <div class="cursor-stack">
        <span class="cursor-stack-label">Bright</span>
        <div class="cursor-btn-row">
          <button class="cursor-btn" id="cursor-bright-up" title="Brighten">↑</button>
          <button class="cursor-btn" id="cursor-bright-down" title="Dim">↓</button>
        </div>
      </div>
      <div class="cursor-stack">
        <span class="cursor-stack-label">Color</span>
        <div class="cursor-btn-row">
          <button class="cursor-btn" id="cursor-color-up" title="Cooler">↑</button>
          <button class="cursor-btn" id="cursor-color-down" title="Warmer">↓</button>
        </div>
      </div>
      <div class="cursor-stack">
        <button class="btn" id="cursor-reset">Reset</button>
      </div>
    </div>
  </div>

  <!-- Brightness & Color Range -->
  <div class="section-block">
    <h2>Brightness &amp; Color</h2>

    <div class="param-row" style="grid-template-columns: 140px 60px 1fr 60px;">
      <label>Color range</label>
      <span class="dual-chip" id="color-min-display">500 K</span>
      <div class="dual-range">
        <div class="dual-track color-track" id="color-track">
          <div class="dual-mask" id="color-mask-left"></div>
          <div class="dual-mask" id="color-mask-right"></div>
        </div>
        <input type="range" id="color-min" min="500" max="6500" step="100" value="500">
        <input type="range" id="color-max" min="500" max="6500" step="100" value="6500">
      </div>
      <span class="dual-chip right" id="color-max-display">6500 K</span>
    </div>

    <div class="param-row" style="grid-template-columns: 140px 60px 1fr 60px;">
      <label>Brightness range</label>
      <span class="dual-chip" id="brightness-min-display">1%</span>
      <div class="dual-range">
        <div class="dual-track">
          <div class="dual-fill" id="brightness-fill"></div>
        </div>
        <input type="range" id="brightness-min" min="1" max="100" step="1" value="1">
        <input type="range" id="brightness-max" min="1" max="100" step="1" value="100">
      </div>
      <span class="dual-chip right" id="brightness-max-display">100%</span>
    </div>

    <div class="param-row">
      <label>Step increments</label>
      <span class="value" id="step-count-display">10 steps</span>
      <input type="range" id="step-count" min="1" max="50" step="1" value="10">
    </div>
  </div>

  <!-- Solar Color Rules -->
  <div class="section-block">
    <h2>Solar Color Rules</h2>

    <div class="solar-rule">
      <div class="solar-rule-header">
        <span class="solar-rule-title">Warm at night</span>
        <div class="solar-rule-toggle">
          <input type="checkbox" id="warm-night-enabled">
          <label for="warm-night-enabled">Enable</label>
        </div>
      </div>
      <div class="solar-rule-controls">
        <select id="warm-night-mode">
          <option value="all">All night</option>
          <option value="sunrise">Before sunrise</option>
          <option value="sunset">After sunset</option>
        </select>
        <div class="color-controls-wrap">
          <button type="button" class="color-value-chip" id="warm-night-target-chip">2700 K</button>
          <div class="color-slider-popup" id="warm-night-popup">
            <div class="dual-range">
              <div class="dual-track color-track" id="warm-night-track"></div>
              <input type="range" id="warm-night-target" min="500" max="4000" step="100" value="2700">
            </div>
          </div>
        </div>
      </div>
      <div class="solar-rule-offsets" id="warm-night-offsets">
        <div class="offset-slider-row" data-window="sunset">
          <label>Start</label>
          <input type="range" id="warm-night-start" min="-180" max="180" step="5" value="-60">
          <span class="offset-text" id="warm-night-start-text">60 min before sunset</span>
        </div>
        <div class="offset-slider-row" data-window="sunrise">
          <label>End</label>
          <input type="range" id="warm-night-end" min="-180" max="180" step="5" value="60">
          <span class="offset-text" id="warm-night-end-text">60 min after sunrise</span>
        </div>
        <div class="offset-slider-row">
          <label>Fade</label>
          <input type="range" id="warm-night-fade" min="0" max="180" step="5" value="60">
          <span class="offset-text" id="warm-night-fade-text">60 min</span>
        </div>
      </div>
    </div>

    <div class="solar-rule">
      <div class="solar-rule-header">
        <span class="solar-rule-title">Cool during day</span>
        <div class="solar-rule-toggle">
          <input type="checkbox" id="cool-day-enabled">
          <label for="cool-day-enabled">Enable</label>
        </div>
      </div>
      <div class="solar-rule-controls">
        <select id="cool-day-mode">
          <option value="all">All day</option>
          <option value="sunrise">After sunrise</option>
          <option value="sunset">Before sunset</option>
        </select>
        <div class="color-controls-wrap">
          <button type="button" class="color-value-chip" id="cool-day-target-chip">6500 K</button>
          <div class="color-slider-popup" id="cool-day-popup">
            <div class="dual-range">
              <div class="dual-track color-track" id="cool-day-track"></div>
              <input type="range" id="cool-day-target" min="4000" max="6500" step="100" value="6500">
            </div>
          </div>
        </div>
      </div>
      <div class="solar-rule-offsets" id="cool-day-offsets">
        <div class="offset-slider-row" data-window="sunrise">
          <label>Start</label>
          <input type="range" id="cool-day-start" min="-180" max="180" step="5" value="0">
          <span class="offset-text" id="cool-day-start-text">at sunrise</span>
        </div>
        <div class="offset-slider-row" data-window="sunset">
          <label>End</label>
          <input type="range" id="cool-day-end" min="-180" max="180" step="5" value="0">
          <span class="offset-text" id="cool-day-end-text">at sunset</span>
        </div>
        <div class="offset-slider-row">
          <label>Fade</label>
          <input type="range" id="cool-day-fade" min="0" max="180" step="5" value="60">
          <span class="offset-text" id="cool-day-fade-text">60 min</span>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// ============================================================
// Circadian Light Designer - Ascend/Descend Model
// ============================================================

const GRAPH_Y_MAX = 150;
const SPEED_LABELS = ['', 'Calm', 'Gentle', 'Soft', 'Smooth', 'Balanced', 'Crisp', 'Fast', 'Snappy', 'Quick', 'Sharp'];
const SPEED_TO_SLOPE = [0, 0.4, 0.6, 0.8, 1.0, 1.3, 1.7, 2.3, 3.0, 4.0, 5.5];

// Colors matching llm_access.html
const ASCEND_COLORS = {
  shade: 'rgba(120,190,255,0.35)',
  text: '#5cb3ff',
  boundary: 'rgba(120,185,245,0.55)',
  axis: '#5cb3ff',
  hoverBg: '#7fc7ff'
};
const DESCEND_COLORS = {
  shade: 'rgba(25,25,25,0.7)',
  text: '#ffe680',
  boundary: 'rgba(255,230,128,0.85)',
  axis: 'rgba(255,230,128,0.7)',
  hoverBg: '#2b2b2b'
};

// Activity Presets
const ACTIVITY_PRESETS = {
  young: { wake_time: 6.0, bed_time: 18.0, ascend_start: 0.0, descend_start: 12.0 },
  adult: { wake_time: 6.0, bed_time: 22.0, ascend_start: 4.0, descend_start: 12.0 },
  nightowl: { wake_time: 10.0, bed_time: 2.0, ascend_start: 8.0, descend_start: 16.0 },
  duskbat: { wake_time: 14.0, bed_time: 6.0, ascend_start: 12.0, descend_start: 20.0 },
  shiftearly: { wake_time: 18.0, bed_time: 10.0, ascend_start: 16.0, descend_start: 0.0 },
  shiftlate: { wake_time: 22.0, bed_time: 14.0, ascend_start: 20.0, descend_start: 4.0 }
};

// State
let config = {
  ascend_start: 3.0,
  descend_start: 12.0,
  wake_time: 6.0,
  bed_time: 22.0,
  wake_speed: 8,
  bed_speed: 6,
  min_color_temp: 500,
  max_color_temp: 6500,
  min_brightness: 1,
  max_brightness: 100,
  max_dim_steps: 10,
  warm_night_enabled: false,
  warm_night_mode: 'all',
  warm_night_target: 2700,
  warm_night_start: -60,  // minutes offset from sunset (negative = before)
  warm_night_end: 60,     // minutes offset from sunrise (positive = after)
  warm_night_fade: 60,    // fade duration in minutes
  cool_day_enabled: false,
  cool_day_mode: 'all',
  cool_day_target: 6500,
  cool_day_start: 0,      // minutes offset from sunrise
  cool_day_end: 0,        // minutes offset from sunset
  cool_day_fade: 60,      // fade duration in minutes
  activity_preset: 'adult',
  latitude: 35.0,
  longitude: -78.6,
  timezone: 'US/Eastern'
};

// Current sun times (cached for solar rules)
let sunTimes = { sunrise: 6, sunset: 18, solarNoon: 12, solarMid: 0 };

// Runtime midpoints (can diverge from base wake/bed times)
let runtimeState = {
  brightness_wake_mid: null,
  brightness_bed_mid: null,
  color_wake_mid: null,
  color_bed_mid: null
};

// Cursor state
let cursorHour = null;
let graphData = null;

// ============================================================
// Solar Calculation Helpers
// ============================================================

const rad = d => d * Math.PI / 180;

function wrap24(x) {
  return ((x % 24) + 24) % 24;
}

function dayOfYear(dateStr) {
  const d = new Date(dateStr + 'T12:00:00');
  const s = new Date(d.getFullYear(), 0, 0);
  return Math.floor((d - s) / 86400000);
}

function solarDeclination(doy) {
  return (23.44 * Math.PI / 180) * Math.sin(2 * Math.PI * (284 + doy) / 365);
}

function getSunTimes(lat, lon, dateStr) {
  const date = new Date(dateStr || new Date().toISOString());
  const n = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
  const J = n + ((lon < 0 ? 360 + lon : lon) / 360);
  const M = (357.5291 + 0.9856 * J) % 360;
  const C = 1.9148 * Math.sin(rad(M)) + 0.02 * Math.sin(rad(2 * M)) + 0.0003 * Math.sin(rad(3 * M));
  const L = (M + 102.9372 + C + 180) % 360;
  const D = Math.asin(Math.sin(rad(L)) * Math.sin(rad(23.44)));
  const cosH0 = (Math.cos(rad(90.833)) - Math.sin(rad(lat)) * Math.sin(D)) / (Math.cos(rad(lat)) * Math.cos(D));

  if (cosH0 < -1 || cosH0 > 1) {
    const sn = 12 - date.getTimezoneOffset() / 60 - (lon / 15);
    return { sunrise: sn - 6, sunset: sn + 6, solarNoon: sn, solarMid: (sn + 12) % 24 };
  }

  const H0 = Math.acos(cosH0);
  const dl = (2 * H0 * 180 / Math.PI) / 15;
  const tz = -date.getTimezoneOffset() / 60;
  const sn = 12 + tz - (lon / 15);
  return { sunrise: sn - dl / 2, sunset: sn + dl / 2, solarNoon: sn, solarMid: (sn + 12) % 24 };
}

function getSelectedDateISO() {
  const slider = document.getElementById('chart-date-slider');
  const dayOffset = slider ? parseInt(slider.value) : 0;
  const now = new Date();
  const target = new Date(now.getFullYear(), 0, 1 + dayOffset);
  return target.toISOString().split('T')[0];
}

// ============================================================
// Color Helpers
// ============================================================

function cctToRGB(k) {
  k = Math.max(500, Math.min(10000, k));
  const t = k / 100;
  let r, g, b;

  if (t <= 66) {
    r = 255;
    g = 99.47 * Math.log(t) - 161.12;
    b = t <= 19 ? 0 : 138.52 * Math.log(t - 10) - 305.04;
  } else {
    r = 329.7 * Math.pow(t - 60, -0.133);
    g = 288.12 * Math.pow(t - 60, -0.075);
    b = 255;
  }

  const s = (k - 5000) / 5000;
  const blueBoost = 1 + 0.8 * Math.max(0, s);
  const redDamp = 1 - 0.4 * Math.max(0, s);
  r = Math.max(0, Math.min(255, r * redDamp));
  g = Math.max(0, Math.min(255, g));
  b = Math.max(0, Math.min(255, b * blueBoost));
  return `rgb(${r | 0},${g | 0},${b | 0})`;
}

function colorWithAlpha(rgb, alpha) {
  const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
  if (match) {
    return `rgba(${match[1]},${match[2]},${match[3]},${alpha})`;
  }
  return rgb;
}

function readableTextColor(bgColor) {
  const match = bgColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
  if (!match) return '#fff';
  const r = parseInt(match[1]);
  const g = parseInt(match[2]);
  const b = parseInt(match[3]);
  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return luminance > 0.5 ? '#000' : '#fff';
}

// Generate color gradient for slider tracks
function updateColorGradients() {
  const minK = config.min_color_temp;
  const maxK = config.max_color_temp;
  const steps = 16;

  // Main color track
  const colorTrack = document.getElementById('color-track');
  if (colorTrack) {
    const stops = [];
    for (let i = 0; i <= steps; i++) {
      const k = 500 + (6000 * i / steps);
      stops.push(`${cctToRGB(k)} ${(i / steps) * 100}%`);
    }
    colorTrack.style.background = `linear-gradient(90deg, ${stops.join(',')})`;

    // Update masks
    const maskLeft = document.getElementById('color-mask-left');
    const maskRight = document.getElementById('color-mask-right');
    if (maskLeft && maskRight) {
      const leftPct = ((minK - 500) / 6000) * 100;
      const rightPct = ((maxK - 500) / 6000) * 100;
      maskLeft.style.left = '0%';
      maskLeft.style.width = `${leftPct}%`;
      maskRight.style.left = `${rightPct}%`;
      maskRight.style.width = `${100 - rightPct}%`;
    }
  }

  // Warm night track
  const warmTrack = document.getElementById('warm-night-track');
  if (warmTrack) {
    const stops = [];
    for (let i = 0; i <= steps; i++) {
      const k = minK + ((maxK - minK) * i / steps);
      stops.push(`${cctToRGB(k)} ${(i / steps) * 100}%`);
    }
    warmTrack.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
  }

  // Cool day track
  const coolTrack = document.getElementById('cool-day-track');
  if (coolTrack) {
    const stops = [];
    for (let i = 0; i <= steps; i++) {
      const k = minK + ((maxK - minK) * i / steps);
      stops.push(`${cctToRGB(k)} ${(i / steps) * 100}%`);
    }
    coolTrack.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
  }

  // Update target chips
  updateColorChips();
}

function updateColorChips() {
  const warmChip = document.getElementById('warm-night-target-chip');
  if (warmChip) {
    const k = config.warm_night_target;
    warmChip.textContent = `${k} K`;
    warmChip.style.background = cctToRGB(k);
    warmChip.style.color = readableTextColor(cctToRGB(k));
  }

  const coolChip = document.getElementById('cool-day-target-chip');
  if (coolChip) {
    const k = config.cool_day_target;
    coolChip.textContent = `${k} K`;
    coolChip.style.background = cctToRGB(k);
    coolChip.style.color = readableTextColor(cctToRGB(k));
  }
}

// Apply solar color rules to CCT curve
function adjustCCTForSolarRules(cctArray, hoursArray, sunrise, sunset) {
  const rules = [];

  // Warm at night rule
  if (config.warm_night_enabled) {
    const startOffsetHrs = config.warm_night_start / 60;
    const endOffsetHrs = config.warm_night_end / 60;
    const fadeHrs = config.warm_night_fade / 60;

    let windowStart, windowEnd;
    if (config.warm_night_mode === 'all') {
      windowStart = sunset + startOffsetHrs;
      windowEnd = sunrise + 24 + endOffsetHrs; // next day sunrise
    } else if (config.warm_night_mode === 'sunset') {
      windowStart = sunset + startOffsetHrs;
      windowEnd = sunrise + 24; // until midnight effectively
    } else { // sunrise
      windowStart = sunset;
      windowEnd = sunrise + endOffsetHrs;
    }

    rules.push({
      mode: 'warm',
      target: config.warm_night_target,
      windowStart,
      windowEnd,
      fadeHours: fadeHrs,
      alignEnd: false
    });
  }

  // Cool during day rule
  if (config.cool_day_enabled) {
    const startOffsetHrs = config.cool_day_start / 60;
    const endOffsetHrs = config.cool_day_end / 60;
    const fadeHrs = config.cool_day_fade / 60;

    let windowStart, windowEnd;
    if (config.cool_day_mode === 'all') {
      windowStart = sunrise + startOffsetHrs;
      windowEnd = sunset + endOffsetHrs;
    } else if (config.cool_day_mode === 'sunrise') {
      windowStart = sunrise + startOffsetHrs;
      windowEnd = sunset;
    } else { // sunset
      windowStart = sunrise;
      windowEnd = sunset + endOffsetHrs;
    }

    rules.push({
      mode: 'cool',
      target: config.cool_day_target,
      windowStart,
      windowEnd,
      fadeHours: fadeHrs,
      alignEnd: false
    });
  }

  // Apply rules
  const fwd = (a, b) => ((b - a) % 24 + 24) % 24;
  const alignTime = (time, reference) => {
    let t = time;
    while (t < reference - 12) t += 24;
    while (t > reference + 12) t -= 24;
    return t;
  };

  rules.forEach(rule => {
    if (!rule.target) return;
    let { windowStart, windowEnd } = rule;
    const totalSpan = fwd(windowStart, windowEnd);
    if (totalSpan <= 0) return;

    for (let i = 0; i < cctArray.length; i++) {
      const alignedHour = alignTime(hoursArray[i], windowStart);
      const distFromStart = fwd(windowStart, alignedHour);
      if (distFromStart < 0 || distFromStart > totalSpan) continue;

      let weight = 1;
      if (rule.fadeHours > 0.01) {
        if (distFromStart < rule.fadeHours) {
          weight = distFromStart / rule.fadeHours;
        }
      }

      if (weight <= 0) continue;
      if (weight > 1) weight = 1;

      const current = cctArray[i];
      if (rule.mode === 'cool') {
        if (current >= rule.target) continue;
        cctArray[i] = current + (rule.target - current) * weight;
      } else if (rule.mode === 'warm') {
        if (current <= rule.target) continue;
        cctArray[i] = current + (rule.target - current) * weight;
      }
    }
  });
}

// ============================================================
// Utility Functions
// ============================================================

function formatHour(h) {
  const h24 = ((h % 24) + 24) % 24;
  const hr = Math.floor(h24);
  const min = Math.round((h24 - hr) * 60);
  const suffix = hr < 12 ? 'a' : 'p';
  const hr12 = hr === 0 ? 12 : (hr > 12 ? hr - 12 : hr);
  return min === 0 ? `${hr12}:00${suffix}` : `${hr12}:${min.toString().padStart(2, '0')}${suffix}`;
}

function fmtTime(h) {
  return formatHour(h);
}

function logistic(x, midpoint, slope, y0, y1) {
  try {
    const expVal = Math.exp(-slope * (x - midpoint));
    return y0 + (y1 - y0) / (1 + expVal);
  } catch {
    return slope * (x - midpoint) > 0 ? y1 : y0;
  }
}

// ============================================================
// Curve Calculation
// ============================================================

function calculateCurveData() {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  const wakeMid = runtimeState.brightness_wake_mid ?? config.wake_time;
  const bedMid = runtimeState.brightness_bed_mid ?? config.bed_time;
  const colorWakeMid = runtimeState.color_wake_mid ?? config.wake_time;
  const colorBedMid = runtimeState.color_bed_mid ?? config.bed_time;

  const kAscend = SPEED_TO_SLOPE[config.wake_speed] || 1.3;
  const kDescend = SPEED_TO_SLOPE[config.bed_speed] || 1.3;

  const bMin = config.min_brightness / 100;
  const bMax = config.max_brightness / 100;
  const cLow = config.min_color_temp;
  const cHigh = config.max_color_temp;

  const hours = Array.from({ length: 480 }, (_, i) => (i * 3) / 60);

  const brightness = hours.map(h => {
    const h48 = h < tAscend ? h + 24 : h;
    const inAscend = h48 >= tAscend && h48 < tDescend;

    let wakeMid48 = wakeMid;
    let safety = 0;
    while (wakeMid48 < tAscend && safety++ < 10) wakeMid48 += 24;
    safety = 0;
    while (wakeMid48 > tDescend && safety++ < 10) wakeMid48 -= 24;

    let bedMid48 = bedMid;
    safety = 0;
    while (bedMid48 < tDescend && safety++ < 10) bedMid48 += 24;
    safety = 0;
    while (bedMid48 > tDescend + 24 && safety++ < 10) bedMid48 -= 24;

    if (inAscend) {
      return logistic(h48, wakeMid48, kAscend, bMin, bMax);
    } else {
      const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
      return logistic(hDescend48, bedMid48, -kDescend, bMin, bMax);
    }
  });

  const colorCurve = hours.map(h => {
    const h48 = h < tAscend ? h + 24 : h;
    const inAscend = h48 >= tAscend && h48 < tDescend;

    let colorWakeMid48 = colorWakeMid;
    let safety = 0;
    while (colorWakeMid48 < tAscend && safety++ < 10) colorWakeMid48 += 24;
    safety = 0;
    while (colorWakeMid48 > tDescend && safety++ < 10) colorWakeMid48 -= 24;

    let colorBedMid48 = colorBedMid;
    safety = 0;
    while (colorBedMid48 < tDescend && safety++ < 10) colorBedMid48 += 24;
    safety = 0;
    while (colorBedMid48 > tDescend + 24 && safety++ < 10) colorBedMid48 -= 24;

    let normalized;
    if (inAscend) {
      normalized = logistic(h48, colorWakeMid48, kAscend, 0, 1);
    } else {
      const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
      normalized = logistic(hDescend48, colorBedMid48, -kDescend, 0, 1);
    }
    return Math.max(0, Math.min(1, normalized));
  });

  const cct = colorCurve.map(v => cLow + (cHigh - cLow) * v);

  const phase = hours.map(h => {
    const h48 = h < tAscend ? h + 24 : h;
    return h48 < tDescend ? 'Ascend' : 'Descend';
  });

  return { hours, brightness, cct, phase, tAscend, tDescend };
}

// Get brightness at specific x value
function getBrightnessAt(xVal, brightnessPct, samplesPerHour) {
  const idx = Math.min(brightnessPct.length - 1, Math.max(0, Math.round(xVal * samplesPerHour)));
  return brightnessPct[idx];
}

// Generate phase segments for shading
function spanSegments(start, end) {
  let delta = ((end - start) % 24 + 24) % 24;
  if (delta === 0) delta = 24;
  const startWrap = wrap24(start);
  const endWrap = (startWrap + delta) % 24;
  if (delta === 24) return [{ start: 0, end: 24 }];
  if (startWrap < endWrap) return [{ start: startWrap, end: endWrap }];
  return [
    { start: startWrap, end: 24 },
    { start: 0, end: endWrap }
  ];
}

// ============================================================
// Chart Rendering
// ============================================================

function renderChart() {
  const dateStr = getSelectedDateISO();
  const { sunrise, sunset, solarNoon, solarMid } = getSunTimes(config.latitude, config.longitude, dateStr);

  // Cache sun times for color rules
  sunTimes = { sunrise, sunset, solarNoon, solarMid };

  const data = calculateCurveData();

  // Apply solar color rules to CCT
  adjustCCTForSolarRules(data.cct, data.hours, sunrise, sunset);

  graphData = data;

  const { hours, brightness, cct, phase, tAscend, tDescend } = data;
  const brightnessPct = brightness.map(v => v * 100);
  const samplesPerHour = hours.length / 24;

  // Build traces
  const traces = [];

  // Color-gradient brightness curve (filled + line segments)
  const step = 2;
  for (let i = step; i < hours.length; i += step) {
    const color = cctToRGB(cct[i]);
    const fillColor = colorWithAlpha(color, 0.5);
    const x0 = hours[i - step];
    const x1 = hours[i];
    const y0 = brightnessPct[i - step];
    const y1 = brightnessPct[i];

    // Filled area under curve
    traces.push({
      type: 'scatter',
      mode: 'lines',
      x: [x0, x1, x1, x0],
      y: [y0, y1, 0, 0],
      fill: 'toself',
      line: { width: 0 },
      fillcolor: fillColor,
      hoverinfo: 'skip',
      showlegend: false
    });

    // Colored line segment
    traces.push({
      type: 'scatter',
      mode: 'lines',
      x: [x0, x1],
      y: [y0, y1],
      line: { width: 3, color },
      hoverinfo: 'skip',
      showlegend: false
    });
  }

  // Sun curve - LINE ONLY, no fill
  const lat = config.latitude;
  const latRad = lat * Math.PI / 180;
  const doyToday = dayOfYear(dateStr);
  const doyWinter = dayOfYear(`${new Date(dateStr).getFullYear()}-12-21`);
  const deltaToday = solarDeclination(doyToday);
  const deltaWinter = solarDeclination(doyWinter);

  const H = hours.map(hh => (hh - solarNoon) * (Math.PI / 12));

  function zenith(phi, delta, Hr) {
    const c = Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(Hr);
    return Math.acos(Math.max(-1, Math.min(1, c)));
  }

  function ghiHaurwitz(z) {
    if (z >= Math.PI / 2) return 0;
    const mu = Math.cos(z);
    return 1098 * mu * Math.exp(-0.057 / mu);
  }

  const ghiToday = H.map(Hr => ghiHaurwitz(zenith(latRad, deltaToday, Hr)));
  const ghiWinter = H.map(Hr => ghiHaurwitz(zenith(latRad, deltaWinter, Hr)));
  const alpha = 1.5 / Math.max(...ghiWinter, 0.001);
  const sunScaledPct = ghiToday.map(v => v * alpha * 100);

  // Sun curve - just line, no fill
  traces.push({
    type: 'scatter',
    mode: 'lines',
    x: hours,
    y: sunScaledPct,
    line: { width: 1, color: 'rgba(255,255,255,0.25)' },
    name: 'Sun',
    hoverinfo: 'skip',
    showlegend: true
  });

  // Hover trace - CCT colored background, shows phase, no time
  const hoverDetails = brightnessPct.map((v, i) => {
    const pct = Math.round(v);
    const kelvin = Math.round(cct[i]);
    const phaseWord = phase[i] === 'Ascend' ? 'ascending' : 'descending';
    return `${pct}% • ${kelvin}K • ${phaseWord}`;
  });

  const hoverBgColors = cct.map(k => colorWithAlpha(cctToRGB(k), 0.92));
  const hoverTextColors = cct.map(k => readableTextColor(cctToRGB(k)));
  const hoverBorderColors = cct.map(k => colorWithAlpha(cctToRGB(k), 0.65));

  traces.push({
    type: 'scatter',
    mode: 'lines',
    x: hours,
    y: brightnessPct,
    line: { width: 0 },
    showlegend: false,
    text: hoverDetails,
    hovertemplate: '%{text}<extra></extra>',
    hoverlabel: {
      bgcolor: hoverBgColors,
      bordercolor: hoverBorderColors,
      font: { color: hoverTextColors, size: 13 }
    }
  });

  // Legend placeholder for HomeGlo
  traces.push({
    type: 'scatter',
    mode: 'lines',
    x: [null],
    y: [null],
    line: { width: 3, color: '#fff' },
    name: 'HomeGlo',
    hoverinfo: 'skip',
    showlegend: true
  });

  // Shapes and annotations
  const shapes = [];
  const annotations = [];

  // Phase shading ABOVE the curve
  const ascendSegments = spanSegments(tAscend, tDescend);
  const descendSegments = spanSegments(tDescend, tAscend + 24);

  const addCurveBand = (segments, color) => {
    const yTop = GRAPH_Y_MAX;
    const stepSize = 0.05;
    segments.forEach(seg => {
      const points = [];
      for (let x = seg.start; x <= seg.end + 1e-6; x += stepSize) {
        const clamped = Math.min(seg.end, x);
        points.push({ x: clamped, y: getBrightnessAt(clamped, brightnessPct, samplesPerHour) });
      }
      if (!points.length) return;
      const startX = points[0].x;
      const endX = points[points.length - 1].x;
      let path = `M ${startX} ${yTop} L ${endX} ${yTop}`;
      for (let i = points.length - 1; i >= 0; i--) {
        path += ` L ${points[i].x} ${points[i].y}`;
      }
      path += ' Z';
      shapes.push({
        type: 'path',
        xref: 'x',
        yref: 'y',
        path,
        fillcolor: color,
        line: { width: 0 },
        layer: 'below'
      });
    });
  };

  addCurveBand(ascendSegments, ASCEND_COLORS.shade);
  addCurveBand(descendSegments, DESCEND_COLORS.shade);

  // Phase boundary lines
  const ascendStart = wrap24(config.ascend_start);
  const descendStart = wrap24(config.descend_start);

  shapes.push({
    type: 'line', xref: 'x', yref: 'paper',
    x0: ascendStart, x1: ascendStart, y0: 0, y1: 1,
    line: { color: ASCEND_COLORS.axis, width: 1.5 }
  });
  shapes.push({
    type: 'line', xref: 'x', yref: 'paper',
    x0: descendStart, x1: descendStart, y0: 0, y1: 1,
    line: { color: DESCEND_COLORS.axis, width: 1.5 }
  });

  // X-axis labels (from top to bottom):
  // 1. Time labels (handled by xaxis ticktext at y=0)
  // 2. Phase labels (ascend starts, wake, descend starts, bed) at y = -0.14
  // 3. Solar labels (sunrise, sunset, etc.) at y = -0.20, muted grey

  // Phase labels with vertical lines
  const phaseLabels = [
    { label: 'ascend starts', x: ascendStart, color: ASCEND_COLORS.text, lineColor: ASCEND_COLORS.axis, solid: true },
    { label: 'wake', x: wrap24(config.wake_time), color: ASCEND_COLORS.text, lineColor: ASCEND_COLORS.axis, solid: false },
    { label: 'descend starts', x: descendStart, color: DESCEND_COLORS.text, lineColor: DESCEND_COLORS.axis, solid: true },
    { label: 'bed', x: wrap24(config.bed_time), color: DESCEND_COLORS.text, lineColor: DESCEND_COLORS.axis, solid: false }
  ];

  phaseLabels.forEach(marker => {
    // Vertical line from label to axis
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: marker.x, x1: marker.x, y0: -0.08, y1: marker.solid ? 1 : 0,
      line: { color: marker.lineColor, width: marker.solid ? 1.6 : 1, dash: marker.solid ? 'solid' : 'dot' }
    });
    annotations.push({
      x: marker.x, y: -0.14, xref: 'x', yref: 'paper',
      text: marker.label,
      showarrow: false,
      font: { size: 11, color: marker.color }
    });
  });

  // Solar labels - all same muted grey color, lower position
  const solarLabelColor = 'rgba(215,215,215,0.8)';
  const solarLineColor = 'rgba(200,200,200,0.35)';
  const solarLabels = [
    { label: 'sunrise', x: wrap24(sunrise) },
    { label: 'sunset', x: wrap24(sunset) },
    { label: 'solar noon', x: wrap24(solarNoon) },
    { label: 'solar midnight', x: wrap24(solarMid) }
  ];

  solarLabels.forEach(marker => {
    if (!Number.isFinite(marker.x)) return;
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: marker.x, x1: marker.x, y0: -0.135, y1: 0,
      line: { color: solarLineColor, width: 1, dash: 'dot' }
    });
    annotations.push({
      x: marker.x, y: -0.20, xref: 'x', yref: 'paper',
      text: marker.label,
      showarrow: false,
      font: { size: 10, color: solarLabelColor }
    });
  });

  // Store base shapes/annotations for cursor updates
  window.baseShapes = shapes.slice();
  window.baseAnnotations = annotations.slice();

  const layout = {
    paper_bgcolor: '#0a0a0a',
    plot_bgcolor: '#0a0a0a',
    margin: { t: 40, r: 40, l: 50, b: 120 },  // Extra bottom margin for solar labels
    legend: { orientation: 'h', x: 0, y: 1.1, font: { color: '#c8c8c8' } },
    hovermode: 'closest',
    xaxis: {
      range: [0, 24],
      dtick: 2,
      tickvals: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24],
      ticktext: ['12a', '2a', '4a', '6a', '8a', '10a', '12p', '2p', '4p', '6p', '8p', '10p', '12a'],
      gridcolor: 'rgba(80,100,130,0.22)',
      tickfont: { color: '#c8c8c8' },
      ticklen: 4,
      tickcolor: 'rgba(160,190,220,0.2)'
    },
    yaxis: {
      range: [0, GRAPH_Y_MAX],
      gridcolor: 'rgba(80,100,130,0.22)',
      tickfont: { color: '#c8c8c8' },
      ticklen: 4,
      title: 'Brightness (%)',
      titlefont: { color: '#c8c8c8' }
    },
    shapes,
    annotations
  };

  Plotly.react('chart', traces, layout, { displayModeBar: false }).then(() => {
    initChartInteractivity();
    applyCursor();
  });

  // Update date display
  const dateDisplay = document.getElementById('chart-date-display');
  if (dateDisplay) {
    const d = new Date(dateStr + 'T12:00:00');
    dateDisplay.textContent = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }
}

// ============================================================
// Chart Interactivity
// ============================================================

function initChartInteractivity() {
  const chart = document.getElementById('chart');
  if (!chart || chart._interactivityInitialized) return;

  const chartWrapper = document.querySelector('.chart-wrapper');
  const hoverLabel = document.getElementById('time-hover-label');

  // Helper to get plot area (Plotly creates this after rendering)
  const getPlotArea = () => {
    // Try multiple selectors for Plotly's plot area
    return chart.querySelector('.cartesianlayer .plot') ||
           chart.querySelector('.plot-container .plot') ||
           chart.querySelector('.nsewdrag');
  };

  // Mouse move for time hover label at top
  chart.addEventListener('mousemove', (ev) => {
    const plotArea = getPlotArea();
    if (!plotArea) return;

    const rect = plotArea.getBoundingClientRect();
    const inside = ev.clientX >= rect.left && ev.clientX <= rect.right &&
                   ev.clientY >= rect.top && ev.clientY <= rect.bottom;

    if (!inside) {
      hoverLabel.style.opacity = '0';
      return;
    }

    const layout = chart._fullLayout;
    const xRange = layout?.xaxis?.range || [0, 24];
    const ratio = (ev.clientX - rect.left) / rect.width;
    const xVal = xRange[0] + ratio * (xRange[1] - xRange[0]);
    const wrapperRect = chartWrapper.getBoundingClientRect();

    hoverLabel.textContent = fmtTime(xVal);
    hoverLabel.style.left = `${ev.clientX - wrapperRect.left}px`;

    // Color based on phase
    const tAscend = config.ascend_start;
    let tDescend = config.descend_start;
    if (tDescend <= tAscend) tDescend += 24;
    let h = xVal;
    if (h < tAscend) h += 24;
    const inAscend = h < tDescend;
    const chipColor = inAscend ? ASCEND_COLORS.hoverBg : DESCEND_COLORS.hoverBg;

    hoverLabel.style.background = chipColor;
    hoverLabel.style.color = readableTextColor(chipColor);
    hoverLabel.style.opacity = '1';
  }, true);  // Use capture phase

  chart.addEventListener('mouseleave', () => {
    hoverLabel.style.opacity = '0';
  }, true);

  // Click for cursor placement - use capture to get events before Plotly
  chart.addEventListener('click', (ev) => {
    const plotArea = getPlotArea();
    if (!plotArea) {
      console.log('No plot area found');
      return;
    }

    const rect = plotArea.getBoundingClientRect();
    if (ev.clientX < rect.left || ev.clientX > rect.right ||
        ev.clientY < rect.top || ev.clientY > rect.bottom) {
      return;
    }

    const layout = chart._fullLayout;
    const xRange = layout?.xaxis?.range || [0, 24];
    const ratio = (ev.clientX - rect.left) / rect.width;
    const xVal = xRange[0] + ratio * (xRange[1] - xRange[0]);

    cursorHour = xVal;
    applyCursor();
  }, true);  // Use capture phase

  // Double click to clear cursor
  chart.addEventListener('dblclick', () => {
    cursorHour = null;
    applyCursor();
  }, true);

  chart._interactivityInitialized = true;
}

function applyCursor() {
  const chart = document.getElementById('chart');
  const cursorControls = document.getElementById('cursor-controls');
  const cursorCallout = document.getElementById('cursor-callout');

  if (!chart || !window.baseShapes) return;

  const shapes = window.baseShapes.slice();
  const annotations = window.baseAnnotations ? window.baseAnnotations.slice() : [];

  if (cursorHour === null) {
    Plotly.relayout(chart, { shapes, annotations });
    cursorControls.classList.add('hidden');
    cursorCallout.style.opacity = '0';
    return;
  }

  // Add cursor line
  shapes.push({
    type: 'line', xref: 'x', yref: 'paper',
    x0: cursorHour, x1: cursorHour, y0: 0, y1: 1,
    line: { color: 'rgba(255,255,255,0.8)', width: 2 }
  });

  // Update cursor callout
  if (graphData) {
    const idx = graphData.hours.findIndex(h => h >= cursorHour);
    if (idx >= 0) {
      const bri = Math.round(graphData.brightness[idx] * 100);
      const cctVal = Math.round(graphData.cct[idx]);
      const phaseWord = graphData.phase[idx] === 'Ascend' ? 'ascending' : 'descending';

      const plotArea = chart.querySelector('.cartesianlayer .plot');
      const chartWrapper = document.querySelector('.chart-wrapper');
      if (plotArea && chartWrapper) {
        const rect = plotArea.getBoundingClientRect();
        const wrapperRect = chartWrapper.getBoundingClientRect();
        const x = rect.left + (cursorHour / 24) * rect.width - wrapperRect.left;
        const y = rect.top + (1 - graphData.brightness[idx]) * rect.height - wrapperRect.top;

        cursorCallout.textContent = `${fmtTime(cursorHour)} • ${bri}% • ${cctVal}K • ${phaseWord}`;
        cursorCallout.style.left = `${x}px`;
        cursorCallout.style.top = `${y - 35}px`;
        cursorCallout.style.opacity = '1';

        // Color based on CCT
        const color = cctToRGB(cctVal);
        cursorCallout.style.background = colorWithAlpha(color, 0.92);
        cursorCallout.style.color = readableTextColor(color);
        cursorCallout.style.borderColor = colorWithAlpha(color, 0.65);
      }
    }
  }

  Plotly.relayout(chart, { shapes, annotations });
  cursorControls.classList.remove('hidden');
}

// ============================================================
// UI Updates
// ============================================================

function updateDisplay(id, value) {
  const el = document.getElementById(id);
  if (el) el.textContent = value;
}

function updateSliderValue(sliderId, displayId, formatter) {
  const slider = document.getElementById(sliderId);
  if (!slider) return;
  slider.addEventListener('input', () => {
    const val = parseFloat(slider.value);
    updateDisplay(displayId, formatter(val));
    syncConfigFromUI();
    renderChart();
  });
}

function syncConfigFromUI() {
  config.ascend_start = parseFloat(document.getElementById('ascend-start').value);
  config.descend_start = parseFloat(document.getElementById('descend-start').value) % 24;
  config.wake_time = parseFloat(document.getElementById('wake-time').value);
  config.bed_time = parseFloat(document.getElementById('bed-time').value) % 24;
  config.wake_speed = parseInt(document.getElementById('wake-speed').value);
  config.bed_speed = parseInt(document.getElementById('bed-speed').value);

  config.min_color_temp = parseInt(document.getElementById('color-min').value);
  config.max_color_temp = parseInt(document.getElementById('color-max').value);
  config.min_brightness = parseInt(document.getElementById('brightness-min').value);
  config.max_brightness = parseInt(document.getElementById('brightness-max').value);
  config.max_dim_steps = parseInt(document.getElementById('step-count').value);

  config.warm_night_enabled = document.getElementById('warm-night-enabled').checked;
  config.warm_night_mode = document.getElementById('warm-night-mode').value;
  config.warm_night_target = parseInt(document.getElementById('warm-night-target').value);
  config.warm_night_start = parseInt(document.getElementById('warm-night-start')?.value || -60);
  config.warm_night_end = parseInt(document.getElementById('warm-night-end')?.value || 60);
  config.warm_night_fade = parseInt(document.getElementById('warm-night-fade')?.value || 60);

  config.cool_day_enabled = document.getElementById('cool-day-enabled').checked;
  config.cool_day_mode = document.getElementById('cool-day-mode').value;
  config.cool_day_target = parseInt(document.getElementById('cool-day-target').value);
  config.cool_day_start = parseInt(document.getElementById('cool-day-start')?.value || 0);
  config.cool_day_end = parseInt(document.getElementById('cool-day-end')?.value || 0);
  config.cool_day_fade = parseInt(document.getElementById('cool-day-fade')?.value || 60);

  resetRuntimeMidpoints();
  updateColorGradients();
  constrainWakeBedSliders();
}

function syncUIFromConfig() {
  document.getElementById('ascend-start').value = config.ascend_start;
  document.getElementById('descend-start').value = config.descend_start;
  document.getElementById('wake-time').value = config.wake_time;
  document.getElementById('bed-time').value = config.bed_time;
  document.getElementById('wake-speed').value = config.wake_speed;
  document.getElementById('bed-speed').value = config.bed_speed;

  document.getElementById('color-min').value = config.min_color_temp;
  document.getElementById('color-max').value = config.max_color_temp;
  document.getElementById('brightness-min').value = config.min_brightness;
  document.getElementById('brightness-max').value = config.max_brightness;
  document.getElementById('step-count').value = config.max_dim_steps;

  document.getElementById('warm-night-enabled').checked = config.warm_night_enabled;
  document.getElementById('warm-night-mode').value = config.warm_night_mode;
  document.getElementById('warm-night-target').value = config.warm_night_target;
  const warmStart = document.getElementById('warm-night-start');
  const warmEnd = document.getElementById('warm-night-end');
  const warmFade = document.getElementById('warm-night-fade');
  if (warmStart) warmStart.value = config.warm_night_start;
  if (warmEnd) warmEnd.value = config.warm_night_end;
  if (warmFade) warmFade.value = config.warm_night_fade;

  document.getElementById('cool-day-enabled').checked = config.cool_day_enabled;
  document.getElementById('cool-day-mode').value = config.cool_day_mode;
  document.getElementById('cool-day-target').value = config.cool_day_target;
  const coolStart = document.getElementById('cool-day-start');
  const coolEnd = document.getElementById('cool-day-end');
  const coolFade = document.getElementById('cool-day-fade');
  if (coolStart) coolStart.value = config.cool_day_start;
  if (coolEnd) coolEnd.value = config.cool_day_end;
  if (coolFade) coolFade.value = config.cool_day_fade;

  document.getElementById('activity-preset').value = config.activity_preset || 'adult';

  updateDisplay('ascend-start-display', formatHour(config.ascend_start));
  updateDisplay('descend-start-display', formatHour(config.descend_start));
  updateDisplay('wake-time-display', formatHour(config.wake_time));
  updateDisplay('bed-time-display', formatHour(config.bed_time));
  updateDisplay('wake-speed-display', `${SPEED_LABELS[config.wake_speed]} (${config.wake_speed})`);
  updateDisplay('bed-speed-display', `${SPEED_LABELS[config.bed_speed]} (${config.bed_speed})`);
  updateDisplay('color-min-display', `${config.min_color_temp} K`);
  updateDisplay('color-max-display', `${config.max_color_temp} K`);
  updateDisplay('brightness-min-display', `${config.min_brightness}%`);
  updateDisplay('brightness-max-display', `${config.max_brightness}%`);
  updateDisplay('step-count-display', `${config.max_dim_steps} steps`);

  updateDualFills();
  updateColorGradients();
  updateOffsetDisplays();
  constrainWakeBedSliders();
}

// Update offset text displays
function updateOffsetDisplays() {
  const formatOffset = (val, baseEvent) => {
    const absVal = Math.abs(val);
    if (val === 0) return `at ${baseEvent}`;
    const direction = val < 0 ? 'before' : 'after';
    return `${absVal} min ${direction} ${baseEvent}`;
  };

  updateDisplay('warm-night-start-text', formatOffset(config.warm_night_start, 'sunset'));
  updateDisplay('warm-night-end-text', formatOffset(config.warm_night_end, 'sunrise'));
  updateDisplay('warm-night-fade-text', `${config.warm_night_fade} min`);
  updateDisplay('cool-day-start-text', formatOffset(config.cool_day_start, 'sunrise'));
  updateDisplay('cool-day-end-text', formatOffset(config.cool_day_end, 'sunset'));
  updateDisplay('cool-day-fade-text', `${config.cool_day_fade} min`);
}

// Constrain wake slider to between ascend_start and descend_start
// Constrain bed slider to between descend_start and ascend_start (wrapping)
function constrainWakeBedSliders() {
  const wakeSlider = document.getElementById('wake-time');
  const bedSlider = document.getElementById('bed-time');
  if (!wakeSlider || !bedSlider) return;

  // Wake must be between ascend_start and descend_start
  const ascendStart = config.ascend_start;
  let descendStart = config.descend_start;
  if (descendStart <= ascendStart) descendStart += 24;

  wakeSlider.min = ascendStart;
  wakeSlider.max = descendStart;

  // Clamp current value
  let wakeVal = parseFloat(wakeSlider.value);
  if (wakeVal < ascendStart) wakeVal = ascendStart;
  if (wakeVal > descendStart) wakeVal = descendStart;
  wakeSlider.value = wakeVal;
  config.wake_time = wakeVal % 24;
  updateDisplay('wake-time-display', formatHour(config.wake_time));

  // Bed must be between descend_start and ascend_start+24
  bedSlider.min = config.descend_start;
  bedSlider.max = config.descend_start + 24 - (descendStart - ascendStart);

  let bedVal = parseFloat(bedSlider.value);
  const bedMin = parseFloat(bedSlider.min);
  const bedMax = parseFloat(bedSlider.max);
  if (bedVal < bedMin) bedVal = bedMin;
  if (bedVal > bedMax) bedVal = bedMax;
  bedSlider.value = bedVal;
  config.bed_time = bedVal % 24;
  updateDisplay('bed-time-display', formatHour(config.bed_time));
}

function updateDualFills() {
  const colorMin = parseInt(document.getElementById('color-min').value);
  const colorMax = parseInt(document.getElementById('color-max').value);
  const colorFill = document.getElementById('color-fill');
  if (colorFill) {
    const left = ((colorMin - 500) / 6000) * 100;
    const right = ((colorMax - 500) / 6000) * 100;
    colorFill.style.left = `${left}%`;
    colorFill.style.width = `${right - left}%`;
  }

  const briMin = parseInt(document.getElementById('brightness-min').value);
  const briMax = parseInt(document.getElementById('brightness-max').value);
  const briFill = document.getElementById('brightness-fill');
  if (briFill) {
    briFill.style.left = `${briMin}%`;
    briFill.style.width = `${briMax - briMin}%`;
  }
}

function resetRuntimeMidpoints() {
  runtimeState.brightness_wake_mid = config.wake_time;
  runtimeState.brightness_bed_mid = config.bed_time;
  runtimeState.color_wake_mid = config.wake_time;
  runtimeState.color_bed_mid = config.bed_time;
}

// ============================================================
// Event Handlers
// ============================================================

function setupEventListeners() {
  updateSliderValue('ascend-start', 'ascend-start-display', formatHour);
  updateSliderValue('descend-start', 'descend-start-display', formatHour);
  updateSliderValue('wake-time', 'wake-time-display', formatHour);
  updateSliderValue('bed-time', 'bed-time-display', formatHour);
  updateSliderValue('wake-speed', 'wake-speed-display', v => `${SPEED_LABELS[v]} (${v})`);
  updateSliderValue('bed-speed', 'bed-speed-display', v => `${SPEED_LABELS[v]} (${v})`);

  updateSliderValue('color-min', 'color-min-display', v => `${v} K`);
  updateSliderValue('color-max', 'color-max-display', v => `${v} K`);
  updateSliderValue('brightness-min', 'brightness-min-display', v => `${v}%`);
  updateSliderValue('brightness-max', 'brightness-max-display', v => `${v}%`);
  updateSliderValue('step-count', 'step-count-display', v => `${v} steps`);

  // Warm/cool target sliders (inside popups)
  document.getElementById('warm-night-target')?.addEventListener('input', () => {
    config.warm_night_target = parseInt(document.getElementById('warm-night-target').value);
    updateColorChips();
    renderChart();
  });
  document.getElementById('cool-day-target')?.addEventListener('input', () => {
    config.cool_day_target = parseInt(document.getElementById('cool-day-target').value);
    updateColorChips();
    renderChart();
  });

  // Offset sliders
  ['warm-night-start', 'warm-night-end', 'warm-night-fade', 'cool-day-start', 'cool-day-end', 'cool-day-fade'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('input', () => {
        syncConfigFromUI();
        updateOffsetDisplays();
        renderChart();
      });
    }
  });

  ['warm-night-enabled', 'cool-day-enabled', 'warm-night-mode', 'cool-day-mode'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('change', () => { syncConfigFromUI(); renderChart(); });
  });

  // Color chip buttons - toggle popups
  document.getElementById('warm-night-target-chip')?.addEventListener('click', (e) => {
    e.stopPropagation();
    const popup = document.getElementById('warm-night-popup');
    const other = document.getElementById('cool-day-popup');
    if (other) other.classList.remove('is-open');
    popup?.classList.toggle('is-open');
  });
  document.getElementById('cool-day-target-chip')?.addEventListener('click', (e) => {
    e.stopPropagation();
    const popup = document.getElementById('cool-day-popup');
    const other = document.getElementById('warm-night-popup');
    if (other) other.classList.remove('is-open');
    popup?.classList.toggle('is-open');
  });

  // Close popups when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.color-controls-wrap')) {
      document.querySelectorAll('.color-slider-popup').forEach(p => p.classList.remove('is-open'));
    }
  });

  document.getElementById('activity-preset').addEventListener('change', (e) => {
    const preset = ACTIVITY_PRESETS[e.target.value];
    if (preset) {
      config.activity_preset = e.target.value;
      config.wake_time = preset.wake_time;
      config.bed_time = preset.bed_time;
      config.ascend_start = preset.ascend_start;
      config.descend_start = preset.descend_start;
      resetRuntimeMidpoints();
      syncUIFromConfig();
      renderChart();
    }
  });

  document.getElementById('chart-date-slider').addEventListener('input', () => {
    renderChart();
  });

  document.getElementById('cursor-step-up')?.addEventListener('click', () => stepCursor('up', true, true));
  document.getElementById('cursor-step-down')?.addEventListener('click', () => stepCursor('down', true, true));
  document.getElementById('cursor-bright-up')?.addEventListener('click', () => stepCursor('up', true, false));
  document.getElementById('cursor-bright-down')?.addEventListener('click', () => stepCursor('down', true, false));
  document.getElementById('cursor-color-up')?.addEventListener('click', () => stepCursor('up', false, true));
  document.getElementById('cursor-color-down')?.addEventListener('click', () => stepCursor('down', false, true));
  document.getElementById('cursor-reset')?.addEventListener('click', () => {
    resetRuntimeMidpoints();
    renderChart();
    applyCursor();
  });

  ['color-min', 'color-max', 'brightness-min', 'brightness-max'].forEach(id => {
    document.getElementById(id)?.addEventListener('input', updateDualFills);
  });

  document.getElementById('save-config')?.addEventListener('click', saveConfig);
}

function stepCursor(direction, adjustBrightness, adjustColor) {
  if (cursorHour === null) return;

  const stepSize = 0.5;
  const sign = direction === 'up' ? 1 : -1;

  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;
  let h = cursorHour;
  if (h < tAscend) h += 24;
  const inAscend = h < tDescend;

  if (adjustBrightness) {
    if (inAscend) {
      runtimeState.brightness_wake_mid = (runtimeState.brightness_wake_mid ?? config.wake_time) + sign * stepSize;
    } else {
      runtimeState.brightness_bed_mid = (runtimeState.brightness_bed_mid ?? config.bed_time) + sign * stepSize;
    }
  }

  if (adjustColor) {
    if (inAscend) {
      runtimeState.color_wake_mid = (runtimeState.color_wake_mid ?? config.wake_time) + sign * stepSize;
    } else {
      runtimeState.color_bed_mid = (runtimeState.color_bed_mid ?? config.bed_time) + sign * stepSize;
    }
  }

  renderChart();
  applyCursor();
}

// ============================================================
// API Communication
// ============================================================

async function loadConfig() {
  try {
    const resp = await fetch('./api/config');
    if (resp.ok) {
      const data = await resp.json();
      Object.assign(config, data);
      resetRuntimeMidpoints();
      syncUIFromConfig();
      renderChart();
    }
  } catch (err) {
    console.error('Error loading config:', err);
  }
}

async function saveConfig() {
  const statusEl = document.getElementById('save-status');
  try {
    const resp = await fetch('./api/config', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(config)
    });

    if (resp.ok) {
      statusEl.innerHTML = '<div class="success">Configuration saved successfully!</div>';
    } else {
      statusEl.innerHTML = '<div class="error">Failed to save configuration</div>';
    }
  } catch (err) {
    statusEl.innerHTML = '<div class="error">Error saving configuration: ' + err.message + '</div>';
  }

  setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
}

// ============================================================
// Initialize
// ============================================================

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('chart-date-slider');
  if (slider) {
    const now = new Date();
    const start = new Date(now.getFullYear(), 0, 1);
    const diff = now - start;
    const dayOfYear = Math.floor(diff / 86400000);
    slider.value = dayOfYear;
  }

  resetRuntimeMidpoints();
  setupEventListeners();
  syncUIFromConfig();
  renderChart();

  loadConfig();
});
</script>
</body>
</html>
