<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Circadian Light by HomeGlo</title>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
<style>
:root {
  --bg: #000;
  --panel: #181818;
  --panel2: #252525;
  --text: #e6e6e6;
  --muted: #bbb;
  --muted2: #aaa;
  --line: #333;
  --line2: #2c2c2c;
  --grid: #202020;
  --accent: #1e90ff;
  --ascend: rgba(120, 190, 255, 0.32);
  --ascend-border: rgba(120, 185, 245, 0.5);
  --descend: rgba(255, 220, 100, 0.12);
  --descend-border: rgba(255, 230, 128, 0.45);
}
* { box-sizing: border-box; }
html, body { height: 100%; margin: 0; background: var(--bg); color: var(--text); font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
body { padding: 20px; }
h1 { margin: 0 0 18px; font-size: 28px; font-weight: 600; }
h2 { margin: 0 0 12px; font-size: 1.1rem; font-weight: 600; }

.container { max-width: 1200px; margin: 0 auto; }
.header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; }
.header-actions { display: flex; gap: 12px; align-items: center; }

/* Activity Preset */
.activity-select { margin-bottom: 16px; }
.activity-select select {
  width: 100%;
  max-width: 300px;
  font-size: 1rem;
  padding: 10px 14px;
  border-radius: 10px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(255,255,255,0.06);
  color: #fff;
}

/* Section Blocks */
.section-block {
  background: var(--panel);
  border: 1px solid var(--line);
  border-radius: 12px;
  padding: 16px;
  margin-bottom: 16px;
}
.section-block--ascend {
  background: var(--ascend);
  border-color: var(--ascend-border);
}
.section-block--ascend h2 { color: #7ec8ff; }
.section-block--descend {
  background: var(--descend);
  border-color: var(--descend-border);
}
.section-block--descend h2 { color: #ffd47a; }
/* Time badge in section headers with timeline */
.section-block h2 {
  margin-bottom: 4px;
}
.header-timeline {
  position: relative;
  height: 22px;
  margin-bottom: 10px;
}
.header-timeline::before {
  content: '';
  position: absolute;
  left: 0;
  right: 0;
  top: 50%;
  height: 1px;
  background: rgba(255,255,255,0.15);
}
.time-badge {
  position: absolute;
  top: 50%;
  font-size: 0.7rem;
  font-weight: 500;
  padding: 2px 8px;
  border-radius: 10px;
  white-space: nowrap;
  transform: translate(-50%, -50%);
  transition: left 0.2s ease;
}
.section-block--ascend .time-badge {
  background: rgba(126,200,255,0.25);
  color: #7ec8ff;
}
.section-block--descend .time-badge {
  background: rgba(255,212,122,0.25);
  color: #ffd47a;
}

/* Timing Grid */
.timing-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 16px;
}
@media (max-width: 768px) {
  .timing-grid { grid-template-columns: 1fr; }
}

/* Parameter Rows */
.param-row {
  display: grid;
  grid-template-columns: 140px 80px 1fr;
  align-items: center;
  gap: 12px;
  margin: 10px 0;
}
/* Hidden control rows - kept for future "custom" preset */
.param-row.is-hidden {
  display: none;
  pointer-events: none;
}
.param-row label {
  font-size: 0.9rem;
  color: var(--muted);
  font-weight: 600;
}
.param-row .value {
  font-size: 0.95rem;
  font-weight: 600;
  color: var(--text);
  text-align: right;
}

/* Sliders */
input[type=range] {
  width: 100%;
  background: transparent;
  appearance: none;
  height: 20px;
  padding: 0;
  margin: 0;
}
input[type=range]:focus { outline: none; }
input[type=range]::-webkit-slider-runnable-track {
  height: 4px;
  background: rgba(255,255,255,0.3);
  border-radius: 2px;
}
input[type=range]::-moz-range-track {
  height: 4px;
  background: rgba(255,255,255,0.3);
  border-radius: 2px;
}
input[type=range]::-webkit-slider-thumb {
  appearance: none;
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid rgba(0,0,0,0.3);
  margin-top: -6px;
  cursor: pointer;
}
input[type=range]::-moz-range-thumb {
  width: 16px;
  height: 16px;
  border-radius: 50%;
  background: #fff;
  border: 2px solid rgba(0,0,0,0.3);
  cursor: pointer;
}

/* Chart Section */
.chart-wrapper { position: relative; margin-bottom: 32px; }
#chart { height: 450px; }
.chart-date-control {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 10px;
  margin: 6px auto 8px;
  max-width: 420px;
}
.chart-date-display {
  font-size: 0.9rem;
  color: var(--text);
  min-width: 70px;
  font-weight: 600;
}
.chart-date-control input[type=range] {
  flex: 1;
}

/* Time hover label - above x-axis, shows time with phase color */
.time-hover-label {
  position: absolute;
  bottom: 70px;
  padding: 4px 9px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.3);
  background: rgba(5,5,5,0.88);
  color: #fff;
  font-size: 0.75rem;
  font-weight: 600;
  pointer-events: none;
  transform: translateX(-50%);
  opacity: 0;
  transition: opacity 0.12s ease, left 0.08s ease;
  white-space: nowrap;
  box-shadow: 0 4px 10px rgba(0,0,0,0.35);
  z-index: 100;
}

/* Cursor callout - shows values at cursor position */
.graph-cursor-callout {
  position: absolute;
  bottom: -8px;
  padding: 4px 10px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(10,10,10,0.85);
  color: #fff;
  font-size: 0.78rem;
  font-weight: 600;
  pointer-events: none;
  transform: translateX(-50%);
  opacity: 0;
  transition: opacity 0.12s ease, left 0.08s ease;
  white-space: nowrap;
  z-index: 100;
}

/* Cursor Controls */
.cursor-controls {
  display: flex;
  justify-content: center;
  gap: 40px;
  margin-top: 16px;
}
.cursor-controls.hidden { display: none; }
.cursor-divider {
  width: 1px;
  background: rgba(255,255,255,0.2);
  align-self: stretch;
  margin: 8px 10px;
}
.cursor-stack {
  display: flex;
  flex-direction: column;
  align-items: center;
  gap: 6px;
  width: 100px;
}
.cursor-stack.wide {
  width: auto;
}
.cursor-stack-label {
  font-size: 0.9rem;
  color: #f0f0f0;
  letter-spacing: 0.08em;
  min-height: 20px;
  display: flex;
  align-items: center;
  gap: 6px;
}
.increment-input {
  width: 36px;
  padding: 2px 4px;
  font-size: 0.75rem;
  background: #333;
  border: 1px solid #555;
  border-radius: 3px;
  color: #ddd;
  text-align: center;
}
.cursor-btn-row {
  display: flex;
  flex-direction: column;
  gap: 6px;
  align-items: center;
  width: 100%;
}
.cursor-btn-row.horizontal {
  flex-direction: row;
  justify-content: center;
}
.cursor-btn {
  --btn-bg: rgba(255,255,255,0.06);
  --btn-text: #fff;
  --btn-fill: 0;
  --btn-fill-opacity: 0;
  border: 1px solid rgba(255,255,255,0.25);
  background: var(--btn-bg);
  color: var(--btn-text);
  font-size: 1rem;
  font-weight: 600;
  padding: 4px 16px;
  border-radius: 999px;
  width: 96px;
  cursor: pointer;
  transition: background 0.15s, border 0.15s, color 0.15s;
  position: relative;
  overflow: hidden;
  display: flex;
  align-items: center;
  justify-content: center;
}
.cursor-btn.wide {
  width: 140px;
}
.cursor-btn.small {
  width: auto;
  min-width: 40px;
  padding: 4px 10px;
  font-size: 0.85rem;
}
.cursor-btn.time-nav {
  width: 115px;
  height: 52px;
  padding: 8px 12px;
  flex-direction: column;
  justify-content: center;
  gap: 2px;
  overflow: visible;
}
.time-nav-header {
  display: flex;
  align-items: baseline;
  gap: 10px;
  position: relative;
  z-index: 1;
}
.time-nav-label {
  font-size: 0.9rem;
  font-weight: 600;
}
.time-nav-time {
  font-size: 0.6rem;
  opacity: 0.75;
}
.time-nav-values {
  font-size: 0.6rem;
  opacity: 0.9;
  white-space: nowrap;
  position: relative;
  z-index: 1;
}
.time-nav-values:empty, .time-nav-time:empty {
  display: none;
}
.cursor-btn::after {
  content: '';
  position: absolute;
  inset: 2px;
  border-radius: 999px;
  background: linear-gradient(90deg, rgba(255,255,255,0.05), rgba(255,255,255,0.95));
  opacity: var(--btn-fill-opacity);
  transform-origin: left center;
  transform: scaleX(var(--btn-fill));
  transition: transform 0.2s ease, opacity 0.2s ease;
  pointer-events: none;
}
.cursor-btn .btn-arrow {
  position: relative;
  z-index: 1;
  font-size: 1.05rem;
  line-height: 1;
}
.cursor-btn:hover {
  border-color: rgba(255,255,255,0.45);
}
.cursor-btn:disabled {
  opacity: 0.4;
  cursor: not-allowed;
}
.cursor-btn.at-extreme {
  opacity: 0.6;
  cursor: not-allowed;
}
.cursor-btn.at-extreme .btn-arrow {
  opacity: 0.4;
}
.cursor-midpoint-info {
  font-size: 0.65rem;
  font-weight: 400;
  color: var(--muted);
  opacity: 0.75;
}

/* Button callouts showing next value */
.btn-callout {
  position: relative;
  z-index: 1;
  font-size: 0.6rem;
  font-weight: 500;
  opacity: 0.85;
  min-width: 32px;
  text-align: center;
}
.btn-callout.left {
  margin-right: 4px;
}
.btn-callout.right {
  margin-left: 4px;
}
.btn-callout:empty {
  display: none;
}

/* Dual Range Slider - fixed from llm_access for proper left handle grabbing */
.dual-range {
  position: relative;
  display: flex;
  align-items: center;
  gap: 8px;
}
.dual-track {
  position: relative;
  flex: 1;
  height: 6px;
  background: rgba(255,255,255,0.3);
  border-radius: 3px;
}
.dual-track.color-track {
  height: 8px;
  border-radius: 4px;
}
.dual-fill {
  position: absolute;
  top: 0;
  height: 100%;
  background: var(--accent);
  border-radius: inherit;
  pointer-events: none;
}
.dual-mask {
  position: absolute;
  top: 0;
  height: 100%;
  background: rgba(0,0,0,0.7);
  pointer-events: none;
}
.dual-range input[type=range] {
  position: absolute;
  left: 0;
  right: 0;
  top: 0;
  width: 100%;
  height: 20px;
  background: transparent;
  pointer-events: none;
  cursor: pointer;
}
.dual-range input[type=range]::-webkit-slider-runnable-track {
  background: transparent;
}
.dual-range input[type=range]::-moz-range-track {
  background: transparent;
}
.dual-range input[type=range]::-webkit-slider-thumb {
  pointer-events: auto;
}
.dual-range input[type=range]::-moz-range-thumb {
  pointer-events: auto;
}
.dual-range input[type=range].range-min {
  z-index: 4;
}
.dual-range input[type=range].range-max {
  z-index: 3;
}
.dual-chip {
  font-size: 0.85rem;
  color: var(--muted);
  min-width: 60px;
}
.dual-chip.right { text-align: right; }

/* Color Value Chip Button */
.color-value-chip {
  border: none;
  border-radius: 999px;
  padding: 6px 14px;
  font-size: 0.85rem;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.15s;
  min-width: 80px;
  text-align: center;
}
.color-value-chip:hover {
  filter: brightness(1.1);
}

/* Temporary ceiling/floor chip (shown when runtime differs from config) */
.temp-ceiling-chip {
  display: inline-block;
  border-radius: 999px;
  padding: 4px 10px;
  font-size: 0.75rem;
  font-weight: 600;
  margin-left: 6px;
  background: rgba(255, 255, 255, 0.15);
  color: #ccc;
  border: 1px dashed rgba(255, 255, 255, 0.3);
}
.temp-ceiling-chip.hidden {
  display: none;
}

/* Temporary bounds row */
.temp-bounds-row {
  display: flex;
  align-items: center;
  gap: 8px;
  padding: 4px 0 4px 140px;
  font-size: 0.8rem;
}
.temp-bounds-row.hidden {
  display: none;
}
.temp-bounds-label {
  color: #888;
  font-style: italic;
}

/* Lock checkbox for range controls */
.lock-checkbox-wrap {
  display: inline-flex;
  align-items: center;
  gap: 4px;
  margin-left: 8px;
  font-size: 0.75rem;
  color: #888;
  cursor: pointer;
  user-select: none;
}
.lock-checkbox-wrap input[type="checkbox"] {
  width: 14px;
  height: 14px;
  margin: 0;
  cursor: pointer;
  accent-color: #666;
}
.lock-checkbox-wrap .lock-icon {
  font-size: 0.8rem;
  opacity: 0.6;
}
.lock-checkbox-wrap input[type="checkbox"]:checked + .lock-icon {
  opacity: 1;
  color: #f5a623;
}

/* Color Slider Popup */
.color-controls-wrap {
  position: relative;
  display: inline-block;
}
.color-slider-popup {
  position: absolute;
  top: calc(100% + 8px);
  left: 50%;
  transform: translateX(-50%);
  background: #101010;
  border: 1px solid rgba(255,255,255,0.12);
  border-radius: 10px;
  padding: 12px 14px;
  box-shadow: 0 12px 24px rgba(0,0,0,0.45);
  min-width: 280px;
  display: none;
  z-index: 50;
}
.color-slider-popup.is-open {
  display: block;
}
.color-slider-popup .dual-track {
  height: 10px;
  border-radius: 5px;
}
.color-slider-popup input[type=range] {
  height: 20px;
}

/* Offset Slider Rows */
.offset-slider-row {
  display: grid;
  grid-template-columns: 60px 1fr 140px;
  gap: 10px;
  align-items: center;
  margin: 8px 0;
}
.offset-slider-row label {
  font-size: 0.8rem;
  color: var(--muted2);
  text-transform: lowercase;
}
.offset-slider-row .offset-text {
  font-size: 0.75rem;
  color: var(--muted);
}

/* Color Rule Stack - grouped layout like llm_access */
.color-rule-grid {
  display: flex;
  flex-direction: column;
  gap: 20px;
  margin-top: 16px;
}
.color-rule-stack {
  display: grid;
  grid-template-columns: 150px minmax(0, 1fr);
  gap: 18px;
  padding: 12px 0;
  border-top: 1px solid var(--line);
}
.color-rule-stack:first-child { border-top: none; padding-top: 0; }
.color-rule-stack-label {
  display: flex;
  flex-direction: column;
  align-items: flex-start;
  gap: 8px;
  position: relative;
  padding-right: 12px;
}
.color-rule-stack-label::after {
  content: '';
  position: absolute;
  top: 0;
  right: 0;
  bottom: 0;
  width: 1px;
  background: rgba(255,255,255,0.2);
}
.color-rule-label {
  font-size: 1rem;
  font-weight: 600;
  color: var(--text);
}
.info-icon {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  position: relative;
  width: 16px;
  height: 16px;
  margin-left: 6px;
  font-size: 11px;
  font-weight: 600;
  color: rgba(255,255,255,0.5);
  border: 1px solid rgba(255,255,255,0.3);
  border-radius: 50%;
  cursor: pointer;
  vertical-align: middle;
  user-select: none;
  transition: all 0.15s ease;
}
.info-icon:hover {
  color: rgba(255,255,255,0.8);
  border-color: rgba(255,255,255,0.5);
}
.info-tooltip {
  display: none;
  position: absolute;
  top: 24px;
  left: 50%;
  transform: translateX(-50%);
  width: 280px;
  padding: 10px 12px;
  background: rgba(30,30,35,0.98);
  border: 1px solid rgba(255,255,255,0.2);
  border-radius: 8px;
  font-size: 0.85rem;
  font-weight: 400;
  line-height: 1.4;
  color: rgba(255,255,255,0.85);
  box-shadow: 0 4px 12px rgba(0,0,0,0.3);
  z-index: 100;
}
.info-tooltip.is-open {
  display: block;
}
.color-rule-toggle {
  margin-left: 0;
}
.color-rule-toggle input[type=checkbox] {
  width: 16px;
  height: 16px;
  accent-color: #7CFF72;
}
.color-rule-stack-body {
  display: flex;
  flex-direction: column;
  gap: 10px;
}
.color-rule-stack-body.is-disabled {
  opacity: 0.4;
  pointer-events: none;
}
.color-rule-main-row {
  display: flex;
  gap: 12px;
  align-items: center;
  flex-wrap: wrap;
}
.color-rule-main-row select {
  padding: 6px 10px;
  border-radius: 8px;
  border: 1px solid var(--line);
  background: var(--panel2);
  color: var(--text);
  font-size: 0.9rem;
}
.color-rule-slider-row {
  width: 100%;
}
.color-rule-slider-row.is-disabled {
  opacity: 0.4;
  pointer-events: none;
}

/* Legacy solar-rule classes for backward compatibility */
.solar-rule-offsets {
  display: flex;
  flex-direction: column;
  gap: 8px;
}


/* Buttons */
.btn {
  border: 1px solid rgba(255,255,255,0.3);
  background: rgba(255,255,255,0.1);
  color: #fff;
  padding: 10px 20px;
  border-radius: 8px;
  cursor: pointer;
  font-weight: 600;
  font-size: 0.9rem;
  transition: all 0.15s;
}
.btn:hover { background: rgba(255,255,255,0.15); }
.btn-primary {
  background: var(--accent);
  border-color: var(--accent);
}
.btn-primary:hover { filter: brightness(1.1); }

/* Collapsible Section */
.collapsible-section {
  margin-top: 16px;
  border-top: 1px solid var(--line);
  padding-top: 12px;
}
.collapsible-header {
  display: flex;
  align-items: center;
  gap: 8px;
  cursor: pointer;
  user-select: none;
  color: var(--muted);
  font-size: 0.85rem;
}
.collapsible-header:hover {
  color: var(--text);
}
.collapsible-arrow {
  transition: transform 0.2s ease;
  font-size: 0.7rem;
}
.collapsible-section.is-open .collapsible-arrow {
  transform: rotate(90deg);
}
.collapsible-content {
  display: none;
  padding-top: 12px;
}
.collapsible-section.is-open .collapsible-content {
  display: block;
}
.location-grid {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 12px;
}
.location-field {
  display: flex;
  flex-direction: column;
  gap: 4px;
}
.location-field label {
  font-size: 0.8rem;
  color: var(--muted);
}
.location-field input {
  padding: 8px 10px;
  border-radius: 6px;
  border: 1px solid var(--line);
  background: var(--panel2);
  color: var(--text);
  font-size: 0.9rem;
}
.location-field input:disabled {
  opacity: 0.5;
}
.location-toggle {
  display: flex;
  align-items: center;
  gap: 8px;
  margin-bottom: 12px;
  font-size: 0.85rem;
  color: var(--muted);
}
.location-toggle input[type=checkbox] {
  width: 14px;
  height: 14px;
}

/* Status Messages */
.success {
  color: #51cf66;
  font-size: 0.9rem;
  margin: 10px 0;
  padding: 12px 16px;
  background: rgba(81,207,102,0.15);
  border: 1px solid rgba(81,207,102,0.3);
  border-radius: 8px;
  font-weight: 600;
}
.error {
  color: #ff6b6b;
  font-size: 0.9rem;
  margin: 10px 0;
  padding: 12px 16px;
  background: rgba(255,107,107,0.15);
  border: 1px solid rgba(255,107,107,0.3);
  border-radius: 8px;
  font-weight: 600;
}

/* Live Design Controls */
.live-design-controls {
  display: flex;
  justify-content: center;
  align-items: center;
  padding: 12px 0;
  border-top: 1px solid var(--line);
  margin-top: 8px;
  gap: 16px;
}
.live-design-controls label {
  font-size: 0.9rem;
  color: var(--muted);
  font-weight: 600;
}
.live-design-controls select {
  padding: 8px 12px;
  border-radius: 8px;
  border: 1px solid rgba(255,255,255,0.35);
  background: rgba(255,255,255,0.06);
  color: #fff;
  min-width: 180px;
  font-size: 0.9rem;
}
.live-design-controls select:focus {
  outline: none;
  border-color: var(--accent);
}
.live-design-controls .btn.active {
  background: var(--accent);
  color: #fff;
}
.live-design-status {
  font-size: 0.8rem;
  color: var(--muted2);
  margin-left: 8px;
}
.live-design-status.active {
  color: #4ade80;
}

/* Responsive */
@media (max-width: 640px) {
  .param-row { grid-template-columns: 1fr; gap: 4px; }
  .cursor-controls { flex-wrap: wrap; gap: 24px; }
  .solar-rule { grid-template-columns: 1fr; }
}
</style>
</head>
<body>
<div class="container">
  <div class="header">
    <h1>Circadian Light by HomeGlo</h1>
    <div class="header-actions">
      <button id="save-config" class="btn btn-primary">Save</button>
    </div>
  </div>
  <div id="save-status"></div>

  <!-- Activity Preset -->
  <div class="activity-select">
    <label for="activity-preset">Activity Preset</label>
    <select id="activity-preset">
      <option value="young">Young Child</option>
      <option value="adult" selected>Adult</option>
      <option value="nightowl">Night Owl</option>
      <option value="duskbat">Dusk Bat</option>
      <option value="shiftearly">Overnight Shift Early</option>
      <option value="shiftlate">Overnight Shift Late</option>
    </select>
  </div>

  <!-- Ascend/Descend Timing -->
  <div class="timing-grid">
    <div class="section-block section-block--ascend">
      <h2>Ascend</h2>
      <div class="header-timeline"><span class="time-badge" id="ascend-start-badge">4:00a</span></div>
      <div class="param-row is-hidden">
        <label>Ascend starts</label>
        <span class="value" id="ascend-start-display">3:00a</span>
        <input type="range" id="ascend-start" min="0" max="24" step="0.5" value="3">
      </div>
      <div class="param-row">
        <label>Wake time</label>
        <span class="value" id="wake-time-display">6:00a</span>
        <input type="range" id="wake-time" min="0" max="24" step="0.5" value="6">
      </div>
      <div class="param-row">
        <label>Wake speed</label>
        <span class="value" id="wake-speed-display">Fast (8)</span>
        <input type="range" id="wake-speed" min="1" max="10" step="1" value="8">
      </div>
    </div>

    <div class="section-block section-block--descend">
      <h2>Descend</h2>
      <div class="header-timeline"><span class="time-badge" id="descend-start-badge">12:00p</span></div>
      <div class="param-row is-hidden">
        <label>Descend starts</label>
        <span class="value" id="descend-start-display">12:00p</span>
        <input type="range" id="descend-start" min="0" max="36" step="0.5" value="12">
      </div>
      <div class="param-row">
        <label>Bed time</label>
        <span class="value" id="bed-time-display">10:00p</span>
        <input type="range" id="bed-time" min="0" max="36" step="0.5" value="22">
      </div>
      <div class="param-row">
        <label>Bed speed</label>
        <span class="value" id="bed-speed-display">Crisp (6)</span>
        <input type="range" id="bed-speed" min="1" max="10" step="1" value="6">
      </div>
    </div>
  </div>

  <!-- Chart -->
  <div class="section-block">
    <div class="chart-date-control">
      <span class="chart-date-display" id="chart-date-display">Today</span>
      <input type="range" id="chart-date-slider" min="0" max="364" value="0">
    </div>
    <div class="chart-wrapper">
      <div id="chart"></div>
      <div class="time-hover-label" id="time-hover-label"></div>
      <div class="graph-cursor-callout" id="cursor-callout"></div>
    </div>

    <!-- Cursor Controls -->
    <div class="cursor-controls hidden" id="cursor-controls">
      <div class="cursor-stack wide">
        <span class="cursor-stack-label">Cursor</span>
        <div class="cursor-btn-row horizontal">
          <button class="cursor-btn time-nav" id="cursor-time-minus" title="-5 minutes">
            <span class="time-nav-header"><span class="time-nav-label">-5</span> <span class="time-nav-time" id="time-minus-time"></span></span>
            <span class="time-nav-values" id="time-minus-values"></span>
          </button>
          <button class="cursor-btn time-nav" id="cursor-time-plus" title="+5 minutes">
            <span class="time-nav-header"><span class="time-nav-label">+5</span> <span class="time-nav-time" id="time-plus-time"></span></span>
            <span class="time-nav-values" id="time-plus-values"></span>
          </button>
          <button class="btn" id="cursor-time-now" title="Now">Now</button>
        </div>
      </div>
      <div class="cursor-divider"></div>
      <div class="cursor-stack">
        <span class="cursor-stack-label">Step <input type="number" class="increment-input" id="step-increments" min="1" max="50" title="Step increments"></span>
        <div class="cursor-btn-row">
          <button class="cursor-btn wide" id="cursor-step-up" data-mode="combo" title="Step Up">
            <span class="btn-callout left" id="step-up-bri-callout"></span>
            <span class="btn-arrow">â†‘</span>
            <span class="btn-callout right" id="step-up-cct-callout"></span>
          </button>
          <button class="cursor-btn wide" id="cursor-step-down" data-mode="combo" title="Step Down">
            <span class="btn-callout left" id="step-down-bri-callout"></span>
            <span class="btn-arrow">â†“</span>
            <span class="btn-callout right" id="step-down-cct-callout"></span>
          </button>
        </div>
      </div>
      <div class="cursor-stack">
        <span class="cursor-stack-label">Bright <input type="number" class="increment-input" id="brightness-increments" min="1" max="50" title="Brightness increments"> <span class="cursor-midpoint-info" id="brightness-midpoint-info"></span></span>
        <div class="cursor-btn-row">
          <button class="cursor-btn" id="cursor-bright-up" data-mode="brightness" title="Brighten">
            <span class="btn-callout left" id="bright-up-callout"></span>
            <span class="btn-arrow">â†‘</span>
          </button>
          <button class="cursor-btn" id="cursor-bright-down" data-mode="brightness" title="Dim">
            <span class="btn-callout left" id="bright-down-callout"></span>
            <span class="btn-arrow">â†“</span>
          </button>
        </div>
      </div>
      <div class="cursor-stack">
        <span class="cursor-stack-label">Color <input type="number" class="increment-input" id="color-increments" min="1" max="50" title="Color increments"> <span class="cursor-midpoint-info" id="color-midpoint-info"></span></span>
        <div class="cursor-btn-row">
          <button class="cursor-btn" id="cursor-color-up" data-mode="color" title="Cooler">
            <span class="btn-arrow">â†‘</span>
            <span class="btn-callout right" id="color-up-callout"></span>
          </button>
          <button class="cursor-btn" id="cursor-color-down" data-mode="color" title="Warmer">
            <span class="btn-arrow">â†“</span>
            <span class="btn-callout right" id="color-down-callout"></span>
          </button>
        </div>
      </div>
      <div class="cursor-stack">
        <span class="cursor-stack-label">&nbsp;</span>
        <div class="cursor-btn-row">
          <button class="btn" id="cursor-reset">Reset</button>
        </div>
      </div>
    </div>

    <!-- Live Design Controls -->
    <div class="live-design-controls" id="live-design-controls">
      <label for="live-area-select">Live Design:</label>
      <select id="live-area-select">
        <option value="">Select Area</option>
      </select>
      <button class="btn" id="live-design-toggle">Enable</button>
      <span class="live-design-status" id="live-design-status"></span>
    </div>
  </div>

  <!-- Brightness & Color Range -->
  <div class="section-block">
    <h2>Brightness &amp; Color</h2>

    <div class="param-row" style="grid-template-columns: 140px 60px 1fr 60px 28px;">
      <label>Color range</label>
      <span class="dual-chip" id="color-min-display">500 K</span>
      <div class="dual-range">
        <div class="dual-track color-track" id="color-track">
          <div class="dual-mask" id="color-mask-left"></div>
          <div class="dual-mask" id="color-mask-right"></div>
        </div>
        <input type="range" id="color-min" class="range-min" min="500" max="6500" step="100" value="500">
        <input type="range" id="color-max" class="range-max" min="500" max="6500" step="100" value="6500">
      </div>
      <span class="dual-chip right" id="color-max-display">6500 K</span>
      <label class="lock-checkbox-wrap" title="Lock color range bounds"><input type="checkbox" id="color-range-locked"><span class="lock-icon">ðŸ”’</span></label>
    </div>

    <div class="param-row" style="grid-template-columns: 140px 60px 1fr 60px 28px;">
      <label>Brightness range</label>
      <span class="dual-chip" id="brightness-min-display">1%</span>
      <div class="dual-range">
        <div class="dual-track">
          <div class="dual-fill" id="brightness-fill"></div>
        </div>
        <input type="range" id="brightness-min" class="range-min" min="1" max="100" step="1" value="1">
        <input type="range" id="brightness-max" class="range-max" min="1" max="100" step="1" value="100">
      </div>
      <span class="dual-chip right" id="brightness-max-display">100%</span>
      <label class="lock-checkbox-wrap" title="Lock brightness range bounds"><input type="checkbox" id="brightness-range-locked"><span class="lock-icon">ðŸ”’</span></label>
    </div>

    <!-- Temporary bounds indicator (shown when runtime bounds differ from config) -->
    <div class="temp-bounds-row hidden" id="temp-bounds-row">
      <span class="temp-bounds-label">Temporary:</span>
      <span class="temp-ceiling-chip hidden" id="temp-bri-min-chip"></span>
      <span class="temp-ceiling-chip hidden" id="temp-bri-max-chip"></span>
      <span class="temp-ceiling-chip hidden" id="temp-color-min-chip"></span>
      <span class="temp-ceiling-chip hidden" id="temp-color-max-chip"></span>
    </div>

    <div class="param-row">
      <label>Increments</label>
      <span class="value" id="step-count-display">10 steps</span>
      <input type="range" id="step-count" min="1" max="50" step="1" value="10">
    </div>

    <!-- Color Rules - integrated into Brightness & Color -->
    <div class="color-rule-grid">
      <div class="color-rule-stack" data-color-row="night">
        <div class="color-rule-stack-label">
          <label class="color-rule-label">Warm night<span class="info-icon" data-tooltip="warm-night-info">i<span class="info-tooltip" id="warm-night-info">Sets a minimum warmth when sun isn't up; if your Circadian curve is cool (high Kelvin) between sunset and the next day's sunrise, this applies warming.</span></span></label>
          <div class="color-rule-toggle">
            <input type="checkbox" id="warm-night-enabled">
          </div>
        </div>
        <div class="color-rule-stack-body" id="warm-night-body">
          <div class="color-rule-main-row">
            <select id="warm-night-mode">
              <option value="all">all night</option>
              <option value="sunrise">before sunrise</option>
              <option value="sunset">after sunset</option>
            </select>
            <div class="color-controls-wrap">
              <button type="button" class="color-value-chip" id="warm-night-target-chip">2700 K</button>
              <span class="temp-ceiling-chip hidden" id="warm-night-ceiling-chip">â†’ 3300 K</span>
              <label class="lock-checkbox-wrap" title="Lock warm night ceiling"><input type="checkbox" id="warm-night-locked"><span class="lock-icon">ðŸ”’</span></label>
              <div class="color-slider-popup" id="warm-night-popup">
                <div class="dual-range">
                  <div class="dual-track color-track" id="warm-night-track"></div>
                  <input type="range" id="warm-night-target" class="range-min" min="500" max="4000" step="100" value="2700">
                </div>
              </div>
            </div>
          </div>
          <div class="color-rule-slider-row" data-rule-window="sunset">
            <div class="offset-slider-row">
              <label>Start</label>
              <input type="range" id="warm-night-start" min="-180" max="180" step="5" value="-60">
              <span class="offset-text" id="warm-night-start-text">60 min before sunset</span>
            </div>
          </div>
          <div class="color-rule-slider-row" data-rule-window="sunrise">
            <div class="offset-slider-row">
              <label>End</label>
              <input type="range" id="warm-night-end" min="-180" max="180" step="5" value="60">
              <span class="offset-text" id="warm-night-end-text">60 min after sunrise</span>
            </div>
          </div>
          <div class="color-rule-slider-row" data-rule-window="any">
            <div class="offset-slider-row">
              <label>Fade</label>
              <input type="range" id="warm-night-fade" min="0" max="180" step="5" value="60">
              <span class="offset-text" id="warm-night-fade-text">60 min</span>
            </div>
          </div>
        </div>
      </div>

      <div class="color-rule-stack" data-color-row="daylight">
        <div class="color-rule-stack-label">
          <label class="color-rule-label">Cool day<span class="info-icon" data-tooltip="cool-day-info">i<span class="info-tooltip" id="cool-day-info">Sets a minimum coolness when the sun is up; if your Circadian curve is warm (low Kelvin) between sunrise and sunset, this applies cooling.</span></span></label>
          <div class="color-rule-toggle">
            <input type="checkbox" id="cool-day-enabled">
          </div>
        </div>
        <div class="color-rule-stack-body" id="cool-day-body">
          <div class="color-rule-main-row">
            <select id="cool-day-mode">
              <option value="all">all day</option>
              <option value="sunrise">after sunrise</option>
              <option value="sunset">before sunset</option>
            </select>
            <div class="color-controls-wrap">
              <button type="button" class="color-value-chip" id="cool-day-target-chip">6500 K</button>
              <span class="temp-ceiling-chip hidden" id="cool-day-floor-chip">â†’ 5000 K</span>
              <label class="lock-checkbox-wrap" title="Lock cool day floor"><input type="checkbox" id="cool-day-locked"><span class="lock-icon">ðŸ”’</span></label>
              <div class="color-slider-popup" id="cool-day-popup">
                <div class="dual-range">
                  <div class="dual-track color-track" id="cool-day-track"></div>
                  <input type="range" id="cool-day-target" class="range-min" min="4000" max="6500" step="100" value="6500">
                </div>
              </div>
            </div>
          </div>
          <div class="color-rule-slider-row" data-rule-window="sunrise">
            <div class="offset-slider-row">
              <label>Start</label>
              <input type="range" id="cool-day-start" min="-180" max="180" step="5" value="0">
              <span class="offset-text" id="cool-day-start-text">at sunrise</span>
            </div>
          </div>
          <div class="color-rule-slider-row" data-rule-window="sunset">
            <div class="offset-slider-row">
              <label>End</label>
              <input type="range" id="cool-day-end" min="-180" max="180" step="5" value="0">
              <span class="offset-text" id="cool-day-end-text">at sunset</span>
            </div>
          </div>
          <div class="color-rule-slider-row" data-rule-window="any">
            <div class="offset-slider-row">
              <label>Fade</label>
              <input type="range" id="cool-day-fade" min="0" max="180" step="5" value="60">
              <span class="offset-text" id="cool-day-fade-text">60 min</span>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Collapsible Location Section -->
    <div class="collapsible-section" id="location-section">
      <div class="collapsible-header" id="location-header">
        <span class="collapsible-arrow">â–¶</span>
        <span>Location</span>
        <span id="location-summary" style="margin-left: auto; opacity: 0.7;"></span>
      </div>
      <div class="collapsible-content">
        <div class="location-toggle">
          <input type="checkbox" id="use-ha-location" checked>
          <label for="use-ha-location">Use Home Assistant location</label>
        </div>
        <div class="location-grid">
          <div class="location-field">
            <label>Latitude</label>
            <input type="number" id="location-lat" step="0.0001" value="35.0">
          </div>
          <div class="location-field">
            <label>Longitude</label>
            <input type="number" id="location-lon" step="0.0001" value="-78.6">
          </div>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
// ============================================================
// Circadian Light Designer - Ascend/Descend Model
// ============================================================

const GRAPH_Y_MAX = 150;
const SPEED_LABELS = ['', 'Calm', 'Gentle', 'Soft', 'Smooth', 'Balanced', 'Crisp', 'Fast', 'Snappy', 'Quick', 'Sharp'];
const SPEED_TO_SLOPE = [0, 0.4, 0.6, 0.8, 1.0, 1.3, 1.7, 2.3, 3.0, 4.0, 5.5];

// Colors matching llm_access.html
const ASCEND_COLORS = {
  shade: 'rgba(120,190,255,0.35)',
  text: '#5cb3ff',
  boundary: 'rgba(120,185,245,0.55)',
  axis: '#5cb3ff',
  hoverBg: '#7fc7ff'
};
const DESCEND_COLORS = {
  shade: 'rgba(255,220,100,0.12)',
  text: '#ffe680',
  boundary: 'rgba(255,230,128,0.85)',
  axis: 'rgba(255,230,128,0.7)',
  hoverBg: '#ffe680'
};

// Activity Presets
// warm_night_enabled: true for young, adult, nightowl (per llm_access)
// cool_day_enabled: false for all (per llm_access)
const ACTIVITY_PRESETS = {
  young: { wake_time: 6.0, bed_time: 18.0, ascend_start: 0.0, descend_start: 12.0, warm_night_enabled: true, cool_day_enabled: false },
  adult: { wake_time: 6.0, bed_time: 22.0, ascend_start: 4.0, descend_start: 12.0, warm_night_enabled: true, cool_day_enabled: false },
  nightowl: { wake_time: 10.0, bed_time: 2.0, ascend_start: 8.0, descend_start: 16.0, warm_night_enabled: true, cool_day_enabled: false },
  duskbat: { wake_time: 14.0, bed_time: 6.0, ascend_start: 12.0, descend_start: 20.0, warm_night_enabled: false, cool_day_enabled: false },
  shiftearly: { wake_time: 18.0, bed_time: 10.0, ascend_start: 16.0, descend_start: 0.0, warm_night_enabled: false, cool_day_enabled: false },
  shiftlate: { wake_time: 22.0, bed_time: 14.0, ascend_start: 20.0, descend_start: 4.0, warm_night_enabled: false, cool_day_enabled: false }
};

// State
let config = {
  ascend_start: 3.0,
  descend_start: 12.0,
  wake_time: 6.0,
  bed_time: 22.0,
  wake_speed: 8,
  bed_speed: 6,
  min_color_temp: 500,
  max_color_temp: 6500,
  min_brightness: 1,
  max_brightness: 100,
  max_dim_steps: 10,
  step_increments: null,        // defaults to max_dim_steps
  brightness_increments: null,  // defaults to max_dim_steps
  color_increments: null,       // defaults to max_dim_steps
  warm_night_enabled: true,  // default matches adult preset
  warm_night_mode: 'all',
  warm_night_target: 2700,
  warm_night_start: -60,  // minutes offset from sunset (negative = before)
  warm_night_end: 60,     // minutes offset from sunrise (positive = after)
  warm_night_fade: 60,    // fade duration in minutes
  cool_day_enabled: false,
  cool_day_mode: 'all',
  cool_day_target: 6500,
  cool_day_start: 0,      // minutes offset from sunrise
  cool_day_end: 0,        // minutes offset from sunset
  cool_day_fade: 60,      // fade duration in minutes
  activity_preset: 'adult',
  use_ha_location: true,
  latitude: 35.0,
  longitude: -78.6,
  timezone: 'US/Eastern'
};

// Current sun times (cached for solar rules)
let sunTimes = { sunrise: 6, sunset: 18, solarNoon: 12, solarMid: 0 };

// Runtime state for current phase (resets at phase transitions)
// Only one phase is active at a time, so we only need one midpoint per axis
let runtimeState = {
  enabled: false,              // Whether circadian lighting is active
  frozen: false,               // Whether to freeze at current position (stop following time)
  brightness_mid: null,        // Current phase's brightness midpoint (falls back to wake_time or bed_time)
  color_mid: null,             // Current phase's color midpoint (falls back to wake_time or bed_time)
  solar_rule_color_limit: null, // Pushed ceiling/floor for active solar rule
  // Brightness bounds (can be pushed beyond config via Bright Up/Down)
  max_brightness: null,        // Can only increase above config.max_brightness (absolute max: 100)
  min_brightness: null,        // Can only decrease below config.min_brightness (absolute min: 1)
  // Color bounds (can be pushed beyond config via Color Up/Down)
  max_color_temp: null,        // Can only increase above config.max_color_temp (absolute max: 6500)
  min_color_temp: null         // Can only decrease below config.min_color_temp (absolute min: 500)
};

// Cursor state
let cursorHour = null;
let graphData = null;
let lastCursorPhase = null;  // Track phase for reset on transition

// Live Design state
let liveDesignEnabled = false;
let liveDesignAreaId = null;

// ============================================================
// Solar Calculation Helpers
// ============================================================

const rad = d => d * Math.PI / 180;

function wrap24(x) {
  return ((x % 24) + 24) % 24;
}

// Check if hour is within a time window (handles midnight wrap-around)
function isInTimeWindow(hour, windowStart, windowEnd) {
  hour = wrap24(hour);
  windowStart = wrap24(windowStart);
  windowEnd = wrap24(windowEnd);

  if (windowStart > windowEnd) {
    // Wraps around midnight
    return hour >= windowStart || hour <= windowEnd;
  } else {
    return hour >= windowStart && hour <= windowEnd;
  }
}

// Get warm_night window boundaries based on current config and sun times
function getWarmNightWindow() {
  if (!config || !sunTimes || !config.warm_night_enabled) return null;

  const { sunrise, sunset } = sunTimes;
  const solarMid = wrap24(sunTimes.solarMid);
  const startOffsetHrs = config.warm_night_start / 60;
  const endOffsetHrs = config.warm_night_end / 60;
  const mode = config.warm_night_mode;

  let windowStart, windowEnd;
  if (mode === 'sunrise') {
    windowStart = solarMid;
    windowEnd = wrap24(sunrise + endOffsetHrs);
  } else if (mode === 'sunset') {
    windowStart = wrap24(sunset + startOffsetHrs);
    windowEnd = solarMid;
  } else {
    windowStart = wrap24(sunset + startOffsetHrs);
    windowEnd = wrap24(sunrise + endOffsetHrs);
  }

  return { windowStart, windowEnd };
}

// Get cool_day window boundaries based on current config and sun times
function getCoolDayWindow() {
  if (!config || !sunTimes || !config.cool_day_enabled) return null;

  const { sunrise, sunset } = sunTimes;
  const solarNoon = wrap24(sunTimes.solarNoon);
  const startOffsetHrs = config.cool_day_start / 60;
  const endOffsetHrs = config.cool_day_end / 60;
  const mode = config.cool_day_mode;

  let windowStart, windowEnd;
  if (mode === 'sunrise') {
    windowStart = wrap24(sunrise + startOffsetHrs);
    windowEnd = solarNoon;
  } else if (mode === 'sunset') {
    windowStart = solarNoon;
    windowEnd = wrap24(sunset + endOffsetHrs);
  } else {
    windowStart = wrap24(sunrise + startOffsetHrs);
    windowEnd = wrap24(sunset + endOffsetHrs);
  }

  return { windowStart, windowEnd };
}

// ============================================================
// Single-Point Value Calculation (source of truth)
// ============================================================

/**
 * Check if hour is in window and calculate fade weight.
 */
function getWindowWeight(hour, windowStart, windowEnd, fadeHrs) {
  const h = wrap24(hour);
  let inWindow = false;
  let distFromStart = 0;
  let distToEnd = 0;

  if (windowStart > windowEnd) {
    // Wraps around midnight
    inWindow = h >= windowStart || h <= windowEnd;
    if (inWindow) {
      distFromStart = h >= windowStart ? (h - windowStart) : (h + 24 - windowStart);
      distToEnd = h <= windowEnd ? (windowEnd - h) : (windowEnd + 24 - h);
    }
  } else {
    // Normal range
    inWindow = h >= windowStart && h <= windowEnd;
    if (inWindow) {
      distFromStart = h - windowStart;
      distToEnd = windowEnd - h;
    }
  }

  if (!inWindow) {
    return { inWindow: false, weight: 0 };
  }

  // Calculate fade weight
  let weight = 1;
  if (fadeHrs > 0.01) {
    if (distFromStart < fadeHrs) {
      weight = Math.min(weight, distFromStart / fadeHrs);
    }
    if (distToEnd < fadeHrs) {
      weight = Math.min(weight, distToEnd / fadeHrs);
    }
  }

  return { inWindow: true, weight };
}

/**
 * Apply warm_night and cool_day solar rules to a single CCT value at a given hour.
 */
function applySolarRuleAtHour(baseCCT, hour) {
  if (!sunTimes) return baseCCT;

  let cct = baseCCT;
  const { sunrise, sunset, solarNoon, solarMid } = sunTimes;

  // Warm night - ceiling
  if (config.warm_night_enabled) {
    const warmTarget = runtimeState.solar_rule_color_limit ?? config.warm_night_target;

    if (cct > warmTarget) {
      const fadeHrs = config.warm_night_fade / 60;
      const startOffsetHrs = config.warm_night_start / 60;
      const endOffsetHrs = config.warm_night_end / 60;
      const mode = config.warm_night_mode;

      let windowStart, windowEnd;
      if (mode === 'sunrise') {
        windowStart = wrap24(solarMid);
        windowEnd = wrap24(sunrise + endOffsetHrs);
      } else if (mode === 'sunset') {
        windowStart = wrap24(sunset + startOffsetHrs);
        windowEnd = wrap24(solarMid);
      } else {
        windowStart = wrap24(sunset + startOffsetHrs);
        windowEnd = wrap24(sunrise + endOffsetHrs);
      }

      const { inWindow, weight } = getWindowWeight(hour, windowStart, windowEnd, fadeHrs);
      if (inWindow && weight > 0) {
        cct = cct + (warmTarget - cct) * weight;
      }
    }
  }

  // Cool day - floor
  if (config.cool_day_enabled) {
    const coolTarget = runtimeState.solar_rule_color_limit ?? config.cool_day_target;

    if (cct < coolTarget) {
      const fadeHrs = config.cool_day_fade / 60;
      const startOffsetHrs = config.cool_day_start / 60;
      const endOffsetHrs = config.cool_day_end / 60;
      const mode = config.cool_day_mode;

      let windowStart, windowEnd;
      if (mode === 'sunrise') {
        windowStart = wrap24(sunrise + startOffsetHrs);
        windowEnd = wrap24(solarNoon);
      } else if (mode === 'sunset') {
        windowStart = wrap24(solarNoon);
        windowEnd = wrap24(sunset + endOffsetHrs);
      } else {
        windowStart = wrap24(sunrise + startOffsetHrs);
        windowEnd = wrap24(sunset + endOffsetHrs);
      }

      const { inWindow, weight } = getWindowWeight(hour, windowStart, windowEnd, fadeHrs);
      if (inWindow && weight > 0) {
        cct = cct + (coolTarget - cct) * weight;
      }
    }
  }

  return cct;
}

/**
 * Calculate brightness, CCT, and phase at a specific hour.
 * Single source of truth for curve + solar rule calculations.
 */
function getValuesAtTime(hour) {
  // Phase detection
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  const h48 = hour < tAscend ? hour + 24 : hour;
  const inAscend = h48 >= tAscend && h48 < tDescend;
  const phase = inAscend ? 'Ascend' : 'Descend';

  // Slopes - clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];

  // Bounds
  const bMin = (runtimeState.min_brightness ?? config.min_brightness) / 100;
  const bMax = (runtimeState.max_brightness ?? config.max_brightness) / 100;
  const cLow = runtimeState.min_color_temp ?? config.min_color_temp;
  const cHigh = runtimeState.max_color_temp ?? config.max_color_temp;

  // Brightness midpoint (runtimeState applies to current phase only)
  const wakeMid = inAscend ? (runtimeState.brightness_mid ?? config.wake_time) : config.wake_time;
  const bedMid = !inAscend ? (runtimeState.brightness_mid ?? config.bed_time) : config.bed_time;

  let wakeMid48 = wakeMid;
  while (wakeMid48 < tAscend) wakeMid48 += 24;
  while (wakeMid48 > tDescend) wakeMid48 -= 24;

  let bedMid48 = bedMid;
  while (bedMid48 < tDescend) bedMid48 += 24;
  while (bedMid48 > tDescend + 24) bedMid48 -= 24;

  // Calculate brightness
  let brightnessNorm;
  if (inAscend) {
    brightnessNorm = logistic(h48, wakeMid48, kAscend, bMin, bMax);
  } else {
    const hDescend48 = h48 < tDescend ? h48 + 24 : h48;
    brightnessNorm = logistic(hDescend48, bedMid48, -kDescend, bMin, bMax);
  }
  const brightness = brightnessNorm * 100;

  // Color midpoint (runtimeState applies to current phase only)
  const colorWakeMid = inAscend ? (runtimeState.color_mid ?? config.wake_time) : config.wake_time;
  const colorBedMid = !inAscend ? (runtimeState.color_mid ?? config.bed_time) : config.bed_time;

  let colorWakeMid48 = colorWakeMid;
  while (colorWakeMid48 < tAscend) colorWakeMid48 += 24;
  while (colorWakeMid48 > tDescend) colorWakeMid48 -= 24;

  let colorBedMid48 = colorBedMid;
  while (colorBedMid48 < tDescend) colorBedMid48 += 24;
  while (colorBedMid48 > tDescend + 24) colorBedMid48 -= 24;

  // Calculate base CCT
  let colorNorm;
  if (inAscend) {
    colorNorm = logistic(h48, colorWakeMid48, kAscend, 0, 1);
  } else {
    const hDescend48 = h48 < tDescend ? h48 + 24 : h48;
    colorNorm = logistic(hDescend48, colorBedMid48, -kDescend, 0, 1);
  }
  colorNorm = Math.max(0, Math.min(1, colorNorm));
  let cct = cLow + (cHigh - cLow) * colorNorm;

  // Apply solar rules
  cct = applySolarRuleAtHour(cct, hour);

  return { brightness, cct, phase };
}

/**
 * Calculate what step up/down would produce.
 * Simulates stepCursor logic to preview button results.
 * @param {Object} cursorPoint - Current cursor point with x (hour), y (brightness), cct
 * @returns {Object} { upBri, upCCT, downBri, downCCT }
 */
function getStepPreview(cursorPoint) {
  // Defensive check
  if (!cursorPoint || !config) {
    return { upBri: 100, upCCT: 4000, downBri: 10, downCCT: 2700 };
  }

  const hour = cursorPoint.x;
  const currentBri = cursorPoint.y;
  const currentCCT = cursorPoint.cct;

  // Step Up/Down uses step_increments
  const steps = config.step_increments ?? config.max_dim_steps ?? 10;
  const configMinBri = config.min_brightness;
  const configMaxBri = config.max_brightness;
  const configMinCCT = config.min_color_temp;
  const configMaxCCT = config.max_color_temp;

  // Current runtime bounds
  const bMin = runtimeState.min_brightness ?? configMinBri;
  const bMax = runtimeState.max_brightness ?? configMaxBri;
  const cMin = runtimeState.min_color_temp ?? configMinCCT;
  const cMax = runtimeState.max_color_temp ?? configMaxCCT;

  // Step size based on config range
  const briStep = (configMaxBri - configMinBri) / steps;

  // Absolute limits
  const ABSOLUTE_MIN_BRI = 1;
  const ABSOLUTE_MAX_BRI = 100;
  const ABSOLUTE_MIN_CCT = 500;
  const ABSOLUTE_MAX_CCT = 6500;

  // Phase detection
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;
  const h48 = hour < tAscend ? hour + 24 : hour;
  const inAscend = h48 >= tAscend && h48 < tDescend;

  // Clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];
  const slope = inAscend ? kAscend : -kDescend;

  // Check lock state
  const brightnessLocked = document.getElementById('brightness-range-locked')?.checked;

  // Helper: calculate CCT for a target brightness (simulates curve traversal)
  function getStepResultCCT(direction, targetBri) {
    const atConfigMax = direction === 'up' && currentBri >= bMax - 0.5;
    const atConfigMin = direction === 'down' && currentBri <= bMin + 0.5;

    if ((atConfigMax || atConfigMin) && !brightnessLocked) {
      // Pushing beyond bounds - proportional push
      const briAbsoluteLimit = direction === 'up' ? ABSOLUTE_MAX_BRI : ABSOLUTE_MIN_BRI;
      const briCurrentBound = direction === 'up' ? bMax : bMin;
      const briHeadroom = Math.abs(briAbsoluteLimit - briCurrentBound);
      const briPushAmount = Math.min(briStep, briHeadroom);
      const pushPercent = briHeadroom > 0 ? briPushAmount / briHeadroom : 0;

      const cctAbsoluteLimit = direction === 'up' ? ABSOLUTE_MAX_CCT : ABSOLUTE_MIN_CCT;
      const cctHeadroom = Math.abs(cctAbsoluteLimit - currentCCT);
      const cctPushAmount = pushPercent * cctHeadroom;

      return direction === 'up' ? currentCCT + cctPushAmount : currentCCT - cctPushAmount;
    }

    // Within bounds - traverse the diverged curve
    // Find virtual time T' where brightness curve = targetBri
    const briMid = runtimeState.brightness_mid ?? (inAscend ? config.wake_time : config.bed_time);
    const colorMid = runtimeState.color_mid ?? (inAscend ? config.wake_time : config.bed_time);

    // Lift midpoints into 48h space
    let briMid48 = briMid;
    let colorMid48 = colorMid;
    if (inAscend) {
      while (briMid48 < tAscend) briMid48 += 24;
      while (colorMid48 < tAscend) colorMid48 += 24;
    } else {
      while (briMid48 < tDescend) briMid48 += 24;
      while (colorMid48 < tDescend) colorMid48 += 24;
    }

    // Calculate virtual time T' where brightness = targetBri
    const bMinNorm = bMin / 100;
    const bMaxNorm = bMax / 100;
    const clampedBri = Math.max(bMin + 0.1, Math.min(bMax - 0.1, targetBri));
    const targetBriNorm = clampedBri / 100;
    const briRatio = (targetBriNorm - bMinNorm) / (bMaxNorm - bMinNorm);

    // Avoid division issues at extremes
    if (briRatio <= 0.001 || briRatio >= 0.999) {
      // At extreme, just use current CCT
      return currentCCT;
    }

    const virtualTime = briMid48 + Math.log(briRatio / (1 - briRatio)) / slope;

    // Get color at virtual time from color curve (base curve)
    let colorNorm;
    if (inAscend) {
      colorNorm = logistic(virtualTime, colorMid48, slope, 0, 1);
    } else {
      const vtDescend = virtualTime < tDescend ? virtualTime + 24 : virtualTime;
      colorNorm = logistic(vtDescend, colorMid48, slope, 0, 1);
    }
    colorNorm = Math.max(0, Math.min(1, colorNorm));
    const baseCCT = cMin + (cMax - cMin) * colorNorm;

    // Clamp to effective bounds (matches stepCursor behavior - no solar rules here)
    return Math.max(cMin, Math.min(cMax, baseCCT));
  }

  // Calculate step up preview
  let upBri = Math.min(ABSOLUTE_MAX_BRI, currentBri + briStep);
  const atAbsoluteMaxBri = currentBri >= ABSOLUTE_MAX_BRI - 0.5;
  const atConfigMaxBri = currentBri >= bMax - 0.5;
  let upCCT;

  if (atAbsoluteMaxBri || (atConfigMaxBri && brightnessLocked)) {
    // Can't step up further
    upBri = currentBri;
    upCCT = currentCCT;
  } else {
    upCCT = getStepResultCCT('up', upBri);
  }

  // Calculate step down preview
  let downBri = Math.max(ABSOLUTE_MIN_BRI, currentBri - briStep);
  const atAbsoluteMinBri = currentBri <= ABSOLUTE_MIN_BRI + 0.5;
  const atConfigMinBri = currentBri <= bMin + 0.5;
  let downCCT;

  if (atAbsoluteMinBri || (atConfigMinBri && brightnessLocked)) {
    // Can't step down further
    downBri = currentBri;
    downCCT = currentCCT;
  } else {
    downCCT = getStepResultCCT('down', downBri);
  }

  return { upBri, upCCT, downBri, downCCT };
}

function dayOfYear(dateStr) {
  const d = new Date(dateStr + 'T12:00:00');
  const s = new Date(d.getFullYear(), 0, 0);
  return Math.floor((d - s) / 86400000);
}

function solarDeclination(doy) {
  return (23.44 * Math.PI / 180) * Math.sin(2 * Math.PI * (284 + doy) / 365);
}

function getSunTimes(lat, lon, dateStr) {
  const date = new Date(dateStr || new Date().toISOString());
  const n = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
  const J = n + ((lon < 0 ? 360 + lon : lon) / 360);
  const M = (357.5291 + 0.9856 * J) % 360;
  const C = 1.9148 * Math.sin(rad(M)) + 0.02 * Math.sin(rad(2 * M)) + 0.0003 * Math.sin(rad(3 * M));
  const L = (M + 102.9372 + C + 180) % 360;
  const D = Math.asin(Math.sin(rad(L)) * Math.sin(rad(23.44)));
  const cosH0 = (Math.cos(rad(90.833)) - Math.sin(rad(lat)) * Math.sin(D)) / (Math.cos(rad(lat)) * Math.cos(D));

  if (cosH0 < -1 || cosH0 > 1) {
    const sn = 12 - date.getTimezoneOffset() / 60 - (lon / 15);
    return { sunrise: sn - 6, sunset: sn + 6, solarNoon: sn, solarMid: (sn + 12) % 24 };
  }

  const H0 = Math.acos(cosH0);
  const dl = (2 * H0 * 180 / Math.PI) / 15;
  const tz = -date.getTimezoneOffset() / 60;
  const sn = 12 + tz - (lon / 15);
  return { sunrise: sn - dl / 2, sunset: sn + dl / 2, solarNoon: sn, solarMid: (sn + 12) % 24 };
}

function getSelectedDateISO() {
  const slider = document.getElementById('chart-date-slider');
  const dayOffset = slider ? parseInt(slider.value) : 0;
  const now = new Date();
  const target = new Date(now.getFullYear(), 0, 1 + dayOffset);
  return target.toISOString().split('T')[0];
}

// ============================================================
// Color Helpers
// ============================================================

function cctToRGB(k) {
  k = Math.max(500, Math.min(10000, k));
  const t = k / 100;
  let r, g, b;

  if (t <= 66) {
    r = 255;
    g = 99.47 * Math.log(t) - 161.12;
    b = t <= 19 ? 0 : 138.52 * Math.log(t - 10) - 305.04;
  } else {
    r = 329.7 * Math.pow(t - 60, -0.133);
    g = 288.12 * Math.pow(t - 60, -0.075);
    b = 255;
  }

  const s = (k - 5000) / 5000;
  const blueBoost = 1 + 0.8 * Math.max(0, s);
  const redDamp = 1 - 0.4 * Math.max(0, s);
  r = Math.max(0, Math.min(255, r * redDamp));
  g = Math.max(0, Math.min(255, g));
  b = Math.max(0, Math.min(255, b * blueBoost));
  return `rgb(${r | 0},${g | 0},${b | 0})`;
}

function colorWithAlpha(rgb, alpha) {
  const match = rgb.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
  if (match) {
    return `rgba(${match[1]},${match[2]},${match[3]},${alpha})`;
  }
  return rgb;
}

function readableTextColor(bgColor) {
  let r, g, b;

  // Try rgb/rgba format
  const rgbMatch = bgColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
  if (rgbMatch) {
    r = parseInt(rgbMatch[1]);
    g = parseInt(rgbMatch[2]);
    b = parseInt(rgbMatch[3]);
  } else {
    // Try hex format (#rgb or #rrggbb)
    const hexMatch = bgColor.match(/^#([0-9a-f]{3,6})$/i);
    if (hexMatch) {
      let hex = hexMatch[1];
      if (hex.length === 3) {
        hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
      }
      r = parseInt(hex.substr(0, 2), 16);
      g = parseInt(hex.substr(2, 2), 16);
      b = parseInt(hex.substr(4, 2), 16);
    } else {
      return '#fff';  // fallback
    }
  }

  const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  return luminance > 0.5 ? '#000' : '#fff';
}

// Generate color gradient for slider tracks
function updateColorGradients() {
  const minK = config.min_color_temp;
  const maxK = config.max_color_temp;
  const steps = 16;

  // Main color track
  const colorTrack = document.getElementById('color-track');
  if (colorTrack) {
    const stops = [];
    for (let i = 0; i <= steps; i++) {
      const k = 500 + (6000 * i / steps);
      stops.push(`${cctToRGB(k)} ${(i / steps) * 100}%`);
    }
    colorTrack.style.background = `linear-gradient(90deg, ${stops.join(',')})`;

    // Update masks
    const maskLeft = document.getElementById('color-mask-left');
    const maskRight = document.getElementById('color-mask-right');
    if (maskLeft && maskRight) {
      const leftPct = ((minK - 500) / 6000) * 100;
      const rightPct = ((maxK - 500) / 6000) * 100;
      maskLeft.style.left = '0%';
      maskLeft.style.width = `${leftPct}%`;
      maskRight.style.left = `${rightPct}%`;
      maskRight.style.width = `${100 - rightPct}%`;
    }
  }

  // Warm night track - gradient matches slider's dynamic bounds
  const warmTrack = document.getElementById('warm-night-track');
  const warmSlider = document.getElementById('warm-night-target');
  if (warmTrack && warmSlider) {
    const warmMin = parseInt(warmSlider.min) || minK;
    const warmMax = parseInt(warmSlider.max) || maxK;
    const stops = [];
    for (let i = 0; i <= steps; i++) {
      const k = warmMin + ((warmMax - warmMin) * i / steps);
      stops.push(`${cctToRGB(k)} ${(i / steps) * 100}%`);
    }
    warmTrack.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
  }

  // Cool day track - gradient matches slider's dynamic bounds
  const coolTrack = document.getElementById('cool-day-track');
  const coolSlider = document.getElementById('cool-day-target');
  if (coolTrack && coolSlider) {
    const coolMin = parseInt(coolSlider.min) || minK;
    const coolMax = parseInt(coolSlider.max) || maxK;
    const stops = [];
    for (let i = 0; i <= steps; i++) {
      const k = coolMin + ((coolMax - coolMin) * i / steps);
      stops.push(`${cctToRGB(k)} ${(i / steps) * 100}%`);
    }
    coolTrack.style.background = `linear-gradient(90deg, ${stops.join(',')})`;
  }

  // Update target chips
  updateColorChips();
}

function updateColorChips() {
  const warmChip = document.getElementById('warm-night-target-chip');
  if (warmChip) {
    const k = config.warm_night_target;
    warmChip.textContent = `${k} K`;
    warmChip.style.background = cctToRGB(k);
    warmChip.style.color = readableTextColor(cctToRGB(k));
  }

  const coolChip = document.getElementById('cool-day-target-chip');
  if (coolChip) {
    const k = config.cool_day_target;
    coolChip.textContent = `${k} K`;
    coolChip.style.background = cctToRGB(k);
    coolChip.style.color = readableTextColor(cctToRGB(k));
  }

  // Update temporary ceiling/floor chips (solar_rule_color_limit applies to active rule)
  const warmCeilingChip = document.getElementById('warm-night-ceiling-chip');
  const coolFloorChip = document.getElementById('cool-day-floor-chip');
  const limit = runtimeState.solar_rule_color_limit;

  // Check which rule is active at cursor position
  const warmWindow = getWarmNightWindow();
  const coolWindow = getCoolDayWindow();
  const inWarmWindow = warmWindow && warmWindow.inWindow;
  const inCoolWindow = coolWindow && coolWindow.inWindow;

  if (warmCeilingChip) {
    if (inWarmWindow && limit !== null && limit !== config.warm_night_target) {
      warmCeilingChip.textContent = `â†’ ${Math.round(limit)} K`;
      warmCeilingChip.style.background = cctToRGB(limit);
      warmCeilingChip.style.color = readableTextColor(cctToRGB(limit));
      warmCeilingChip.classList.remove('hidden');
    } else {
      warmCeilingChip.classList.add('hidden');
    }
  }

  if (coolFloorChip) {
    if (inCoolWindow && limit !== null && limit !== config.cool_day_target) {
      coolFloorChip.textContent = `â†’ ${Math.round(limit)} K`;
      coolFloorChip.style.background = cctToRGB(limit);
      coolFloorChip.style.color = readableTextColor(cctToRGB(limit));
      coolFloorChip.classList.remove('hidden');
    } else {
      coolFloorChip.classList.add('hidden');
    }
  }

  // Update temporary brightness/color bound chips
  updateTempBoundsChips();
}

function updateTempBoundsChips() {
  const tempBoundsRow = document.getElementById('temp-bounds-row');
  let anyVisible = false;

  // Brightness min chip
  const briMinChip = document.getElementById('temp-bri-min-chip');
  if (briMinChip) {
    const rtMin = runtimeState.min_brightness;
    if (rtMin !== null && rtMin !== config.min_brightness) {
      briMinChip.textContent = `Min: ${Math.round(rtMin)}%`;
      briMinChip.classList.remove('hidden');
      anyVisible = true;
    } else {
      briMinChip.classList.add('hidden');
    }
  }

  // Brightness max chip
  const briMaxChip = document.getElementById('temp-bri-max-chip');
  if (briMaxChip) {
    const rtMax = runtimeState.max_brightness;
    if (rtMax !== null && rtMax !== config.max_brightness) {
      briMaxChip.textContent = `Max: ${Math.round(rtMax)}%`;
      briMaxChip.classList.remove('hidden');
      anyVisible = true;
    } else {
      briMaxChip.classList.add('hidden');
    }
  }

  // Color min chip
  const colorMinChip = document.getElementById('temp-color-min-chip');
  if (colorMinChip) {
    const rtMin = runtimeState.min_color_temp;
    if (rtMin !== null && rtMin !== config.min_color_temp) {
      const k = Math.round(rtMin);
      colorMinChip.textContent = `Min: ${k} K`;
      colorMinChip.style.background = cctToRGB(k);
      colorMinChip.style.color = readableTextColor(cctToRGB(k));
      colorMinChip.classList.remove('hidden');
      anyVisible = true;
    } else {
      colorMinChip.classList.add('hidden');
    }
  }

  // Color max chip
  const colorMaxChip = document.getElementById('temp-color-max-chip');
  if (colorMaxChip) {
    const rtMax = runtimeState.max_color_temp;
    if (rtMax !== null && rtMax !== config.max_color_temp) {
      const k = Math.round(rtMax);
      colorMaxChip.textContent = `Max: ${k} K`;
      colorMaxChip.style.background = cctToRGB(k);
      colorMaxChip.style.color = readableTextColor(cctToRGB(k));
      colorMaxChip.classList.remove('hidden');
      anyVisible = true;
    } else {
      colorMaxChip.classList.add('hidden');
    }
  }

  // Show/hide the entire row
  if (tempBoundsRow) {
    if (anyVisible) {
      tempBoundsRow.classList.remove('hidden');
    } else {
      tempBoundsRow.classList.add('hidden');
    }
  }
}

// Apply solar color rules to CCT curve
function adjustCCTForSolarRules(cctArray, hoursArray, sunrise, sunset) {
  const fadeHrs = config.warm_night_fade / 60;
  const coolFadeHrs = config.cool_day_fade / 60;
  const solarMid = wrap24(sunTimes.solarMid);  // solar midnight
  const solarNoon = wrap24(sunTimes.solarNoon);

  // Warm night rule
  if (config.warm_night_enabled) {
    const startOffsetHrs = config.warm_night_start / 60;  // offset from sunset
    const endOffsetHrs = config.warm_night_end / 60;      // offset from sunrise
    const mode = config.warm_night_mode;
    // Use runtime limit if set (can only be higher than config target)
    const warmTarget = runtimeState.solar_rule_color_limit ?? config.warm_night_target;

    // Determine window based on mode
    let windowStart, windowEnd;
    if (mode === 'sunrise') {
      // Before sunrise only: solar midnight to sunrise+end
      windowStart = solarMid;
      windowEnd = wrap24(sunrise + endOffsetHrs);
    } else if (mode === 'sunset') {
      // After sunset only: sunset+start to solar midnight
      windowStart = wrap24(sunset + startOffsetHrs);
      windowEnd = solarMid;
    } else {
      // All night: sunset+start to sunrise+end
      windowStart = wrap24(sunset + startOffsetHrs);
      windowEnd = wrap24(sunrise + endOffsetHrs);
    }

    for (let i = 0; i < cctArray.length; i++) {
      const h = hoursArray[i];
      const current = cctArray[i];

      // Skip if already at or below target (using runtime ceiling)
      if (current <= warmTarget) continue;

      // Check if hour is in night window (handles wrap around midnight)
      let inWindow = false;
      let distFromStart = 0;
      let distToEnd = 0;

      if (windowStart > windowEnd) {
        // Wraps around midnight
        inWindow = h >= windowStart || h <= windowEnd;
        if (inWindow) {
          distFromStart = h >= windowStart ? (h - windowStart) : (h + 24 - windowStart);
          distToEnd = h <= windowEnd ? (windowEnd - h) : (windowEnd + 24 - h);
        }
      } else {
        // Normal range
        inWindow = h >= windowStart && h <= windowEnd;
        if (inWindow) {
          distFromStart = h - windowStart;
          distToEnd = windowEnd - h;
        }
      }

      if (!inWindow) continue;

      // Apply fade at BOTH ends
      let weight = 1;
      if (fadeHrs > 0.01) {
        if (distFromStart < fadeHrs) {
          weight = Math.min(weight, distFromStart / fadeHrs);
        }
        if (distToEnd < fadeHrs) {
          weight = Math.min(weight, distToEnd / fadeHrs);
        }
      }

      if (weight <= 0) continue;
      cctArray[i] = current + (warmTarget - current) * weight;
    }
  }

  // Cool day rule
  if (config.cool_day_enabled) {
    const startOffsetHrs = config.cool_day_start / 60;  // offset from sunrise
    const endOffsetHrs = config.cool_day_end / 60;      // offset from sunset
    const mode = config.cool_day_mode;
    // Use runtime limit if set (can only be lower than config target)
    const coolTarget = runtimeState.solar_rule_color_limit ?? config.cool_day_target;

    // Determine window based on mode
    let windowStart, windowEnd;
    if (mode === 'sunrise') {
      // After sunrise only: sunrise+start to solar noon
      windowStart = wrap24(sunrise + startOffsetHrs);
      windowEnd = solarNoon;
    } else if (mode === 'sunset') {
      // Before sunset only: solar noon to sunset+end
      windowStart = solarNoon;
      windowEnd = wrap24(sunset + endOffsetHrs);
    } else {
      // All day: sunrise+start to sunset+end
      windowStart = wrap24(sunrise + startOffsetHrs);
      windowEnd = wrap24(sunset + endOffsetHrs);
    }

    for (let i = 0; i < cctArray.length; i++) {
      const h = hoursArray[i];
      const current = cctArray[i];

      // Skip if already at or above target (using runtime floor)
      if (current >= coolTarget) continue;

      // Check if hour is in day window
      let inWindow = false;
      let distFromStart = 0;
      let distToEnd = 0;

      if (windowStart > windowEnd) {
        // Unusual case - day wraps around midnight
        inWindow = h >= windowStart || h <= windowEnd;
        if (inWindow) {
          distFromStart = h >= windowStart ? (h - windowStart) : (h + 24 - windowStart);
          distToEnd = h <= windowEnd ? (windowEnd - h) : (windowEnd + 24 - h);
        }
      } else {
        // Normal daytime range
        inWindow = h >= windowStart && h <= windowEnd;
        if (inWindow) {
          distFromStart = h - windowStart;
          distToEnd = windowEnd - h;
        }
      }

      if (!inWindow) continue;

      // Apply fade at BOTH ends
      let weight = 1;
      if (coolFadeHrs > 0.01) {
        if (distFromStart < coolFadeHrs) {
          weight = Math.min(weight, distFromStart / coolFadeHrs);
        }
        if (distToEnd < coolFadeHrs) {
          weight = Math.min(weight, distToEnd / coolFadeHrs);
        }
      }

      if (weight <= 0) continue;
      cctArray[i] = current + (coolTarget - current) * weight;
    }
  }
}

// ============================================================
// Utility Functions
// ============================================================

function formatHour(h) {
  const h24 = ((h % 24) + 24) % 24;
  const hr = Math.floor(h24);
  const min = Math.round((h24 - hr) * 60);
  const suffix = hr < 12 ? 'a' : 'p';
  const hr12 = hr === 0 ? 12 : (hr > 12 ? hr - 12 : hr);
  return min === 0 ? `${hr12}:00${suffix}` : `${hr12}:${min.toString().padStart(2, '0')}${suffix}`;
}

function fmtTime(h) {
  return formatHour(h);
}

function logistic(x, midpoint, slope, y0, y1) {
  try {
    const expVal = Math.exp(-slope * (x - midpoint));
    return y0 + (y1 - y0) / (1 + expVal);
  } catch {
    return slope * (x - midpoint) > 0 ? y1 : y0;
  }
}

// ============================================================
// Curve Calculation
// ============================================================

// ============================================================
// Core Calculation Functions (single source of truth)
// These mirror brain.py's CircadianLight.calculate_* methods
// ============================================================

/**
 * Calculate brightness at a specific hour (0-1 scale).
 * This is the single source of truth for brightness calculations.
 */
function calculateBrightnessAtHour(hour) {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  // Determine current phase from cursor for runtimeState application
  const cursorH48 = cursorHour !== null ? (cursorHour < tAscend ? cursorHour + 24 : cursorHour) : tAscend;
  const cursorInAscend = cursorH48 >= tAscend && cursorH48 < tDescend;

  // runtimeState midpoints apply to current phase only
  const wakeMid = cursorInAscend ? (runtimeState.brightness_mid ?? config.wake_time) : config.wake_time;
  const bedMid = !cursorInAscend ? (runtimeState.brightness_mid ?? config.bed_time) : config.bed_time;

  // Clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];

  // Use runtime bounds if set, otherwise config
  const bMin = (runtimeState.min_brightness ?? config.min_brightness) / 100;
  const bMax = (runtimeState.max_brightness ?? config.max_brightness) / 100;

  // Phase detection for this hour
  const h48 = hour < tAscend ? hour + 24 : hour;
  const inAscend = h48 >= tAscend && h48 < tDescend;

  // Lift midpoint to 48h space
  let mid48;
  if (inAscend) {
    mid48 = wakeMid;
    let safety = 0;
    while (mid48 < tAscend && safety++ < 10) mid48 += 24;
    safety = 0;
    while (mid48 > tDescend && safety++ < 10) mid48 -= 24;
  } else {
    mid48 = bedMid;
    let safety = 0;
    while (mid48 < tDescend && safety++ < 10) mid48 += 24;
    safety = 0;
    while (mid48 > tDescend + 24 && safety++ < 10) mid48 -= 24;
  }

  // Calculate brightness from logistic curve
  let value;
  if (inAscend) {
    value = logistic(h48, mid48, kAscend, bMin, bMax);
  } else {
    const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
    value = logistic(hDescend48, mid48, -kDescend, bMin, bMax);
  }

  // Clamp to bounds (matches brain.py)
  return Math.max(bMin, Math.min(bMax, value));
}

/**
 * Calculate color temperature at a specific hour (Kelvin).
 * This is the single source of truth for CCT calculations.
 * @param {number} hour - Hour (0-24)
 * @param {boolean} applySolar - Whether to apply solar rules (default true)
 */
function calculateColorAtHour(hour, applySolar = true) {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  // Determine current phase from cursor for runtimeState application
  const cursorH48 = cursorHour !== null ? (cursorHour < tAscend ? cursorHour + 24 : cursorHour) : tAscend;
  const cursorInAscend = cursorH48 >= tAscend && cursorH48 < tDescend;

  // runtimeState midpoints apply to current phase only
  const colorWakeMid = cursorInAscend ? (runtimeState.color_mid ?? config.wake_time) : config.wake_time;
  const colorBedMid = !cursorInAscend ? (runtimeState.color_mid ?? config.bed_time) : config.bed_time;

  // Clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];

  // Use runtime bounds if set, otherwise config
  const cLow = runtimeState.min_color_temp ?? config.min_color_temp;
  const cHigh = runtimeState.max_color_temp ?? config.max_color_temp;

  // Phase detection for this hour
  const h48 = hour < tAscend ? hour + 24 : hour;
  const inAscend = h48 >= tAscend && h48 < tDescend;

  // Lift midpoint to 48h space
  let mid48;
  if (inAscend) {
    mid48 = colorWakeMid;
    let safety = 0;
    while (mid48 < tAscend && safety++ < 10) mid48 += 24;
    safety = 0;
    while (mid48 > tDescend && safety++ < 10) mid48 -= 24;
  } else {
    mid48 = colorBedMid;
    let safety = 0;
    while (mid48 < tDescend && safety++ < 10) mid48 += 24;
    safety = 0;
    while (mid48 > tDescend + 24 && safety++ < 10) mid48 -= 24;
  }

  // Calculate normalized color value (0-1)
  let normalized;
  if (inAscend) {
    normalized = logistic(h48, mid48, kAscend, 0, 1);
  } else {
    const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
    normalized = logistic(hDescend48, mid48, -kDescend, 0, 1);
  }
  normalized = Math.max(0, Math.min(1, normalized));

  // Convert to Kelvin
  let cct = cLow + (cHigh - cLow) * normalized;

  // Apply solar rules if requested
  if (applySolar) {
    cct = applySolarRuleAtHour(cct, hour);
  }

  return cct;
}

/**
 * Get phase (Ascend/Descend) at a specific hour.
 */
function getPhaseAtHour(hour) {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  const h48 = hour < tAscend ? hour + 24 : hour;
  return h48 < tDescend ? 'Ascend' : 'Descend';
}

/**
 * Generate curve data for chart rendering.
 * Uses the core calculation functions to ensure consistency.
 */
function calculateCurveData() {
  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;

  const hours = Array.from({ length: 480 }, (_, i) => (i * 3) / 60);

  // Use core calculation functions for each data point
  const brightness = hours.map(h => calculateBrightnessAtHour(h));
  const cct = hours.map(h => calculateColorAtHour(h, false));  // Solar rules applied separately in renderChart
  const phase = hours.map(h => getPhaseAtHour(h));

  return { hours, brightness, cct, phase, tAscend, tDescend };
}

// Get brightness at specific x value
function getBrightnessAt(xVal, brightnessPct, samplesPerHour) {
  const idx = Math.min(brightnessPct.length - 1, Math.max(0, Math.round(xVal * samplesPerHour)));
  return brightnessPct[idx];
}

// Generate phase segments for shading
function spanSegments(start, end) {
  let delta = ((end - start) % 24 + 24) % 24;
  if (delta === 0) delta = 24;
  const startWrap = wrap24(start);
  const endWrap = (startWrap + delta) % 24;
  if (delta === 24) return [{ start: 0, end: 24 }];
  if (startWrap < endWrap) return [{ start: startWrap, end: endWrap }];
  return [
    { start: startWrap, end: 24 },
    { start: 0, end: endWrap }
  ];
}

// ============================================================
// Chart Rendering
// ============================================================

function renderChart() {
  const dateStr = getSelectedDateISO();
  const { sunrise, sunset, solarNoon, solarMid } = getSunTimes(config.latitude, config.longitude, dateStr);

  // Cache sun times for color rules
  sunTimes = { sunrise, sunset, solarNoon, solarMid };

  const data = calculateCurveData();

  // Apply solar color rules to CCT
  adjustCCTForSolarRules(data.cct, data.hours, sunrise, sunset);

  const { hours, brightness, cct, phase, tAscend, tDescend } = data;
  const brightnessPct = brightness.map(v => v * 100);

  // Store graph data for cursor functions (include brightnessPct for 0-100 scale)
  graphData = { ...data, brightnessPct };
  const samplesPerHour = hours.length / 24;

  // Build traces
  const traces = [];

  // Color-gradient brightness curve (filled + line segments)
  const step = 2;
  for (let i = step; i < hours.length; i += step) {
    const color = cctToRGB(cct[i]);
    const fillColor = colorWithAlpha(color, 0.5);
    const x0 = hours[i - step];
    const x1 = hours[i];
    const y0 = brightnessPct[i - step];
    const y1 = brightnessPct[i];

    // Filled area under curve
    traces.push({
      type: 'scatter',
      mode: 'lines',
      x: [x0, x1, x1, x0],
      y: [y0, y1, 0, 0],
      fill: 'toself',
      line: { width: 0 },
      fillcolor: fillColor,
      hoverinfo: 'skip',
      showlegend: false
    });

    // Colored line segment
    traces.push({
      type: 'scatter',
      mode: 'lines',
      x: [x0, x1],
      y: [y0, y1],
      line: { width: 3, color },
      hoverinfo: 'skip',
      showlegend: false
    });
  }

  // Sun curve - LINE ONLY, no fill
  const lat = config.latitude;
  const latRad = lat * Math.PI / 180;
  const doyToday = dayOfYear(dateStr);
  const doyWinter = dayOfYear(`${new Date(dateStr).getFullYear()}-12-21`);
  const deltaToday = solarDeclination(doyToday);
  const deltaWinter = solarDeclination(doyWinter);

  const H = hours.map(hh => (hh - solarNoon) * (Math.PI / 12));

  function zenith(phi, delta, Hr) {
    const c = Math.sin(phi) * Math.sin(delta) + Math.cos(phi) * Math.cos(delta) * Math.cos(Hr);
    return Math.acos(Math.max(-1, Math.min(1, c)));
  }

  function ghiHaurwitz(z) {
    if (z >= Math.PI / 2) return 0;
    const mu = Math.cos(z);
    return 1098 * mu * Math.exp(-0.057 / mu);
  }

  const ghiToday = H.map(Hr => ghiHaurwitz(zenith(latRad, deltaToday, Hr)));
  const ghiWinter = H.map(Hr => ghiHaurwitz(zenith(latRad, deltaWinter, Hr)));
  const alpha = 1.5 / Math.max(...ghiWinter, 0.001);
  const sunScaledPct = ghiToday.map(v => v * alpha * 100);

  // Sun curve - just line, no fill
  traces.push({
    type: 'scatter',
    mode: 'lines',
    x: hours,
    y: sunScaledPct,
    line: { width: 1, color: 'rgba(255,255,255,0.25)' },
    name: 'Sun',
    hoverinfo: 'skip',
    showlegend: true
  });

  // Hover trace - CCT colored background, shows phase, no time
  const hoverDetails = brightnessPct.map((v, i) => {
    const pct = Math.round(v);
    const kelvin = Math.round(cct[i]);
    const phaseWord = phase[i] === 'Ascend' ? 'ascending' : 'descending';
    return `${pct}% â€¢ ${kelvin}K â€¢ ${phaseWord}`;
  });

  const hoverBgColors = cct.map(k => colorWithAlpha(cctToRGB(k), 0.92));
  const hoverTextColors = cct.map(k => readableTextColor(cctToRGB(k)));
  const hoverBorderColors = cct.map(k => colorWithAlpha(cctToRGB(k), 0.65));

  traces.push({
    type: 'scatter',
    mode: 'lines',
    x: hours,
    y: brightnessPct,
    line: { width: 0 },
    showlegend: false,
    text: hoverDetails,
    hovertemplate: '%{text}<extra></extra>',
    hoverlabel: {
      bgcolor: hoverBgColors,
      bordercolor: hoverBorderColors,
      font: { color: hoverTextColors, size: 13 }
    }
  });

  // Legend placeholder for Circadian Light
  traces.push({
    type: 'scatter',
    mode: 'lines',
    x: [null],
    y: [null],
    line: { width: 3, color: '#fff' },
    name: 'Circadian Light',
    hoverinfo: 'skip',
    showlegend: true
  });

  // Cursor point marker trace (CCT-colored ball at cursor position)
  traces.push({
    x: [null],
    y: [null],
    mode: 'markers',
    marker: { size: 14, color: '#fff', line: { width: 2, color: '#fff' } },
    hoverinfo: 'skip',
    showlegend: false,
    name: 'cursor-point'
  });
  window.cursorTraceIndex = traces.length - 1;

  // Shapes and annotations
  const shapes = [];
  const annotations = [];

  // Phase shading ABOVE the curve
  const ascendSegments = spanSegments(tAscend, tDescend);
  const descendSegments = spanSegments(tDescend, tAscend + 24);

  const addCurveBand = (segments, color) => {
    const yTop = GRAPH_Y_MAX;
    const stepSize = 0.05;
    segments.forEach(seg => {
      const points = [];
      for (let x = seg.start; x <= seg.end + 1e-6; x += stepSize) {
        const clamped = Math.min(seg.end, x);
        points.push({ x: clamped, y: getBrightnessAt(clamped, brightnessPct, samplesPerHour) });
      }
      if (!points.length) return;
      const startX = points[0].x;
      const endX = points[points.length - 1].x;
      let path = `M ${startX} ${yTop} L ${endX} ${yTop}`;
      for (let i = points.length - 1; i >= 0; i--) {
        path += ` L ${points[i].x} ${points[i].y}`;
      }
      path += ' Z';
      shapes.push({
        type: 'path',
        xref: 'x',
        yref: 'y',
        path,
        fillcolor: color,
        line: { width: 0 },
        layer: 'below'
      });
    });
  };

  addCurveBand(ascendSegments, ASCEND_COLORS.shade);
  addCurveBand(descendSegments, DESCEND_COLORS.shade);

  // Phase boundary lines
  const ascendStart = wrap24(config.ascend_start);
  const descendStart = wrap24(config.descend_start);

  shapes.push({
    type: 'line', xref: 'x', yref: 'paper',
    x0: ascendStart, x1: ascendStart, y0: 0, y1: 1,
    line: { color: ASCEND_COLORS.axis, width: 1.5 }
  });
  shapes.push({
    type: 'line', xref: 'x', yref: 'paper',
    x0: descendStart, x1: descendStart, y0: 0, y1: 1,
    line: { color: DESCEND_COLORS.axis, width: 1.5 }
  });

  // Phase name labels above the curve (at y=115)
  const phaseNameY = 115;
  const addPhaseNameLabels = (segments, label, palette) => {
    segments.forEach(seg => {
      const span = seg.end - seg.start;
      if (span < 1) return;  // Skip segments shorter than 1 hour
      const mid = seg.start + span / 2;
      annotations.push({
        x: mid,
        y: phaseNameY,
        xref: 'x',
        yref: 'y',
        text: label,
        showarrow: false,
        font: { size: 13, color: palette.text },
        opacity: 0.85,
        hoverlabel: {
          bgcolor: palette.hoverBg,
          bordercolor: palette.hoverBg,
          font: { color: readableTextColor(palette.hoverBg) }
        }
      });
    });
  };
  addPhaseNameLabels(ascendSegments, 'Ascend', ASCEND_COLORS);
  addPhaseNameLabels(descendSegments, 'Descend', DESCEND_COLORS);

  // X-axis labels (from top to bottom):
  // 1. Time labels (handled by xaxis ticktext at y=0)
  // 2. Phase labels (ascend starts, wake, descend starts, bed) at y = -0.14
  // 3. Solar labels (sunrise, sunset, etc.) at y = -0.20, muted grey

  // Phase labels with vertical lines
  const phaseLabels = [
    { label: 'ascend starts', x: ascendStart, color: ASCEND_COLORS.text, lineColor: ASCEND_COLORS.axis, solid: true, extendUp: true },
    { label: 'wake', x: wrap24(config.wake_time), color: ASCEND_COLORS.text, lineColor: ASCEND_COLORS.axis, solid: false, extendUp: true },
    { label: 'descend starts', x: descendStart, color: DESCEND_COLORS.text, lineColor: DESCEND_COLORS.axis, solid: true, extendUp: true },
    { label: 'bed', x: wrap24(config.bed_time), color: DESCEND_COLORS.text, lineColor: DESCEND_COLORS.axis, solid: false, extendUp: true }
  ];

  phaseLabels.forEach(marker => {
    // Vertical line from label up through the graph
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: marker.x, x1: marker.x,
      y0: -0.08,
      y1: marker.extendUp ? 1 : 0,
      line: { color: marker.lineColor, width: marker.solid ? 1.6 : 1, dash: marker.solid ? 'solid' : 'dot' }
    });
    const hoverBg = marker.color === ASCEND_COLORS.text ? ASCEND_COLORS.hoverBg : DESCEND_COLORS.hoverBg;
    annotations.push({
      x: marker.x, y: -0.14, xref: 'x', yref: 'paper',
      text: marker.label,
      showarrow: false,
      font: { size: 11, color: marker.color },
      hovertext: fmtTime(marker.x),
      hoverlabel: {
        bgcolor: hoverBg,
        bordercolor: hoverBg,
        font: { color: readableTextColor(hoverBg), size: 12 }
      }
    });
  });

  // Solar labels - all same muted grey color, lower position
  const solarLabelColor = 'rgba(215,215,215,0.8)';
  const solarLineColor = 'rgba(200,200,200,0.35)';
  const solarLabels = [
    { label: 'sunrise', x: wrap24(sunrise), extendUp: true },
    { label: 'sunset', x: wrap24(sunset), extendUp: true },
    { label: 'solar noon', x: wrap24(solarNoon), extendUp: false },
    { label: 'solar midnight', x: wrap24(solarMid), extendUp: false }
  ];

  const solarHoverBg = '#3a3a3a';
  solarLabels.forEach(marker => {
    if (!Number.isFinite(marker.x)) return;
    // Line from label up (sunrise/sunset go all the way up)
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: marker.x, x1: marker.x,
      y0: -0.135,
      y1: marker.extendUp ? 1 : 0,
      line: { color: solarLineColor, width: 1, dash: 'dot' }
    });
    annotations.push({
      x: marker.x, y: -0.20, xref: 'x', yref: 'paper',
      text: marker.label,
      showarrow: false,
      font: { size: 10, color: solarLabelColor },
      hovertext: fmtTime(marker.x),
      hoverlabel: {
        bgcolor: solarHoverBg,
        bordercolor: solarHoverBg,
        font: { color: '#fff', size: 12 }
      }
    });
  });

  // Store base shapes/annotations for cursor updates
  window.baseShapes = shapes.slice();
  window.baseAnnotations = annotations.slice();

  const layout = {
    paper_bgcolor: '#0a0a0a',
    plot_bgcolor: '#0a0a0a',
    margin: { t: 40, r: 40, l: 50, b: 100 },
    legend: { orientation: 'h', x: 0, y: 1.1, font: { color: '#c8c8c8' } },
    hovermode: 'closest',
    xaxis: {
      range: [0, 24],
      dtick: 2,
      tickvals: [0, 2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22, 24],
      ticktext: ['12a', '2a', '4a', '6a', '8a', '10a', '12p', '2p', '4p', '6p', '8p', '10p', '12a'],
      gridcolor: 'rgba(80,100,130,0.22)',
      tickfont: { color: '#c8c8c8' },
      ticklen: 4,
      tickcolor: 'rgba(160,190,220,0.2)'
    },
    yaxis: {
      range: [0, GRAPH_Y_MAX],
      gridcolor: 'rgba(80,100,130,0.22)',
      tickfont: { color: '#c8c8c8' },
      ticklen: 4,
      title: 'Brightness (%)',
      titlefont: { color: '#c8c8c8' }
    },
    shapes,
    annotations
  };

  Plotly.react('chart', traces, layout, { displayModeBar: false }).then(() => {
    initChartInteractivity();
    applyCursor();
  });

  // Update date display
  const dateDisplay = document.getElementById('chart-date-display');
  if (dateDisplay) {
    const d = new Date(dateStr + 'T12:00:00');
    dateDisplay.textContent = d.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  }

  // Update color chips (including temp ceiling/floor)
  updateColorChips();
}

// ============================================================
// Chart Interactivity
// ============================================================

function initChartInteractivity() {
  const chart = document.getElementById('chart');
  if (!chart || chart._interactivityInitialized) return;

  const chartWrapper = document.querySelector('.chart-wrapper');
  const hoverLabel = document.getElementById('time-hover-label');

  // Helper to get plot area (Plotly creates this after rendering)
  const getPlotArea = () => {
    // Try multiple selectors for Plotly's plot area
    return chart.querySelector('.cartesianlayer .plot') ||
           chart.querySelector('.plot-container .plot') ||
           chart.querySelector('.nsewdrag');
  };

  // Mouse move for time hover label at top
  chart.addEventListener('mousemove', (ev) => {
    const plotArea = getPlotArea();
    if (!plotArea) return;

    const rect = plotArea.getBoundingClientRect();
    const inside = ev.clientX >= rect.left && ev.clientX <= rect.right &&
                   ev.clientY >= rect.top && ev.clientY <= rect.bottom;

    if (!inside) {
      hoverLabel.style.opacity = '0';
      return;
    }

    const layout = chart._fullLayout;
    const xRange = layout?.xaxis?.range || [0, 24];
    const ratio = (ev.clientX - rect.left) / rect.width;
    const xVal = xRange[0] + ratio * (xRange[1] - xRange[0]);
    const wrapperRect = chartWrapper.getBoundingClientRect();

    hoverLabel.textContent = fmtTime(xVal);
    hoverLabel.style.left = `${ev.clientX - wrapperRect.left}px`;

    // Color based on phase
    const tAscend = config.ascend_start;
    let tDescend = config.descend_start;
    if (tDescend <= tAscend) tDescend += 24;
    let h = xVal;
    if (h < tAscend) h += 24;
    const inAscend = h < tDescend;
    const chipColor = inAscend ? ASCEND_COLORS.hoverBg : DESCEND_COLORS.hoverBg;

    hoverLabel.style.background = chipColor;
    hoverLabel.style.color = readableTextColor(chipColor);
    hoverLabel.style.opacity = '1';
  }, true);  // Use capture phase

  chart.addEventListener('mouseleave', () => {
    hoverLabel.style.opacity = '0';
  }, true);

  // Click for cursor placement - use capture to get events before Plotly
  chart.addEventListener('click', (ev) => {
    const plotArea = getPlotArea();
    if (!plotArea) {
      console.log('No plot area found');
      return;
    }

    const rect = plotArea.getBoundingClientRect();
    if (ev.clientX < rect.left || ev.clientX > rect.right ||
        ev.clientY < rect.top || ev.clientY > rect.bottom) {
      return;
    }

    const layout = chart._fullLayout;
    const xRange = layout?.xaxis?.range || [0, 24];
    const ratio = (ev.clientX - rect.left) / rect.width;
    const xVal = xRange[0] + ratio * (xRange[1] - xRange[0]);

    cursorHour = xVal;
    applyCursor();
  }, true);  // Use capture phase

  // Double click to clear cursor
  chart.addEventListener('dblclick', () => {
    cursorHour = null;
    applyCursor();
  }, true);

  chart._interactivityInitialized = true;
}

function applyCursor() {
  const chart = document.getElementById('chart');
  const cursorControls = document.getElementById('cursor-controls');
  const cursorCallout = document.getElementById('cursor-callout');
  const traceIdx = typeof window.cursorTraceIndex === 'number' ? window.cursorTraceIndex : null;

  if (!chart || !window.baseShapes) return;

  const shapes = window.baseShapes.slice();
  const annotations = window.baseAnnotations ? window.baseAnnotations.slice() : [];

  if (cursorHour === null) {
    Plotly.relayout(chart, { shapes, annotations });
    if (traceIdx != null) {
      Plotly.restyle(chart, { x: [[null]], y: [[null]] }, traceIdx);
    }
    cursorControls.classList.add('hidden');
    cursorCallout.style.opacity = '0';
    updateCursorButtons(null);
    return;
  }

  // Get cursor point data using core calculation functions (exact values, no interpolation)
  let cursorPoint = null;
  if (config) {
    cursorPoint = {
      x: cursorHour,
      y: calculateBrightnessAtHour(cursorHour) * 100,  // Convert 0-1 to 0-100
      cct: calculateColorAtHour(cursorHour, true),     // With solar rules
      phase: getPhaseAtHour(cursorHour)
    };

    // Reset runtime state on phase transition (ascend â†” descend)
    if (lastCursorPhase !== null && cursorPoint.phase !== lastCursorPhase) {
      resetRuntimeState();
      // Re-render chart with reset state
      renderChart();
    }
    lastCursorPhase = cursorPoint.phase;
  }

  // Cursor line style - dotted white
  const cursorLineStyle = { color: '#fdfdfd', width: 2, dash: 'dot' };
  const cursorLabelY = -0.26;

  // Add cursor line with gap around the point
  if (cursorPoint) {
    const gap = 3;
    const lowerEnd = Math.max(0, cursorPoint.y - gap);
    const upperStart = Math.min(GRAPH_Y_MAX, cursorPoint.y + gap);

    // Lower segment
    shapes.push({
      type: 'line', xref: 'x', yref: 'y',
      x0: cursorHour, x1: cursorHour, y0: 0, y1: lowerEnd,
      line: cursorLineStyle, layer: 'above'
    });
    // Upper segment
    shapes.push({
      type: 'line', xref: 'x', yref: 'y',
      x0: cursorHour, x1: cursorHour, y0: upperStart, y1: GRAPH_Y_MAX,
      line: cursorLineStyle, layer: 'above'
    });
  } else {
    // Full line if no point
    shapes.push({
      type: 'line', xref: 'x', yref: 'paper',
      x0: cursorHour, x1: cursorHour, y0: 0, y1: 1,
      line: cursorLineStyle, layer: 'above'
    });
  }

  // Cursor line below x-axis to label
  shapes.push({
    type: 'line', xref: 'x', yref: 'paper',
    x0: cursorHour, x1: cursorHour, y0: cursorLabelY + 0.05, y1: 0,
    line: cursorLineStyle, layer: 'above'
  });

  // Cursor label below axis
  annotations.push({
    x: cursorHour, y: cursorLabelY, xref: 'x', yref: 'paper',
    text: 'cursor',
    showarrow: false,
    font: { size: 11, color: '#fdfdfd' },
    opacity: 1
  });

  Plotly.relayout(chart, { shapes, annotations });

  // Update cursor callout and marker
  if (cursorPoint) {
    const bri = Math.round(cursorPoint.y);
    const cctVal = Math.round(cursorPoint.cct);
    const phaseWord = cursorPoint.phase === 'Ascend' ? 'ascending' : 'descending';
    const color = cctToRGB(cctVal);

    const plotArea = chart.querySelector('.cartesianlayer .plot') || chart.querySelector('.nsewdrag');
    const chartWrapper = document.querySelector('.chart-wrapper');
    if (plotArea && chartWrapper) {
      const rect = plotArea.getBoundingClientRect();
      const chartRect = chart.getBoundingClientRect();
      const wrapperRect = chartWrapper.getBoundingClientRect();
      const layout = chart._fullLayout;
      const xRange = layout?.xaxis?.range || [0, 24];
      const ratio = (cursorHour - xRange[0]) / (xRange[1] - xRange[0] || 1);
      const leftPx = rect.left + ratio * rect.width - wrapperRect.left;

      cursorCallout.textContent = `${fmtTime(cursorHour)} â€¢ ${bri}% â€¢ ${cctVal}K â€¢ ${phaseWord}`;
      cursorCallout.style.left = `${leftPx}px`;
      cursorCallout.style.opacity = '1';

      // Color callout based on CCT
      cursorCallout.style.background = color;
      cursorCallout.style.color = readableTextColor(color);
      cursorCallout.style.borderColor = 'rgba(255,255,255,0.5)';
    }

    // Update cursor ball marker (CCT-colored with white border)
    if (traceIdx != null) {
      const markerUpdate = {
        x: [[cursorPoint.x]],
        y: [[cursorPoint.y]],
        marker: [{
          size: 14,
          color,
          opacity: 1,
          symbol: 'circle',
          line: { width: 2, color: '#fff' }
        }]
      };
      Plotly.restyle(chart, markerUpdate, traceIdx);
    }

    // Update cursor button styles with NEXT values
    updateCursorButtons(cursorPoint);

    // Live Design: update lights when cursor values change
    applyLiveLight();
  }

  cursorControls.classList.remove('hidden');
}

// Style cursor buttons based on NEXT values (what button WILL DO)
function updateCursorButtons(point) {
  const stepUp = document.getElementById('cursor-step-up');
  const stepDown = document.getElementById('cursor-step-down');
  const brightUp = document.getElementById('cursor-bright-up');
  const brightDown = document.getElementById('cursor-bright-down');
  const colorUp = document.getElementById('cursor-color-up');
  const colorDown = document.getElementById('cursor-color-down');
  const brightMidInfo = document.getElementById('brightness-midpoint-info');
  const colorMidInfo = document.getElementById('color-midpoint-info');

  const clearBtn = (btn) => {
    if (!btn) return;
    btn.style.removeProperty('--btn-bg');
    btn.style.removeProperty('--btn-text');
    btn.style.removeProperty('--btn-fill');
    btn.style.removeProperty('--btn-fill-opacity');
    btn.classList.remove('at-extreme');
  };

  if (!point) {
    [stepUp, stepDown, brightUp, brightDown, colorUp, colorDown].forEach(clearBtn);
    if (brightMidInfo) brightMidInfo.textContent = '';
    if (colorMidInfo) colorMidInfo.textContent = '';
    return;
  }

  // Determine phase (ascend = wake, descend = bed)
  const inAscend = point.phase === 'Ascend';

  // Get current runtime midpoints (always show, even if equal to base)
  const currentBriMid = runtimeState.brightness_mid ?? (inAscend ? config.wake_time : config.bed_time);
  const currentColorMid = runtimeState.color_mid ?? (inAscend ? config.wake_time : config.bed_time);

  // Show just the time next to the label
  if (brightMidInfo) {
    brightMidInfo.textContent = fmtTime(currentBriMid);
  }
  if (colorMidInfo) {
    colorMidInfo.textContent = fmtTime(currentColorMid);
  }

  // Calculate step increments (based on config range, with separate increments)
  const briSteps = config.brightness_increments ?? config.max_dim_steps ?? 10;
  const colorSteps = config.color_increments ?? config.max_dim_steps ?? 10;

  const configMinPct = config.min_brightness;
  const configMaxPct = config.max_brightness;
  const rangePct = Math.max(0, configMaxPct - configMinPct);
  const deltaPct = briSteps > 0 ? rangePct / briSteps : 0;

  const configMinCCT = Math.min(config.min_color_temp, config.max_color_temp);
  const configMaxCCT = Math.max(config.min_color_temp, config.max_color_temp);
  const rangeCCT = Math.max(0, configMaxCCT - configMinCCT);
  const deltaCCT = colorSteps > 0 ? rangeCCT / colorSteps : 0;

  // Current bounds (runtime or config)
  const effectiveMinPct = runtimeState.min_brightness ?? configMinPct;
  const effectiveMaxPct = runtimeState.max_brightness ?? configMaxPct;
  const effectiveMinCCT = runtimeState.min_color_temp ?? configMinCCT;
  const effectiveMaxCCT = runtimeState.max_color_temp ?? configMaxCCT;

  // Absolute limits
  const ABSOLUTE_MIN_BRI = 1;
  const ABSOLUTE_MAX_BRI = 100;
  const ABSOLUTE_MIN_CCT = 500;
  const ABSOLUTE_MAX_CCT = 6500;

  const currentPct = point.y;
  const currentCCT = point.cct;

  // Calculate NEXT values (what the button will produce)
  // Use absolute limits since bounds can be pushed
  const nextBriUp = Math.min(ABSOLUTE_MAX_BRI, currentPct + deltaPct);
  const nextBriDown = Math.max(ABSOLUTE_MIN_BRI, currentPct - deltaPct);

  // Color buttons can push through solar rules - no clamping
  const nextColorUp = Math.min(ABSOLUTE_MAX_CCT, currentCCT + deltaCCT);
  const nextColorDown = Math.max(ABSOLUTE_MIN_CCT, currentCCT - deltaCCT);

  // Step buttons follow the curve - calculate what stepping would produce
  // This simulates the stepCursor logic: find virtual time, get base CCT, apply solar rules
  const stepPreview = getStepPreview(point);

  // Helper to style a button
  const styleBtn = (btn, targetBri, targetColor, mode) => {
    if (!btn) return;

    // Brightness fill (for brightness and combo modes)
    if ((mode === 'brightness' || mode === 'combo') && Number.isFinite(targetBri)) {
      const frac = Math.max(0, Math.min(1, targetBri / 100));
      btn.style.setProperty('--btn-fill', frac.toFixed(3));
      btn.style.setProperty('--btn-fill-opacity', frac > 0 ? '0.55' : '0');
    } else {
      btn.style.removeProperty('--btn-fill');
      btn.style.removeProperty('--btn-fill-opacity');
    }

    // Color background (for color and combo modes)
    if ((mode === 'color' || mode === 'combo') && Number.isFinite(targetColor)) {
      let color = cctToRGB(targetColor);
      if (mode === 'combo' && Number.isFinite(targetBri)) {
        color = tintColorByBrightness(color, targetBri);
      }
      btn.style.setProperty('--btn-bg', color);
      btn.style.setProperty('--btn-text', readableTextColor(color));
    } else {
      btn.style.removeProperty('--btn-bg');
      btn.style.removeProperty('--btn-text');
    }
  };

  // Style brightness buttons with NEXT brightness values
  styleBtn(brightUp, nextBriUp, null, 'brightness');
  styleBtn(brightDown, nextBriDown, null, 'brightness');

  // Style color buttons with NEXT color values
  styleBtn(colorUp, null, nextColorUp, 'color');
  styleBtn(colorDown, null, nextColorDown, 'color');

  // Style step buttons with calculated step preview values (follows curve with solar rules)
  styleBtn(stepUp, stepPreview.upBri, stepPreview.upCCT, 'combo');
  styleBtn(stepDown, stepPreview.downBri, stepPreview.downCCT, 'combo');

  // Update callouts with next values
  const briUpCallout = document.getElementById('bright-up-callout');
  const briDownCallout = document.getElementById('bright-down-callout');
  const colorUpCallout = document.getElementById('color-up-callout');
  const colorDownCallout = document.getElementById('color-down-callout');
  const stepUpBriCallout = document.getElementById('step-up-bri-callout');
  const stepUpCctCallout = document.getElementById('step-up-cct-callout');
  const stepDownBriCallout = document.getElementById('step-down-bri-callout');
  const stepDownCctCallout = document.getElementById('step-down-cct-callout');

  // Check lock states
  const brightnessLocked = document.getElementById('brightness-range-locked')?.checked;
  const colorRangeLocked = document.getElementById('color-range-locked')?.checked;
  const warmNightLocked = document.getElementById('warm-night-locked')?.checked;
  const coolDayLocked = document.getElementById('cool-day-locked')?.checked;

  // Determine effective limits based on lock state
  const briMaxLimit = brightnessLocked ? effectiveMaxPct : ABSOLUTE_MAX_BRI;
  const briMinLimit = brightnessLocked ? effectiveMinPct : ABSOLUTE_MIN_BRI;
  const cctMaxLimit = colorRangeLocked ? effectiveMaxCCT : ABSOLUTE_MAX_CCT;
  const cctMinLimit = colorRangeLocked ? effectiveMinCCT : ABSOLUTE_MIN_CCT;

  // Check for "at extreme" states
  const briAtMax = currentPct >= briMaxLimit - 0.5;
  const briAtMin = currentPct <= briMinLimit + 0.5;

  // For color extremes, check the DISPLAYED CCT
  const displayedCCT = currentCCT;  // point.cct is already the displayed CCT

  // Color max: either at color range limit, or at solar rule limit if locked
  // solar_rule_color_limit applies to whichever rule is active
  const warmWindow = getWarmNightWindow();
  const coolWindow = getCoolDayWindow();
  const warmCeiling = (warmWindow?.inWindow && runtimeState.solar_rule_color_limit !== null)
    ? runtimeState.solar_rule_color_limit
    : config.warm_night_target;
  const coolFloor = (coolWindow?.inWindow && runtimeState.solar_rule_color_limit !== null)
    ? runtimeState.solar_rule_color_limit
    : config.cool_day_target;

  let cctAtMax = displayedCCT >= cctMaxLimit - 10;
  if (config.warm_night_enabled && warmNightLocked && displayedCCT >= warmCeiling - 10) {
    cctAtMax = true;  // Can't raise ceiling when locked
  }

  let cctAtMin = displayedCCT <= cctMinLimit + 10;
  if (config.cool_day_enabled && coolDayLocked && displayedCCT <= coolFloor + 10) {
    cctAtMin = true;  // Can't lower floor when locked
  }

  // Step buttons: brightness-primary, at extreme based on brightness only
  const stepUpAtExtreme = currentPct >= ABSOLUTE_MAX_BRI - 0.5 ||
    (currentPct >= effectiveMaxPct - 0.5 && brightnessLocked);
  const stepDownAtExtreme = currentPct <= ABSOLUTE_MIN_BRI + 0.5 ||
    (currentPct <= effectiveMinPct + 0.5 && brightnessLocked);

  // Update callouts - show "max"/"min" with current value when at extreme, otherwise show delta
  // Use same starting point that stepCursor click handler uses to ensure preview matches actual behavior
  const clickBri = getBrightnessAtCursor() ?? currentPct;
  const clickCct = getDisplayedCCTAtCursor() ?? displayedCCT;
  const actualBriUp = Math.min(ABSOLUTE_MAX_BRI, clickBri + deltaPct);
  const actualBriDown = Math.max(ABSOLUTE_MIN_BRI, clickBri - deltaPct);
  const actualColorUp = Math.min(ABSOLUTE_MAX_CCT, clickCct + deltaCCT);
  const actualColorDown = Math.max(ABSOLUTE_MIN_CCT, clickCct - deltaCCT);

  if (briUpCallout) {
    const briUpDelta = Math.round(actualBriUp - currentPct);
    briUpCallout.textContent = briAtMax ? 'at max' : (briUpDelta === 0 ? '-' : `+${briUpDelta}%`);
  }
  if (briDownCallout) {
    const briDownDelta = Math.round(currentPct - actualBriDown);
    briDownCallout.textContent = briAtMin ? 'at min' : (briDownDelta === 0 ? '-' : `-${briDownDelta}%`);
  }
  if (colorUpCallout) {
    const colorUpDelta = Math.round(actualColorUp - displayedCCT);
    colorUpCallout.textContent = cctAtMax ? 'at max' : (colorUpDelta === 0 ? '-' : `+${colorUpDelta}K`);
  }
  if (colorDownCallout) {
    const colorDownDelta = Math.round(displayedCCT - actualColorDown);
    colorDownCallout.textContent = cctAtMin ? 'at min' : (colorDownDelta === 0 ? '-' : `-${colorDownDelta}K`);
  }
  // Step buttons use stepPreview (which uses step_increments)
  // Helper to format delta with proper sign
  const formatDelta = (delta, suffix, expectedPositive) => {
    if (delta === 0) return '-';
    // If delta is in wrong direction, show "-" (no valid change)
    if (expectedPositive && delta < 0) return '-';
    if (!expectedPositive && delta > 0) return '-';
    const sign = delta > 0 ? '+' : '';
    return `${sign}${delta}${suffix}`;
  };

  if (stepUpBriCallout) {
    const stepUpBriDelta = Math.round(stepPreview.upBri - currentPct);
    stepUpBriCallout.textContent = stepUpAtExtreme ? 'at max' : formatDelta(stepUpBriDelta, '%', true);
  }
  if (stepUpCctCallout) {
    const stepUpCctDelta = Math.round(stepPreview.upCCT - displayedCCT);
    stepUpCctCallout.textContent = stepUpAtExtreme ? '-' : formatDelta(stepUpCctDelta, 'K', true);
  }
  if (stepDownBriCallout) {
    const stepDownBriDelta = Math.round(stepPreview.downBri - currentPct);
    stepDownBriCallout.textContent = stepDownAtExtreme ? 'at min' : formatDelta(stepDownBriDelta, '%', false);
  }
  if (stepDownCctCallout) {
    const stepDownCctDelta = Math.round(stepPreview.downCCT - displayedCCT);
    stepDownCctCallout.textContent = stepDownAtExtreme ? '-' : formatDelta(stepDownCctDelta, 'K', false);
  }

  // Toggle at-extreme class for styling
  brightUp?.classList.toggle('at-extreme', briAtMax);
  brightDown?.classList.toggle('at-extreme', briAtMin);
  colorUp?.classList.toggle('at-extreme', cctAtMax);
  colorDown?.classList.toggle('at-extreme', cctAtMin);
  stepUp?.classList.toggle('at-extreme', stepUpAtExtreme);
  stepDown?.classList.toggle('at-extreme', stepDownAtExtreme);

  // Update button titles with target values (or "at maximum/minimum" when at extreme)
  if (brightUp) brightUp.title = briAtMax
    ? `at maximum ${Math.round(currentPct)}%`
    : `Brighten to ${Math.round(actualBriUp)}%`;
  if (brightDown) brightDown.title = briAtMin
    ? `at minimum ${Math.round(currentPct)}%`
    : `Dim to ${Math.round(actualBriDown)}%`;
  if (colorUp) colorUp.title = cctAtMax
    ? `at maximum ${Math.round(displayedCCT)}K`
    : `Cooler to ${Math.round(actualColorUp)}K`;
  if (colorDown) colorDown.title = cctAtMin
    ? `at minimum ${Math.round(displayedCCT)}K`
    : `Warmer to ${Math.round(actualColorDown)}K`;
  if (stepUp) stepUp.title = stepUpAtExtreme
    ? `at max: ${Math.round(currentPct)}% @ ${Math.round(displayedCCT)}K`
    : `Step Up to ${Math.round(stepPreview.upBri)}% at ${Math.round(stepPreview.upCCT)}K`;
  if (stepDown) stepDown.title = stepDownAtExtreme
    ? `at min: ${Math.round(currentPct)}% @ ${Math.round(stepPreview.downCCT)}K`
    : `Step Down to ${Math.round(stepPreview.downBri)}% at ${Math.round(stepPreview.downCCT)}K`;

  // Update time navigation button values
  const timeMinusBtn = document.getElementById('cursor-time-minus');
  const timePlusBtn = document.getElementById('cursor-time-plus');
  const timeMinusTime = document.getElementById('time-minus-time');
  const timePlusTime = document.getElementById('time-plus-time');
  const timeMinusValues = document.getElementById('time-minus-values');
  const timePlusValues = document.getElementById('time-plus-values');

  // Helper to format hour as H:MMa/p
  const formatTime = (hour) => {
    const h = ((hour % 24) + 24) % 24;
    const hours24 = Math.floor(h);
    const mins = Math.round((h - hours24) * 60);
    const isPM = hours24 >= 12;
    let hours12 = hours24 % 12;
    if (hours12 === 0) hours12 = 12;
    return `${hours12}:${mins.toString().padStart(2, '0')}${isPM ? 'p' : 'a'}`;
  };

  if (config && cursorHour !== null) {
    // Helper to get values at a specific hour using core calculation functions
    const getValuesAtHour = (hour) => {
      const h = ((hour % 24) + 24) % 24;  // Normalize to 0-24
      return {
        bri: Math.round(calculateBrightnessAtHour(h) * 100),  // Convert 0-1 to 0-100
        cct: Math.round(calculateColorAtHour(h, true))        // With solar rules
      };
    };

    // Use displayed values as starting point (currentPct and displayedCCT from point)
    const displayedBri = Math.round(currentPct);
    const displayedCct = Math.round(displayedCCT);

    // -5 minutes from cursor
    const minusHour = cursorHour - 5/60;
    const minusVals = getValuesAtHour(minusHour);
    const minusBriDelta = minusVals.bri - displayedBri;
    const minusCctDelta = minusVals.cct - displayedCct;
    if (timeMinusTime) timeMinusTime.textContent = formatTime(minusHour);
    if (timeMinusValues) {
      const briStr = minusBriDelta >= 0 ? `+${minusBriDelta}%` : `${minusBriDelta}%`;
      const cctStr = minusCctDelta >= 0 ? `+${minusCctDelta}K` : `${minusCctDelta}K`;
      timeMinusValues.textContent = `${briStr} ${cctStr}`;
    }
    styleBtn(timeMinusBtn, minusVals.bri, minusVals.cct, 'combo');
    if (timeMinusBtn) timeMinusBtn.title = `-5 minutes to ${minusVals.bri}% at ${minusVals.cct}K`;

    // +5 minutes from cursor
    const plusHour = cursorHour + 5/60;
    const plusVals = getValuesAtHour(plusHour);
    const plusBriDelta = plusVals.bri - displayedBri;
    const plusCctDelta = plusVals.cct - displayedCct;
    if (timePlusTime) timePlusTime.textContent = formatTime(plusHour);
    if (timePlusValues) {
      const briStr = plusBriDelta >= 0 ? `+${plusBriDelta}%` : `${plusBriDelta}%`;
      const cctStr = plusCctDelta >= 0 ? `+${plusCctDelta}K` : `${plusCctDelta}K`;
      timePlusValues.textContent = `${briStr} ${cctStr}`;
    }
    styleBtn(timePlusBtn, plusVals.bri, plusVals.cct, 'combo');
    if (timePlusBtn) timePlusBtn.title = `+5 minutes to ${plusVals.bri}% at ${plusVals.cct}K`;
  }
}

// Tint color by brightness (dim for low brightness)
function tintColorByBrightness(rgbStr, brightness) {
  const match = rgbStr.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
  if (!match) return rgbStr;
  const fraction = Math.max(0, Math.min(1, brightness / 100));
  const dimFactor = 0.25 + 0.75 * fraction;
  const [r, g, b] = [match[1], match[2], match[3]].map(v => Math.round(Number(v) * dimFactor));
  return `rgb(${r},${g},${b})`;
}

// ============================================================
// UI Updates
// ============================================================

function updateDisplay(id, value) {
  const el = document.getElementById(id);
  if (el) el.textContent = value;
}

function positionTimelineBadges() {
  const ascendBadge = document.getElementById('ascend-start-badge');
  const descendBadge = document.getElementById('descend-start-badge');

  if (ascendBadge) {
    const pct = (config.ascend_start / 24) * 100;
    ascendBadge.style.left = `${pct}%`;
  }
  if (descendBadge) {
    const pct = (config.descend_start / 24) * 100;
    descendBadge.style.left = `${pct}%`;
  }
}

function updateSliderValue(sliderId, displayId, formatter) {
  const slider = document.getElementById(sliderId);
  if (!slider) return;
  slider.addEventListener('input', () => {
    const val = parseFloat(slider.value);
    updateDisplay(displayId, formatter(val));
    syncConfigFromUI();
    renderChart();
  });
}

function syncConfigFromUI() {
  config.ascend_start = parseFloat(document.getElementById('ascend-start').value);
  config.descend_start = parseFloat(document.getElementById('descend-start').value) % 24;
  config.wake_time = parseFloat(document.getElementById('wake-time').value);
  config.bed_time = parseFloat(document.getElementById('bed-time').value) % 24;
  config.wake_speed = parseInt(document.getElementById('wake-speed').value);
  config.bed_speed = parseInt(document.getElementById('bed-speed').value);

  config.min_color_temp = parseInt(document.getElementById('color-min').value);
  config.max_color_temp = parseInt(document.getElementById('color-max').value);
  config.min_brightness = parseInt(document.getElementById('brightness-min').value);
  config.max_brightness = parseInt(document.getElementById('brightness-max').value);
  config.max_dim_steps = parseInt(document.getElementById('step-count').value);

  // Read individual increment inputs (null if empty or same as master)
  const stepInc = document.getElementById('step-increments')?.value;
  const briInc = document.getElementById('brightness-increments')?.value;
  const colorInc = document.getElementById('color-increments')?.value;
  config.step_increments = stepInc ? parseInt(stepInc) : null;
  config.brightness_increments = briInc ? parseInt(briInc) : null;
  config.color_increments = colorInc ? parseInt(colorInc) : null;

  // Constrain solar target sliders to color range (clamps values if needed)
  updateSolarTargetSliderConstraints();

  config.warm_night_enabled = document.getElementById('warm-night-enabled').checked;
  config.warm_night_mode = document.getElementById('warm-night-mode').value;
  config.warm_night_target = parseInt(document.getElementById('warm-night-target').value);
  config.warm_night_start = parseInt(document.getElementById('warm-night-start')?.value || -60);
  config.warm_night_end = parseInt(document.getElementById('warm-night-end')?.value || 60);
  config.warm_night_fade = parseInt(document.getElementById('warm-night-fade')?.value || 60);

  config.cool_day_enabled = document.getElementById('cool-day-enabled').checked;
  config.cool_day_mode = document.getElementById('cool-day-mode').value;
  config.cool_day_target = parseInt(document.getElementById('cool-day-target').value);
  config.cool_day_start = parseInt(document.getElementById('cool-day-start')?.value || 0);
  config.cool_day_end = parseInt(document.getElementById('cool-day-end')?.value || 0);
  config.cool_day_fade = parseInt(document.getElementById('cool-day-fade')?.value || 60);

  resetRuntimeState();
  updateColorGradients();
  constrainWakeBedSliders();
}

function syncUIFromConfig() {
  document.getElementById('ascend-start').value = config.ascend_start;
  document.getElementById('descend-start').value = config.descend_start;

  // Update wake/bed slider constraints BEFORE setting values
  // (prevents clamping by old constraints when switching presets)
  updateWakeBedSliderConstraints();

  // Handle wake_time slider - if it's before ascend_start, add 24 for slider
  let wakeSliderVal = config.wake_time;
  if (config.wake_time < config.ascend_start) {
    wakeSliderVal = config.wake_time + 24;
  }
  document.getElementById('wake-time').value = wakeSliderVal;

  // Handle bed_time slider - if it's before descend_start, add 24 for slider
  let bedSliderVal = config.bed_time;
  if (config.bed_time < config.descend_start) {
    bedSliderVal = config.bed_time + 24;
  }
  document.getElementById('bed-time').value = bedSliderVal;

  document.getElementById('wake-speed').value = config.wake_speed;
  document.getElementById('bed-speed').value = config.bed_speed;

  document.getElementById('color-min').value = config.min_color_temp;
  document.getElementById('color-max').value = config.max_color_temp;
  document.getElementById('brightness-min').value = config.min_brightness;
  document.getElementById('brightness-max').value = config.max_brightness;
  document.getElementById('step-count').value = config.max_dim_steps;

  // Set individual increment inputs (show effective value, defaulting to max_dim_steps)
  const effectiveStepInc = config.step_increments ?? config.max_dim_steps;
  const effectiveBriInc = config.brightness_increments ?? config.max_dim_steps;
  const effectiveColorInc = config.color_increments ?? config.max_dim_steps;
  document.getElementById('step-increments').value = effectiveStepInc;
  document.getElementById('brightness-increments').value = effectiveBriInc;
  document.getElementById('color-increments').value = effectiveColorInc;

  // Set warm/cool slider values FROM CONFIG BEFORE calling updateSolarTargetSliderConstraints
  // (that function reads slider values, so they must be set first to avoid overwriting config)
  document.getElementById('warm-night-enabled').checked = config.warm_night_enabled;
  document.getElementById('warm-night-mode').value = config.warm_night_mode;
  document.getElementById('warm-night-target').value = config.warm_night_target;
  const warmStart = document.getElementById('warm-night-start');
  const warmEnd = document.getElementById('warm-night-end');
  const warmFade = document.getElementById('warm-night-fade');
  if (warmStart) warmStart.value = config.warm_night_start;
  if (warmEnd) warmEnd.value = config.warm_night_end;
  if (warmFade) warmFade.value = config.warm_night_fade;

  document.getElementById('cool-day-enabled').checked = config.cool_day_enabled;
  document.getElementById('cool-day-mode').value = config.cool_day_mode;
  document.getElementById('cool-day-target').value = config.cool_day_target;
  const coolStart = document.getElementById('cool-day-start');
  const coolEnd = document.getElementById('cool-day-end');
  const coolFade = document.getElementById('cool-day-fade');
  if (coolStart) coolStart.value = config.cool_day_start;
  if (coolEnd) coolEnd.value = config.cool_day_end;
  if (coolFade) coolFade.value = config.cool_day_fade;

  // Now update constraints (reads slider values, enforces warm >= cool)
  updateSolarTargetSliderConstraints();

  document.getElementById('activity-preset').value = config.activity_preset || 'adult';

  updateDisplay('ascend-start-display', formatHour(config.ascend_start));
  updateDisplay('descend-start-display', formatHour(config.descend_start));
  updateDisplay('ascend-start-badge', formatHour(config.ascend_start));
  updateDisplay('descend-start-badge', formatHour(config.descend_start));
  positionTimelineBadges();
  updateDisplay('wake-time-display', formatHour(config.wake_time));
  updateDisplay('bed-time-display', formatHour(config.bed_time));
  updateDisplay('wake-speed-display', `${SPEED_LABELS[config.wake_speed]} (${config.wake_speed})`);
  updateDisplay('bed-speed-display', `${SPEED_LABELS[config.bed_speed]} (${config.bed_speed})`);
  updateDisplay('color-min-display', `${config.min_color_temp} K`);
  updateDisplay('color-max-display', `${config.max_color_temp} K`);
  updateDisplay('brightness-min-display', `${config.min_brightness}%`);
  updateDisplay('brightness-max-display', `${config.max_brightness}%`);
  updateDisplay('step-count-display', `${config.max_dim_steps} steps`);

  updateDualFills();
  updateColorGradients();
  updateOffsetDisplays();
  syncColorRuleRows();
  syncLocationUI();
  constrainWakeBedSliders();
}

// Update offset text displays
function updateOffsetDisplays() {
  const formatOffset = (val, baseEvent) => {
    const absVal = Math.abs(val);
    if (val === 0) return `at ${baseEvent}`;
    const direction = val < 0 ? 'before' : 'after';
    return `${absVal} min ${direction} ${baseEvent}`;
  };

  updateDisplay('warm-night-start-text', formatOffset(config.warm_night_start, 'sunset'));
  updateDisplay('warm-night-end-text', formatOffset(config.warm_night_end, 'sunrise'));
  updateDisplay('warm-night-fade-text', `${config.warm_night_fade} min`);
  updateDisplay('cool-day-start-text', formatOffset(config.cool_day_start, 'sunrise'));
  updateDisplay('cool-day-end-text', formatOffset(config.cool_day_end, 'sunset'));
  updateDisplay('cool-day-fade-text', `${config.cool_day_fade} min`);
}

// Sync color rule rows - toggle is-disabled based on checkbox state
function syncColorRuleRows() {
  const warmEnabled = config.warm_night_enabled;
  const coolEnabled = config.cool_day_enabled;

  // Warm night body
  const warmBody = document.getElementById('warm-night-body');
  if (warmBody) {
    warmBody.classList.toggle('is-disabled', !warmEnabled);
    warmBody.querySelectorAll('select, input[type="range"]').forEach(el => {
      el.disabled = !warmEnabled;
    });
  }

  // Cool day body
  const coolBody = document.getElementById('cool-day-body');
  if (coolBody) {
    coolBody.classList.toggle('is-disabled', !coolEnabled);
    coolBody.querySelectorAll('select, input[type="range"]').forEach(el => {
      el.disabled = !coolEnabled;
    });
  }
}

// Sync location UI elements
function syncLocationUI() {
  const useHA = document.getElementById('use-ha-location');
  const latInput = document.getElementById('location-lat');
  const lonInput = document.getElementById('location-lon');

  if (useHA) useHA.checked = config.use_ha_location;
  if (latInput) {
    latInput.value = config.latitude;
    latInput.disabled = config.use_ha_location;
  }
  if (lonInput) {
    lonInput.value = config.longitude;
    lonInput.disabled = config.use_ha_location;
  }

  updateLocationSummary();
}

// Update location summary in collapsed header
function updateLocationSummary() {
  const summary = document.getElementById('location-summary');
  if (!summary) return;

  const lat = config.latitude.toFixed(2);
  const lon = config.longitude.toFixed(2);
  const latDir = config.latitude >= 0 ? 'N' : 'S';
  const lonDir = config.longitude >= 0 ? 'E' : 'W';
  summary.textContent = `${Math.abs(lat)}Â°${latDir}, ${Math.abs(lon)}Â°${lonDir}`;
}

// Update wake/bed slider min/max constraints only (no value clamping)
// Called before setting slider values to prevent clamping by old constraints
function updateWakeBedSliderConstraints() {
  const wakeSlider = document.getElementById('wake-time');
  const bedSlider = document.getElementById('bed-time');
  if (!wakeSlider || !bedSlider) return;

  const ascendStart = config.ascend_start;
  let descendStart = config.descend_start;
  if (descendStart <= ascendStart) descendStart += 24;

  // Wake slider: ascend_start to descend_start
  wakeSlider.min = ascendStart;
  wakeSlider.max = descendStart;

  // Bed slider: descend_start to (descend_start + descend phase length)
  bedSlider.min = config.descend_start;
  bedSlider.max = config.descend_start + 24 - (descendStart - ascendStart);
}

// Constrain warm_night_target and cool_day_target sliders to color range
// and enforce warm_night_target >= cool_day_target (ceiling >= floor)
// by setting dynamic slider bounds - you can't push one past the other
function updateSolarTargetSliderConstraints() {
  const warmSlider = document.getElementById('warm-night-target');
  const coolSlider = document.getElementById('cool-day-target');
  if (!warmSlider || !coolSlider) return;

  const minTemp = config.min_color_temp;
  const maxTemp = config.max_color_temp;

  let warmVal = parseInt(warmSlider.value);
  let coolVal = parseInt(coolSlider.value);

  // Clamp both to color range first
  warmVal = Math.max(minTemp, Math.min(maxTemp, warmVal));
  coolVal = Math.max(minTemp, Math.min(maxTemp, coolVal));

  // If color range change caused warm < cool, clamp cool down to warm
  if (warmVal < coolVal) {
    coolVal = warmVal;
  }

  // Set dynamic bounds:
  // - warm can't go below cool (min = coolVal)
  // - cool can't go above warm (max = warmVal)
  warmSlider.min = coolVal;
  warmSlider.max = maxTemp;
  coolSlider.min = minTemp;
  coolSlider.max = warmVal;

  // Apply values
  warmSlider.value = warmVal;
  coolSlider.value = coolVal;
  config.warm_night_target = warmVal;
  config.cool_day_target = coolVal;

  // Update track gradients to match new bounds
  updateColorGradients();
}

// Constrain wake slider to between ascend_start and descend_start
// Constrain bed slider to between descend_start and ascend_start (wrapping)
function constrainWakeBedSliders() {
  const wakeSlider = document.getElementById('wake-time');
  const bedSlider = document.getElementById('bed-time');
  if (!wakeSlider || !bedSlider) return;

  // Update constraints first
  updateWakeBedSliderConstraints();

  // Wake must be between ascend_start and descend_start
  const ascendStart = config.ascend_start;
  let descendStart = config.descend_start;
  if (descendStart <= ascendStart) descendStart += 24;

  // Clamp current value
  let wakeVal = parseFloat(wakeSlider.value);
  if (wakeVal < ascendStart) wakeVal = ascendStart;
  if (wakeVal > descendStart) wakeVal = descendStart;
  wakeSlider.value = wakeVal;
  config.wake_time = wakeVal % 24;
  updateDisplay('wake-time-display', formatHour(config.wake_time));

  // Bed: clamp to new constraints
  let bedVal = parseFloat(bedSlider.value);
  const bedMin = parseFloat(bedSlider.min);
  const bedMax = parseFloat(bedSlider.max);
  if (bedVal < bedMin) bedVal = bedMin;
  if (bedVal > bedMax) bedVal = bedMax;
  bedSlider.value = bedVal;
  config.bed_time = bedVal % 24;
  updateDisplay('bed-time-display', formatHour(config.bed_time));
}

function updateDualFills() {
  const colorMin = parseInt(document.getElementById('color-min').value);
  const colorMax = parseInt(document.getElementById('color-max').value);
  const colorFill = document.getElementById('color-fill');
  if (colorFill) {
    const left = ((colorMin - 500) / 6000) * 100;
    const right = ((colorMax - 500) / 6000) * 100;
    colorFill.style.left = `${left}%`;
    colorFill.style.width = `${right - left}%`;
  }

  const briMin = parseInt(document.getElementById('brightness-min').value);
  const briMax = parseInt(document.getElementById('brightness-max').value);
  const briFill = document.getElementById('brightness-fill');
  if (briFill) {
    briFill.style.left = `${briMin}%`;
    briFill.style.width = `${briMax - briMin}%`;
  }
}

function resetRuntimeState() {
  // Reset turns on circadian lighting and resets to default curve
  runtimeState.enabled = true;
  runtimeState.frozen = false;
  // Reset midpoints to follow config
  runtimeState.brightness_mid = null;
  runtimeState.color_mid = null;
  // Reset solar rule limit
  runtimeState.solar_rule_color_limit = null;
  // Reset brightness/color bounds
  runtimeState.max_brightness = null;
  runtimeState.min_brightness = null;
  runtimeState.max_color_temp = null;
  runtimeState.min_color_temp = null;
}

// ============================================================
// Event Handlers
// ============================================================

function setupEventListeners() {
  updateSliderValue('ascend-start', 'ascend-start-display', formatHour);
  updateSliderValue('descend-start', 'descend-start-display', formatHour);
  updateSliderValue('wake-time', 'wake-time-display', formatHour);
  updateSliderValue('bed-time', 'bed-time-display', formatHour);
  updateSliderValue('wake-speed', 'wake-speed-display', v => `${SPEED_LABELS[v]} (${v})`);
  updateSliderValue('bed-speed', 'bed-speed-display', v => `${SPEED_LABELS[v]} (${v})`);

  updateSliderValue('color-min', 'color-min-display', v => `${v} K`);
  updateSliderValue('color-max', 'color-max-display', v => `${v} K`);
  updateSliderValue('brightness-min', 'brightness-min-display', v => `${v}%`);
  updateSliderValue('brightness-max', 'brightness-max-display', v => `${v}%`);
  updateSliderValue('step-count', 'step-count-display', v => `${v} steps`);

  // Master increments slider updates all 3 individual increment inputs
  document.getElementById('step-count')?.addEventListener('input', () => {
    const masterVal = parseInt(document.getElementById('step-count').value);
    document.getElementById('step-increments').value = masterVal;
    document.getElementById('brightness-increments').value = masterVal;
    document.getElementById('color-increments').value = masterVal;
    // Clear individual overrides (they now match master)
    config.step_increments = null;
    config.brightness_increments = null;
    config.color_increments = null;
  });

  // Individual increment inputs update config directly (without resetting runtime state)
  document.getElementById('step-increments')?.addEventListener('input', (e) => {
    config.step_increments = e.target.value ? parseInt(e.target.value) : null;
    renderChart();
  });
  document.getElementById('brightness-increments')?.addEventListener('input', (e) => {
    config.brightness_increments = e.target.value ? parseInt(e.target.value) : null;
    renderChart();
  });
  document.getElementById('color-increments')?.addEventListener('input', (e) => {
    config.color_increments = e.target.value ? parseInt(e.target.value) : null;
    renderChart();
  });

  // Warm/cool target sliders (inside popups)
  // Call updateSolarTargetSliderConstraints to update dynamic bounds
  // (warm can't go below cool, cool can't go above warm)
  document.getElementById('warm-night-target')?.addEventListener('input', () => {
    config.warm_night_target = parseInt(document.getElementById('warm-night-target').value);
    updateSolarTargetSliderConstraints();
    renderChart();
  });
  document.getElementById('cool-day-target')?.addEventListener('input', () => {
    config.cool_day_target = parseInt(document.getElementById('cool-day-target').value);
    updateSolarTargetSliderConstraints();
    renderChart();
  });

  // Offset sliders
  ['warm-night-start', 'warm-night-end', 'warm-night-fade', 'cool-day-start', 'cool-day-end', 'cool-day-fade'].forEach(id => {
    const el = document.getElementById(id);
    if (el) {
      el.addEventListener('input', () => {
        syncConfigFromUI();
        updateOffsetDisplays();
        renderChart();
      });
    }
  });

  ['warm-night-enabled', 'cool-day-enabled', 'warm-night-mode', 'cool-day-mode'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('change', () => { syncConfigFromUI(); syncColorRuleRows(); renderChart(); });
  });

  // Color chip buttons - toggle popups
  document.getElementById('warm-night-target-chip')?.addEventListener('click', (e) => {
    e.stopPropagation();
    const popup = document.getElementById('warm-night-popup');
    const other = document.getElementById('cool-day-popup');
    if (other) other.classList.remove('is-open');
    popup?.classList.toggle('is-open');
  });
  document.getElementById('cool-day-target-chip')?.addEventListener('click', (e) => {
    e.stopPropagation();
    const popup = document.getElementById('cool-day-popup');
    const other = document.getElementById('warm-night-popup');
    if (other) other.classList.remove('is-open');
    popup?.classList.toggle('is-open');
  });

  // Close popups when clicking outside
  document.addEventListener('click', (e) => {
    if (!e.target.closest('.color-controls-wrap')) {
      document.querySelectorAll('.color-slider-popup').forEach(p => p.classList.remove('is-open'));
    }
    // Close info tooltips when clicking outside
    if (!e.target.closest('.info-icon') && !e.target.closest('.info-tooltip')) {
      document.querySelectorAll('.info-tooltip').forEach(t => t.classList.remove('is-open'));
    }
  });

  // Info icon click handlers - toggle tooltip visibility
  document.querySelectorAll('.info-icon').forEach(icon => {
    icon.addEventListener('click', (e) => {
      e.stopPropagation();
      const tooltipId = icon.getAttribute('data-tooltip');
      const tooltip = document.getElementById(tooltipId);
      // Close other tooltips
      document.querySelectorAll('.info-tooltip').forEach(t => {
        if (t.id !== tooltipId) t.classList.remove('is-open');
      });
      tooltip?.classList.toggle('is-open');
    });
  });

  document.getElementById('activity-preset').addEventListener('change', (e) => {
    const preset = ACTIVITY_PRESETS[e.target.value];
    if (preset) {
      config.activity_preset = e.target.value;
      config.wake_time = preset.wake_time;
      config.bed_time = preset.bed_time;
      config.warm_night_enabled = preset.warm_night_enabled;
      config.cool_day_enabled = preset.cool_day_enabled;

      // Get current sun times for solar-based presets
      const { solarNoon, solarMid } = getSunTimes(config.latitude, config.longitude, getSelectedDateISO());
      const solarNoonRounded = Math.round(solarNoon);
      const solarMidRounded = Math.round(solarMid);

      // Young Child: ascend=solar midnight, descend=solar noon
      // Adult: descend=solar noon (ascend stays fixed)
      if (e.target.value === 'young') {
        config.ascend_start = solarMidRounded % 24;
        config.descend_start = solarNoonRounded % 24;
      } else if (e.target.value === 'adult') {
        config.ascend_start = preset.ascend_start;
        config.descend_start = solarNoonRounded % 24;
      } else {
        config.ascend_start = preset.ascend_start;
        config.descend_start = preset.descend_start;
      }

      resetRuntimeState();
      syncUIFromConfig();
      renderChart();
    }
  });

  document.getElementById('chart-date-slider').addEventListener('input', () => {
    renderChart();
  });

  document.getElementById('cursor-step-up')?.addEventListener('click', () => stepCursor('up', true, true));
  document.getElementById('cursor-step-down')?.addEventListener('click', () => stepCursor('down', true, true));
  document.getElementById('cursor-bright-up')?.addEventListener('click', () => stepCursor('up', true, false));
  document.getElementById('cursor-bright-down')?.addEventListener('click', () => stepCursor('down', true, false));
  document.getElementById('cursor-color-up')?.addEventListener('click', () => stepCursor('up', false, true));
  document.getElementById('cursor-color-down')?.addEventListener('click', () => stepCursor('down', false, true));
  document.getElementById('cursor-reset')?.addEventListener('click', () => {
    // Reset runtime state but keep cursor position
    resetRuntimeState();
    renderChart();
    applyCursor();
  });

  // Time navigation buttons
  document.getElementById('cursor-time-now')?.addEventListener('click', () => {
    const now = new Date();
    cursorHour = now.getHours() + now.getMinutes() / 60;
    renderChart();
    applyCursor();
  });
  document.getElementById('cursor-time-plus')?.addEventListener('click', () => {
    cursorHour = (cursorHour + 5/60) % 24;  // +5 minutes, wrap at 24
    renderChart();
    applyCursor();
  });
  document.getElementById('cursor-time-minus')?.addEventListener('click', () => {
    cursorHour = (cursorHour - 5/60 + 24) % 24;  // -5 minutes, wrap at 0
    renderChart();
    applyCursor();
  });

  ['color-min', 'color-max', 'brightness-min', 'brightness-max'].forEach(id => {
    document.getElementById(id)?.addEventListener('input', updateDualFills);
  });

  // Location section toggle
  document.getElementById('location-header')?.addEventListener('click', () => {
    const section = document.getElementById('location-section');
    if (section) section.classList.toggle('is-open');
  });

  // Use HA location toggle
  document.getElementById('use-ha-location')?.addEventListener('change', (e) => {
    config.use_ha_location = e.target.checked;
    const latInput = document.getElementById('location-lat');
    const lonInput = document.getElementById('location-lon');
    if (latInput) latInput.disabled = config.use_ha_location;
    if (lonInput) lonInput.disabled = config.use_ha_location;
  });

  // Lat/long inputs
  document.getElementById('location-lat')?.addEventListener('change', (e) => {
    config.latitude = parseFloat(e.target.value) || 0;
    updateLocationSummary();
    renderChart();
  });
  document.getElementById('location-lon')?.addEventListener('change', (e) => {
    config.longitude = parseFloat(e.target.value) || 0;
    updateLocationSummary();
    renderChart();
  });

  document.getElementById('save-config')?.addEventListener('click', saveConfig);
}

// Inverse logistic: find midpoint that gives target value at time x
function inverseMidpoint(x, targetValue, slope, y0, y1) {
  // Clamp target to avoid division issues
  const epsilon = 0.001;
  const clampedTarget = Math.max(y0 + epsilon, Math.min(y1 - epsilon, targetValue));
  const ratio = (clampedTarget - y0) / (y1 - y0);
  // midpoint = x + ln((1 - ratio) / ratio) / slope
  return x + Math.log((1 - ratio) / ratio) / slope;
}

// Get current brightness at cursor (0-100 scale) using core calculation
function getBrightnessAtCursor() {
  if (cursorHour === null || !config) return null;
  return calculateBrightnessAtHour(cursorHour) * 100;  // Convert 0-1 to 0-100
}

// Get displayed CCT at cursor (AFTER solar rules are applied) using core calculation
function getDisplayedCCTAtCursor() {
  if (cursorHour === null || !config) return null;
  return calculateColorAtHour(cursorHour, true);  // With solar rules
}

// Get current CCT value at cursor (before solar rules, from base curve) using core calculation
function getBaseCCTAtCursor() {
  if (cursorHour === null || !config) return null;
  return calculateColorAtHour(cursorHour, false);  // Without solar rules
}

function stepCursor(direction, adjustBrightness, adjustColor) {
  if (cursorHour === null) return;

  const sign = direction === 'up' ? 1 : -1;
  // Select increment based on mode
  let steps;
  if (adjustBrightness && adjustColor) {
    steps = config.step_increments ?? config.max_dim_steps ?? 10;
  } else if (adjustBrightness) {
    steps = config.brightness_increments ?? config.max_dim_steps ?? 10;
  } else {
    steps = config.color_increments ?? config.max_dim_steps ?? 10;
  }

  const tAscend = config.ascend_start;
  let tDescend = config.descend_start;
  if (tDescend <= tAscend) tDescend += 24;
  let h48 = cursorHour < tAscend ? cursorHour + 24 : cursorHour;
  const inAscend = h48 >= tAscend && h48 < tDescend;

  // Clamp speed to valid range 1-10 (matches brain.py)
  const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.wake_speed))];
  const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, config.bed_speed))];
  const slope = inAscend ? kAscend : -kDescend;

  // For Step Up/Down: brightness-primary, traverse diverged curve
  if (adjustBrightness && adjustColor) {
    // Absolute limits (hardcoded, never exceeded)
    const ABSOLUTE_MIN_BRI = 1;
    const ABSOLUTE_MAX_BRI = 100;
    const ABSOLUTE_MIN_CCT = 500;
    const ABSOLUTE_MAX_CCT = 6500;

    // Config bounds
    const configMinBri = config.min_brightness;
    const configMaxBri = config.max_brightness;
    const configMinCCT = config.min_color_temp;
    const configMaxCCT = config.max_color_temp;

    // Current runtime bounds (may have been pushed)
    const bMin = runtimeState.min_brightness ?? configMinBri;
    const bMax = runtimeState.max_brightness ?? configMaxBri;
    const cMin = runtimeState.min_color_temp ?? configMinCCT;
    const cMax = runtimeState.max_color_temp ?? configMaxCCT;

    // Step size based on config range
    const briStep = (configMaxBri - configMinBri) / steps;

    // Current values
    const currentBri = getBrightnessAtCursor();
    const currentCCT = getDisplayedCCTAtCursor();
    if (currentBri === null || currentCCT === null) return;

    // Check lock state
    const brightnessLocked = document.getElementById('brightness-range-locked')?.checked;

    // Calculate target brightness
    let targetBri = currentBri + sign * briStep;

    // Check if at or would exceed config bounds (triggers pushing behavior)
    const atConfigMax = direction === 'up' && (currentBri >= bMax - 0.5 || targetBri >= bMax);
    const atConfigMin = direction === 'down' && (currentBri <= bMin + 0.5 || targetBri <= bMin);

    // Check if at absolute limits
    const atAbsoluteMax = currentBri >= ABSOLUTE_MAX_BRI - 0.5;
    const atAbsoluteMin = currentBri <= ABSOLUTE_MIN_BRI + 0.5;

    if ((direction === 'up' && atAbsoluteMax) || (direction === 'down' && atAbsoluteMin)) {
      return; // At absolute limit, can't go further
    }

    if ((atConfigMax || atConfigMin) && brightnessLocked) {
      return; // At config bound and locked, can't push
    }

    let targetCCT;

    if (atConfigMax || atConfigMin) {
      // === PUSHING BEYOND CONFIG BOUNDS ===
      // Push brightness and color proportionally toward absolute limits

      const briAbsoluteLimit = direction === 'up' ? ABSOLUTE_MAX_BRI : ABSOLUTE_MIN_BRI;
      const briCurrentBound = direction === 'up' ? bMax : bMin;
      const briHeadroom = Math.abs(briAbsoluteLimit - briCurrentBound);

      // How much to push (capped by headroom and step size)
      const briPushAmount = Math.min(briStep, briHeadroom);
      const pushPercent = briHeadroom > 0 ? briPushAmount / briHeadroom : 0;

      // Push brightness
      if (direction === 'up') {
        targetBri = bMax + briPushAmount;
        runtimeState.max_brightness = Math.min(ABSOLUTE_MAX_BRI, targetBri);
      } else {
        targetBri = bMin - briPushAmount;
        runtimeState.min_brightness = Math.max(ABSOLUTE_MIN_BRI, targetBri);
      }

      // Push color proportionally
      const cctAbsoluteLimit = direction === 'up' ? ABSOLUTE_MAX_CCT : ABSOLUTE_MIN_CCT;
      const cctHeadroom = Math.abs(cctAbsoluteLimit - currentCCT);
      const cctPushAmount = pushPercent * cctHeadroom;

      if (direction === 'up') {
        // Step Up = cooler
        targetCCT = currentCCT + cctPushAmount;
        // Push through any limiting bounds
        if (targetCCT > cMax) {
          runtimeState.max_color_temp = Math.min(ABSOLUTE_MAX_CCT, targetCCT);
        }
        const warmCeiling = runtimeState.solar_rule_color_limit ?? config.warm_night_target;
        if (config.warm_night_enabled && targetCCT > warmCeiling) {
          runtimeState.solar_rule_color_limit = Math.min(ABSOLUTE_MAX_CCT, targetCCT);
        }
      } else {
        // Step Down = warmer
        targetCCT = currentCCT - cctPushAmount;
        // Push through any limiting bounds
        if (targetCCT < cMin) {
          runtimeState.min_color_temp = Math.max(ABSOLUTE_MIN_CCT, targetCCT);
        }
        const coolFloor = runtimeState.solar_rule_color_limit ?? config.cool_day_target;
        if (config.cool_day_enabled && targetCCT < coolFloor) {
          runtimeState.solar_rule_color_limit = Math.max(ABSOLUTE_MIN_CCT, targetCCT);
        }
      }

      // When pushing bounds, don't update midpoints - just render with new bounds
      renderChart();
      applyCursor();
      return;

    } else {
      // === WITHIN BOUNDS - TRAVERSE DIVERGED CURVE ===
      // Find virtual time T' where brightness curve = targetBri
      // Then get color at T' from color curve (using its own midpoint)

      // Check if target would exceed absolute limits (prevents wrap-around)
      if (targetBri <= ABSOLUTE_MIN_BRI) {
        return; // At absolute minimum
      }
      if (targetBri >= ABSOLUTE_MAX_BRI) {
        return; // At absolute maximum
      }

      // Get current midpoints
      const briMid = runtimeState.brightness_mid ?? (inAscend ? config.wake_time : config.bed_time);
      const colorMid = runtimeState.color_mid ?? (inAscend ? config.wake_time : config.bed_time);

      // Lift midpoints into 48h space
      let briMid48 = briMid;
      let colorMid48 = colorMid;
      if (inAscend) {
        while (briMid48 < tAscend) briMid48 += 24;
        while (colorMid48 < tAscend) colorMid48 += 24;
      } else {
        while (briMid48 < tDescend) briMid48 += 24;
        while (colorMid48 < tDescend) colorMid48 += 24;
      }

      // Calculate virtual time T' where brightness = targetBri
      // logistic: y = y0 + (y1-y0) / (1 + exp(-k*(t-mid)))
      // Solving for t: t = mid + ln(ratio/(1-ratio)) / k
      const bMinNorm = bMin / 100;
      const bMaxNorm = bMax / 100;
      const targetBriNorm = Math.max(bMinNorm + 0.001, Math.min(bMaxNorm - 0.001, targetBri / 100));
      const briRatio = (targetBriNorm - bMinNorm) / (bMaxNorm - bMinNorm);
      const virtualTime = briMid48 + Math.log(briRatio / (1 - briRatio)) / slope;

      // Get color at virtual time from color curve (base curve, no solar rules)
      const cMinNorm = 0;
      const cMaxNorm = 1;
      let colorNorm;
      if (inAscend) {
        colorNorm = logistic(virtualTime, colorMid48, slope, cMinNorm, cMaxNorm);
      } else {
        const vtDescend = virtualTime < tDescend ? virtualTime + 24 : virtualTime;
        colorNorm = logistic(vtDescend, colorMid48, slope, cMinNorm, cMaxNorm);
      }
      targetCCT = cMin + (cMax - cMin) * colorNorm;
    }

    // Clamp targets to current effective bounds
    const effectiveBriMin = runtimeState.min_brightness ?? configMinBri;
    const effectiveBriMax = runtimeState.max_brightness ?? configMaxBri;
    const effectiveCCTMin = runtimeState.min_color_temp ?? configMinCCT;
    const effectiveCCTMax = runtimeState.max_color_temp ?? configMaxCCT;

    targetBri = Math.max(effectiveBriMin, Math.min(effectiveBriMax, targetBri));
    targetCCT = Math.max(effectiveCCTMin, Math.min(effectiveCCTMax, targetCCT));

    // Now adjust midpoints so current time gives these target values
    const targetBriNorm = targetBri / 100;
    const bMinNorm = effectiveBriMin / 100;
    const bMaxNorm = effectiveBriMax / 100;

    const targetCCTNorm = (targetCCT - effectiveCCTMin) / (effectiveCCTMax - effectiveCCTMin);

    let calcTime = h48;
    if (!inAscend && h48 < tDescend) calcTime = h48 + 24;

    const newBriMid = inverseMidpoint(calcTime, targetBriNorm, slope, bMinNorm, bMaxNorm);
    const newColorMid = inverseMidpoint(calcTime, targetCCTNorm, slope, 0, 1);

    runtimeState.brightness_mid = newBriMid;
    runtimeState.color_mid = newColorMid;

    renderChart();
    applyCursor();
    return;
  }

  // Brightness only: fixed value increments
  if (adjustBrightness && !adjustColor) {
    // Absolute limits
    const ABSOLUTE_MIN_BRI = 1;
    const ABSOLUTE_MAX_BRI = 100;

    // Use runtime bounds if set, otherwise config
    const bMin = runtimeState.min_brightness ?? config.min_brightness;
    const bMax = runtimeState.max_brightness ?? config.max_brightness;
    const briStep = (config.max_brightness - config.min_brightness) / steps;  // Step based on config range

    const currentBri = getBrightnessAtCursor();
    if (currentBri === null) return;

    // Calculate target
    let targetBri = currentBri + sign * briStep;

    // Check if brightness range is locked
    const brightnessLocked = document.getElementById('brightness-range-locked')?.checked;

    // Check if we need to push bounds
    if (direction === 'up' && currentBri >= bMax - 0.5) {
      // At current max - push the bound up if not at absolute limit
      if (bMax >= ABSOLUTE_MAX_BRI - 0.5 || brightnessLocked) {
        return;  // At absolute max or locked, can't go higher
      }
      const newMax = Math.min(ABSOLUTE_MAX_BRI, bMax + briStep);
      runtimeState.max_brightness = newMax;
      targetBri = newMax;
    } else if (direction === 'down' && currentBri <= bMin + 0.5) {
      // At current min - push the bound down if not at absolute limit
      if (bMin <= ABSOLUTE_MIN_BRI + 0.5 || brightnessLocked) {
        return;  // At absolute min or locked, can't go lower
      }
      const newMin = Math.max(ABSOLUTE_MIN_BRI, bMin - briStep);
      runtimeState.min_brightness = newMin;
      targetBri = newMin;
    }

    // Clamp target to current bounds (after potential push)
    const effectiveMin = runtimeState.min_brightness ?? config.min_brightness;
    const effectiveMax = runtimeState.max_brightness ?? config.max_brightness;
    targetBri = Math.max(effectiveMin, Math.min(effectiveMax, targetBri));

    // Reverse-solve midpoint using effective bounds
    const targetNorm = targetBri / 100;
    const bMinNorm = effectiveMin / 100;
    const bMaxNorm = effectiveMax / 100;

    // Get the correct time representation for inverse calculation
    let calcTime = h48;
    if (!inAscend && h48 < tDescend) calcTime = h48 + 24;

    const newMid = inverseMidpoint(calcTime, targetNorm, slope, bMinNorm, bMaxNorm);

    runtimeState.brightness_mid = newMid;
  }

  // Color only: fixed value increments based on DISPLAYED color
  if (adjustColor && !adjustBrightness) {
    // Absolute limits
    const ABSOLUTE_MIN_CCT = 500;
    const ABSOLUTE_MAX_CCT = 6500;

    // Use runtime bounds if set, otherwise config
    const cMin = runtimeState.min_color_temp ?? config.min_color_temp;
    const cMax = runtimeState.max_color_temp ?? config.max_color_temp;
    const cctStep = (config.max_color_temp - config.min_color_temp) / steps;  // Step based on config range

    // Get DISPLAYED CCT (after solar rules) - this is what user sees
    const displayedCCT = getDisplayedCCTAtCursor();
    if (displayedCCT === null) return;

    // Calculate target
    let targetCCT = displayedCCT + sign * cctStep;

    // Check if color range is locked
    const colorRangeLocked = document.getElementById('color-range-locked')?.checked;

    // Check if we need to push bounds
    if (direction === 'up' && displayedCCT >= cMax - 10) {
      // At current max - push the bound up if not at absolute limit
      if (cMax >= ABSOLUTE_MAX_CCT - 10 || colorRangeLocked) {
        return;  // At absolute max or locked, can't go higher
      }
      const newMax = Math.min(ABSOLUTE_MAX_CCT, cMax + cctStep);
      runtimeState.max_color_temp = newMax;
      targetCCT = newMax;
    } else if (direction === 'down' && displayedCCT <= cMin + 10) {
      // At current min - push the bound down if not at absolute limit
      if (cMin <= ABSOLUTE_MIN_CCT + 10 || colorRangeLocked) {
        return;  // At absolute min or locked, can't go lower
      }
      const newMin = Math.max(ABSOLUTE_MIN_CCT, cMin - cctStep);
      runtimeState.min_color_temp = newMin;
      targetCCT = newMin;
    }

    // Effective bounds after potential push
    const effectiveMin = runtimeState.min_color_temp ?? config.min_color_temp;
    const effectiveMax = runtimeState.max_color_temp ?? config.max_color_temp;
    targetCCT = Math.max(effectiveMin, Math.min(effectiveMax, targetCCT));

    // Get current runtime limit for solar rules (applies to whichever is active)
    const currentLimit = runtimeState.solar_rule_color_limit;
    const warmCeiling = currentLimit ?? config.warm_night_target;
    const coolFloor = currentLimit ?? config.cool_day_target;

    // Check if solar rule locks are enabled
    const warmNightLocked = document.getElementById('warm-night-locked')?.checked;
    const coolDayLocked = document.getElementById('cool-day-locked')?.checked;

    // Color Up (cooler): may need to raise warm_night ceiling
    if (direction === 'up' && config.warm_night_enabled && targetCCT > warmCeiling && !warmNightLocked) {
      runtimeState.solar_rule_color_limit = targetCCT;
    }

    // Color Down (warmer): may need to lower cool_day floor
    if (direction === 'down' && config.cool_day_enabled && targetCCT < coolFloor && !coolDayLocked) {
      runtimeState.solar_rule_color_limit = targetCCT;
    }

    // Now adjust the color midpoint so base curve = target
    // (With ceiling/floor adjusted, the target will be displayed correctly)
    const targetNorm = (targetCCT - effectiveMin) / (effectiveMax - effectiveMin);

    let calcTime = h48;
    if (!inAscend && h48 < tDescend) calcTime = h48 + 24;

    const newMid = inverseMidpoint(calcTime, targetNorm, slope, 0, 1);

    runtimeState.color_mid = newMid;
  }

  renderChart();
  applyCursor();
}

// ============================================================
// API Communication
// ============================================================

async function loadConfig() {
  try {
    const resp = await fetch('./api/config');
    if (resp.ok) {
      const data = await resp.json();
      Object.assign(config, data);
      resetRuntimeState();
      syncUIFromConfig();
      renderChart();
    }
  } catch (err) {
    console.error('Error loading config:', err);
  }
}

async function saveConfig() {
  const statusEl = document.getElementById('save-status');
  try {
    const resp = await fetch('./api/config', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify(config)
    });

    if (resp.ok) {
      const result = await resp.json();
      if (result.refreshed) {
        statusEl.innerHTML = '<div class="success">Saved and refreshing lights...</div>';
      } else {
        statusEl.innerHTML = '<div class="success">Configuration saved!</div>';
      }
    } else {
      statusEl.innerHTML = '<div class="error">Failed to save configuration</div>';
    }
  } catch (err) {
    statusEl.innerHTML = '<div class="error">Error saving configuration: ' + err.message + '</div>';
  }

  setTimeout(() => { statusEl.innerHTML = ''; }, 3000);
}

// ============================================================
// Live Design Functions
// ============================================================

/**
 * Load areas from Home Assistant and populate the dropdown.
 */
async function loadLiveDesignAreas() {
  const select = document.getElementById('live-area-select');
  if (!select) return;

  console.log('[Live Design] Loading areas...');

  try {
    const response = await fetch('./api/areas');
    console.log('[Live Design] API response status:', response.status);

    if (!response.ok) {
      const text = await response.text();
      console.warn('[Live Design] Failed to load areas:', response.status, text);
      return;
    }
    const areas = await response.json();
    console.log('[Live Design] Received areas:', areas);

    if (!Array.isArray(areas) || areas.length === 0) {
      console.warn('[Live Design] No areas returned or invalid response');
      return;
    }

    // Clear existing options except the placeholder
    while (select.options.length > 1) {
      select.remove(1);
    }

    // Add area options
    areas.forEach(area => {
      const option = document.createElement('option');
      option.value = area.area_id;
      option.textContent = area.name;
      select.appendChild(option);
    });
    console.log('[Live Design] Added', areas.length, 'areas to dropdown');
  } catch (err) {
    console.error('[Live Design] Error loading areas:', err);
  }
}

/**
 * Get the brightness and color temperature at the current cursor position.
 * @returns {Object|null} {brightness, colorTemp} or null if cursor not set
 */
function getCursorLightValues() {
  if (cursorHour === null || !config) return null;

  // Use core calculation functions for exact values (consistent with brain.py)
  return {
    brightness: calculateBrightnessAtHour(cursorHour) * 100,  // Convert 0-1 to 0-100
    colorTemp: calculateColorAtHour(cursorHour, true)         // With solar rules
  };
}

/**
 * Apply the current cursor lighting values to the selected area.
 */
async function applyLiveLight() {
  console.log('[Live Design] applyLiveLight called, enabled=', liveDesignEnabled, 'areaId=', liveDesignAreaId);
  if (!liveDesignEnabled || !liveDesignAreaId) {
    console.log('[Live Design] Skipping - not enabled or no area selected');
    return;
  }

  const values = getCursorLightValues();
  console.log('[Live Design] Cursor values:', values);
  if (!values) {
    console.log('[Live Design] No cursor values available');
    return;
  }

  const statusEl = document.getElementById('live-design-status');

  console.log('[Live Design] Sending to API:', {
    area_id: liveDesignAreaId,
    brightness: Math.round(values.brightness),
    color_temp: Math.round(values.colorTemp)
  });

  try {
    const response = await fetch('./api/apply-light', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        area_id: liveDesignAreaId,
        brightness: Math.round(values.brightness),
        color_temp: Math.round(values.colorTemp)
      })
    });

    if (response.ok) {
      if (statusEl) {
        statusEl.textContent = `${Math.round(values.brightness)}% / ${Math.round(values.colorTemp)}K`;
        statusEl.classList.add('active');
      }
    } else {
      console.warn('Failed to apply light:', response.status);
      if (statusEl) {
        statusEl.textContent = 'Error';
        statusEl.classList.remove('active');
      }
    }
  } catch (err) {
    console.error('Error applying live light:', err);
    if (statusEl) {
      statusEl.textContent = 'Error';
      statusEl.classList.remove('active');
    }
  }
}

/**
 * Enable or disable Circadian mode for an area via API.
 */
async function setCircadianMode(areaId, enabled) {
  if (!areaId) return;

  try {
    const response = await fetch('./api/circadian-mode', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ area_id: areaId, enabled })
    });

    if (response.ok) {
      console.log(`[Live Design] Circadian mode ${enabled ? 'enabled' : 'disabled'} for ${areaId}`);
    } else {
      console.warn('[Live Design] Failed to set circadian mode:', response.status);
    }
  } catch (err) {
    console.error('[Live Design] Error setting circadian mode:', err);
  }
}

/**
 * Set up Live Design event listeners.
 */
function setupLiveDesign() {
  const toggleBtn = document.getElementById('live-design-toggle');
  const areaSelect = document.getElementById('live-area-select');
  const statusEl = document.getElementById('live-design-status');

  if (toggleBtn) {
    toggleBtn.addEventListener('click', async () => {
      // Require an area to be selected before enabling
      if (!liveDesignEnabled && !liveDesignAreaId) {
        if (statusEl) {
          statusEl.textContent = 'Select an area first';
          statusEl.classList.remove('active');
        }
        return;
      }

      liveDesignEnabled = !liveDesignEnabled;
      toggleBtn.textContent = liveDesignEnabled ? 'Disable' : 'Enable';
      toggleBtn.classList.toggle('active', liveDesignEnabled);

      // Disable/enable Circadian mode for the area
      if (liveDesignEnabled) {
        // Disable Circadian so periodic updates don't override Live Design
        await setCircadianMode(liveDesignAreaId, false);
      } else {
        // Re-enable Circadian when done with Live Design
        await setCircadianMode(liveDesignAreaId, true);
      }

      if (statusEl) {
        if (liveDesignEnabled) {
          statusEl.textContent = 'Circadian paused - designing';
          statusEl.classList.add('active');
        } else {
          statusEl.textContent = 'Circadian resumed';
          statusEl.classList.remove('active');
          // Clear status after a moment
          setTimeout(() => {
            if (!liveDesignEnabled && statusEl) {
              statusEl.textContent = '';
            }
          }, 2000);
        }
      }

      // If just enabled and cursor is already set, apply immediately
      if (liveDesignEnabled && cursorHour !== null) {
        applyLiveLight();
      }
    });
  }

  if (areaSelect) {
    areaSelect.addEventListener('change', async (e) => {
      const oldAreaId = liveDesignAreaId;
      liveDesignAreaId = e.target.value || null;

      // If Live Design is active and area changed, swap Circadian mode
      if (liveDesignEnabled) {
        if (oldAreaId) {
          // Re-enable Circadian for the old area
          await setCircadianMode(oldAreaId, true);
        }
        if (liveDesignAreaId) {
          // Disable Circadian for the new area
          await setCircadianMode(liveDesignAreaId, false);
        }
      }

      // Reset status when area changes
      if (statusEl) {
        if (liveDesignAreaId && liveDesignEnabled) {
          statusEl.textContent = 'Circadian paused - designing';
          statusEl.classList.add('active');
        } else {
          statusEl.textContent = '';
          statusEl.classList.remove('active');
        }
      }
    });
  }

  // Load areas from HA
  loadLiveDesignAreas();
}

// ============================================================
// Initialize
// ============================================================

document.addEventListener('DOMContentLoaded', () => {
  const slider = document.getElementById('chart-date-slider');
  if (slider) {
    const now = new Date();
    const start = new Date(now.getFullYear(), 0, 1);
    const diff = now - start;
    const dayOfYear = Math.floor(diff / 86400000);
    slider.value = dayOfYear;
  }

  resetRuntimeState();
  setupEventListeners();
  setupLiveDesign();
  syncUIFromConfig();

  // Set cursor to current time on page load
  const now = new Date();
  cursorHour = now.getHours() + now.getMinutes() / 60;

  renderChart();
  applyCursor();

  loadConfig();
});
</script>
</body>
</html>
