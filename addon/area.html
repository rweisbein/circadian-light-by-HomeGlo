<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Circadian Light - Area</title>
  <style>
    :root {
      --bg: #000;
      --panel: #111;
      --card: #1a1a1a;
      --accent: #feac60;
      --accent-hover: #ffc078;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --muted2: #64748b;
      --line: #334155;
      --success: #22c55e;
      --warning: #f59e0b;
      --danger: #ef4444;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    /* Page header with back button */
    .page-header {
      background: var(--panel);
      border-bottom: 1px solid var(--line);
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .back-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .back-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--accent);
    }

    .back-btn svg {
      width: 20px;
      height: 20px;
    }

    .page-title {
      font-size: 1.1rem;
      font-weight: 600;
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Main content */
    .main {
      max-width: 600px;
      margin: 0 auto;
      padding: 16px;
    }

    /* Header meta (zone link, right-aligned in page header) */
    .page-header-meta {
      display: flex;
      flex-direction: column;
      align-items: flex-end;
      justify-content: center;
      flex-shrink: 0;
    }

    .page-header-meta a {
      color: var(--accent);
      text-decoration: none;
      font-size: 1.1rem;
      white-space: nowrap;
    }

    .page-header-meta a:hover {
      text-decoration: underline;
    }

    .page-header-meta-label {
      font-size: 0.6rem;
      color: var(--text);
      opacity: 0.45;
      white-space: nowrap;
      text-transform: lowercase;
      letter-spacing: 0.03em;
    }

    /* Area state display - with dynamic shading (from modal) */
    .area-state {
      --state-bg: var(--panel);
      --state-fill: 0;
      background: var(--state-bg);
      border-radius: 8px;
      padding: 10px 8px;
      margin-bottom: 12px;
      position: relative;
      overflow: hidden;
    }

    .area-state::before {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.12);
      opacity: var(--state-fill);
      pointer-events: none;
    }

    .area-state-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 8px;
      position: relative;
      z-index: 1;
    }

    .area-state-status-row {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
      margin-top: 6px;
      position: relative;
      z-index: 1;
    }

    .row-slider-section { margin-bottom: 4px; padding: 6px 16px; }
    .row-slider-track { height: 10px; position: relative; cursor: pointer; touch-action: none; border-radius: 5px; overflow: visible; }
    .row-slider-fill { display: none; }
    .row-slider-thumb { position: absolute; top: 50%; transform: translate(-50%, -50%); width: 30px; height: 16px; border-radius: 8px 8px 5px 5px; background: rgba(255,255,255,0.9); box-shadow: 0 1px 4px rgba(0,0,0,0.4); pointer-events: none; transition: left 0.15s; }
    .row-slider-track.dragging .row-slider-thumb { transition: none; }

    .area-state-values {
      font-size: 1.4rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    .area-state-controls {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
      background: rgba(0,0,0,0.5);
      padding: 4px;
      border-radius: 10px;
    }

    .area-state-controls-left {
      display: flex;
      gap: 4px;
      flex-shrink: 0;
      background: rgba(0,0,0,0.5);
      padding: 4px;
      border-radius: 10px;
    }

    /* Toggle switch styles (from modal) */
    .toggle-btn {
      width: 36px;
      height: 36px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(30,30,30,0.9);
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      font-size: 1.1rem;
    }

    .toggle-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: rgba(50,50,50,0.9);
    }

    .toggle-btn.active {
      background: rgba(60,60,60,0.9);
      color: var(--text);
      border-color: var(--accent);
    }

    .toggle-btn:disabled {
      opacity: 0.3;
      cursor: default;
      pointer-events: none;
    }

    .toggle-btn svg {
      width: 18px;
      height: 18px;
    }

    /* Timer status (inline in status row) */
    .timer-status {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 0.8rem;
      margin-left: auto;
    }

    .timer-status:empty {
      display: none;
    }

    .timer-status:not(:empty) {
      background: rgba(0,0,0,0.45);
      padding: 2px 8px;
      border-radius: 10px;
    }

    .timer-motion {
      color: #e2e8f0;
      opacity: 0.9;
    }

    .timer-boost {
      color: #e2e8f0;
      opacity: 0.9;
      margin-left: auto;
    }

    .timer-frozen {
      color: #63b3ed;
      opacity: 1;
    }

    .timer-arrow {
      color: inherit;
      margin: 0 3px;
    }

    .timer-warning {
      color: #e6a817;
      animation: timer-pulse 1s ease-in-out infinite;
    }

    @keyframes timer-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    /* Mini chart container (from modal) */
    #mini-chart {
      width: 100%;
      height: 280px;
      margin: 8px 0;
    }

    /* Adjust sliders (from modal - exact same styling) */
    .adjust-section {
      margin-bottom: 12px;
      -webkit-user-select: none;
      user-select: none;
    }
    .adjust-slider-row {
      display: flex;
      align-items: stretch;
      justify-content: center;
      gap: 36px;
    }
    .slider-group {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .step-buttons { display: flex; flex-direction: column; gap: 8px; align-self: center; }
    .step-btn { width: 32px; height: 32px; border-radius: 6px; border: 1px solid rgba(255,255,255,0.15); background: rgba(30,30,30,0.9); color: var(--muted); cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; padding: 0; }
    .step-btn:hover { border-color: rgba(255,255,255,0.35); background: rgba(50,50,50,0.9); color: var(--text); }
    .step-btn:active { background: rgba(70,70,70,0.9); }
    .step-btn svg { width: 16px; height: 16px; }
    .slider-column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 2px;
    }
    .slider-label {
      font-size: 0.85rem;
      font-weight: 600;
      color: var(--text);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .slider-track {
      position: relative;
      width: 24px;
      height: 160px;
      background: rgba(255,255,255,0.08);
      border-radius: 12px;
      cursor: pointer;
      touch-action: none;
      overflow: visible;
    }
    .slider-fill {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      background: rgba(0,0,0,0.55);
      pointer-events: none;
      transition: height 0.15s ease;
      border-radius: 12px 12px 0 0;
      overflow: hidden;
    }
    .slider-thumb {
      position: absolute;
      left: 50%;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid rgba(255,255,255,0.8);
      box-shadow: 0 1px 6px rgba(0,0,0,0.4);
      transform: translate(-50%, 50%);
      pointer-events: none;
      transition: bottom 0.15s ease, background 0.15s ease;
      z-index: 2;
    }
    .slider-track.dragging .slider-fill,
    .slider-track.dragging .slider-thumb {
      transition: none;
    }
    .slider-extreme {
      font-size: 0.6rem;
      color: var(--muted);
      cursor: pointer;
      padding: 2px 0;
      letter-spacing: 0.02em;
    }
    .slider-extreme:hover {
      color: var(--text);
    }
    /* Top extreme (before track): extra space below for thumb */
    .slider-column > .slider-extreme:nth-child(2) {
      padding-bottom: 18px;
    }
    /* Bottom extreme (after track): extra space above for thumb */
    .slider-track + .slider-extreme {
      padding-top: 18px;
    }
    /* Circadian-off overlay */
    .circadian-off-overlay::after {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.6);
      border-radius: 8px;
      z-index: 10;
      pointer-events: none;
    }
    .enable-circadian-btn {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      z-index: 11;
      pointer-events: auto;
      color: var(--accent);
      border: 1px dashed rgba(254, 172, 96, 0.4);
      background: rgba(0,0,0,0.7);
      padding: 10px 20px;
      border-radius: 8px;
      font-size: 0.9rem;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 6px;
    }

    /* Loading state */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 48px;
      color: var(--muted);
    }

    /* Mobile adjustments */
    @media (max-width: 480px) {
      .adjust-slider-row {
        gap: 20px;
      }
      .slider-track {
        height: 140px;
      }
    }

    /* Wake alarm section */
    .wake-alarm-section { margin: 16px; }
    .wake-alarm-card { background: var(--card); border: 1px solid var(--line); border-radius: 10px; overflow: hidden; transition: border-color 0.2s; }
    .wake-alarm-header { display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px 14px; user-select: none; }
    .wake-alarm-title { font-size: 1.0rem; font-weight: 600; color: var(--text); }
    .wake-alarm-toggle { position: relative; width: 32px; height: 16px; }
    .wake-alarm-toggle input { opacity: 0; width: 0; height: 0; }
    .wake-alarm-toggle .slider { position: absolute; inset: 0; background: var(--line); border-radius: 8px; cursor: pointer; transition: background 0.2s; }
    .wake-alarm-toggle .slider::before { content: ''; position: absolute; left: 3px; top: 3px; width: 10px; height: 10px; border-radius: 50%; background: var(--muted); transition: all 0.2s; }
    .wake-alarm-toggle input:checked + .slider { background: var(--text); }
    .wake-alarm-toggle input:checked + .slider::before { transform: translateX(16px); background: #000; }
    .wake-alarm-body { max-height: 0; opacity: 0; overflow: hidden; transition: max-height 0.3s ease, opacity 0.25s ease; }
    .wake-alarm-card.is-open .wake-alarm-body { max-height: 500px; opacity: 1; }
    .wake-alarm-body-inner { padding: 4px 0 14px 0; }
    .wake-alarm-row { display: flex; align-items: center; justify-content: center; margin-bottom: 10px; }
    .wake-day-bubbles { display: flex; gap: 6px; justify-content: center; margin-bottom: 10px; }
    .wake-day-col { display: flex; flex-direction: column; align-items: center; gap: 2px; }
    .wake-day-bubble { width: 24px; height: 24px; border-radius: 50%; border: 1.5px solid var(--line); background: transparent; color: var(--muted); font-size: 0.55rem; font-weight: 600; cursor: pointer; display: flex; align-items: center; justify-content: center; padding: 0; line-height: 1; transition: all 0.15s; }
    .wake-day-bubble:hover { border-color: var(--text); color: var(--text); }
    .wake-day-bubble.active { background: #eef1f5; border-color: #eef1f5; color: #000; }
    .wake-day-time { font-size: 0.6rem; color: var(--muted2); height: 0.75rem; line-height: 0.75rem; font-variant-numeric: tabular-nums; }
    .wake-time-input { background: var(--panel); color: var(--text); border: 1px solid var(--line); border-radius: 6px; padding: 4px 8px; font-size: 0.85rem; outline: none; }
    .wake-time-input:focus { border-color: var(--accent); }
    .wake-offset-control { display: flex; align-items: center; gap: 6px; }
    .wake-offset-btn { width: 28px; height: 28px; border-radius: 50%; border: 1px solid var(--line); background: transparent; color: var(--text); font-size: 1rem; cursor: pointer; display: flex; align-items: center; justify-content: center; transition: all 0.15s; }
    .wake-offset-btn:hover { border-color: var(--accent); color: var(--accent); }
    .wake-offset-value { font-size: 0.85rem; color: var(--text); min-width: 3em; text-align: center; font-variant-numeric: tabular-nums; }
    .wake-next-alarm { font-size: 1.1rem; color: var(--text); font-weight: 700; white-space: nowrap; font-variant-numeric: tabular-nums; }
    .wake-alarm-chevron { display: inline-block; font-size: 1.1rem; line-height: 1; transition: transform 0.25s; color: var(--muted2); flex-shrink: 0; }
    .wake-alarm-card.is-open .wake-alarm-chevron { transform: rotate(90deg); }
    .tune-light-impact { font-size: 0.75rem; color: var(--muted2); white-space: nowrap; min-width: 2.5em; text-align: right; font-variant-numeric: tabular-nums; }


    /* Scheduled tab: radio column + content */
    .alarm-scheduled-layout { display: flex; gap: 12px; align-items: flex-start; padding: 0 14px; }
    .alarm-mode-radios { display: flex; flex-direction: column; gap: 6px; padding-top: 2px; padding-left: 8px; }
    .alarm-mode-radios label { display: flex; align-items: center; gap: 5px; font-size: 0.82rem; color: var(--muted); cursor: pointer; white-space: nowrap; }
    .alarm-mode-radios input[type="radio"] { accent-color: var(--muted); margin: 0; cursor: pointer; }
    .alarm-scheduled-content { flex: 1; min-width: 0; }

    /* Temporary tab: inline override controls */
    .alarm-temp-content { font-size: 0.85rem; }
    .alarm-temp-content .spo-grid { display: grid; grid-template-columns: 20px 1fr; gap: 0 12px; align-items: center; }
    .alarm-temp-content .spo-radio-row { display: contents; cursor: pointer; }
    .alarm-temp-content .spo-radio-row input[type="radio"] { accent-color: var(--muted); margin: 0; cursor: pointer; }
    .alarm-temp-content .spo-time-cell { text-align: left; padding: 6px 0; font-size: 0.88rem; cursor: pointer; }
    .alarm-temp-content .spo-days { display: block; font-size: 0.65rem; opacity: 0.4; margin-top: 1px; }
    .alarm-temp-content .spo-slider-cell { display: flex; flex-direction: column; align-items: stretch; padding: 10px 0 4px; }
    .alarm-temp-content .spo-slider-cell input[type="range"] { width: 100%; height: 4px; accent-color: var(--muted); }
    .alarm-temp-content .spo-slider-cell .spo-slider-val { font-size: 0.75rem; opacity: 0.6; margin-top: 4px; }
    .alarm-temp-content .spo-info { font-size: 0.85rem; color: var(--text); margin-bottom: 8px; }
    .alarm-temp-apply-row { display: flex; align-items: center; gap: 8px; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--line); font-size: 0.8rem; }
    .alarm-temp-apply-row label { opacity: 0.7; }
    .alarm-temp-apply-row input[type="date"] { background: var(--bg); border: 1px solid var(--line); border-radius: 6px; color: var(--text); padding: 5px 6px; font-size: 0.8rem; height: 30px; box-sizing: border-box; }
    .alarm-temp-apply-row button { padding: 5px 14px; border-radius: 6px; border: 1px solid var(--line); background: var(--bg); color: var(--text); font-size: 0.8rem; height: 30px; box-sizing: border-box; cursor: pointer; }
    .alarm-temp-apply-row button:hover { background: rgba(255,255,255,0.08); }
    .alarm-temp-apply-row button.primary { background: var(--accent); color: #000; border-color: var(--accent); }
    .alarm-temp-apply-row button.primary:hover { opacity: 0.9; }
    .alarm-temp-clear { margin-top: 8px; text-align: center; }
    .alarm-temp-clear button { background: none; border: none; color: #ef4444; font-size: 0.75rem; cursor: pointer; opacity: 0.7; padding: 4px 8px; }
    .alarm-temp-clear button:hover { opacity: 1; }

    /* Temp override popover (area detail page) */
    .area-override-popover { position: fixed; z-index: 200; background: var(--card); border: 1px solid var(--line); border-radius: 10px; padding: 14px; min-width: 240px; box-shadow: 0 8px 24px rgba(0,0,0,0.4); }
    .area-override-popover .spo-grid { display: grid; grid-template-columns: 20px 1fr; gap: 0 12px; align-items: center; }
    .area-override-popover .spo-radio-row { display: contents; cursor: pointer; }
    .area-override-popover .spo-radio-row input[type="radio"] { accent-color: var(--muted); margin: 0; cursor: pointer; }
    .area-override-popover .spo-time-cell { text-align: left; padding: 6px 0; font-size: 0.88rem; cursor: pointer; }
    .area-override-popover .spo-slider-cell { display: flex; flex-direction: column; align-items: stretch; padding: 10px 0 4px; }
    .area-override-popover .spo-slider-cell input[type="range"] { width: 100%; height: 4px; accent-color: var(--muted); }
    .area-override-popover .spo-slider-cell .spo-slider-val { font-size: 0.75rem; opacity: 0.6; margin-top: 4px; }
    .area-override-popover .spo-through-radios input[type="radio"] { accent-color: var(--muted); }
    .area-override-popover .spo-info { font-size: 0.9rem; font-weight: 600; padding: 6px 0; text-align: center; }
    .area-override-popover .schedule-popover-title { font-size: 0.8rem; font-weight: 600; margin-bottom: 8px; color: var(--text); }
    .area-override-popover .schedule-popover-clear { margin-top: 8px; text-align: center; }
    .area-override-popover .schedule-popover-clear button { background: none; border: none; color: #ef4444; font-size: 0.75rem; cursor: pointer; opacity: 0.7; padding: 4px 8px; }
    .area-override-popover .schedule-popover-clear button:hover { opacity: 1; }
    .area-override-popover .schedule-popover-apply-row { display: flex; align-items: center; gap: 8px; margin-top: 10px; padding-top: 10px; border-top: 1px solid var(--line); font-size: 0.8rem; }
    .area-override-popover .schedule-popover-apply-row button { padding: 5px 14px; border-radius: 6px; border: 1px solid var(--line); background: var(--bg); color: var(--text); font-size: 0.8rem; height: 30px; box-sizing: border-box; cursor: pointer; }
    .area-override-popover .schedule-popover-apply-row button:hover { background: rgba(255,255,255,0.08); }
    .area-override-popover .schedule-popover-apply-row button.primary { background: var(--accent); color: #000; border-color: var(--accent); }
    .area-override-popover .schedule-popover-apply-row button.primary:hover { opacity: 0.9; }

    /* Tune section — shared */
    .tune-card { background: var(--card); border: 1px solid var(--line); border-radius: 10px; margin-bottom: 8px; overflow: hidden; font-size: 13px; }
    .tune-card-title { padding: 10px 16px 2px; font-size: 0.75rem; font-weight: 500; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; }
    .tune-section-header { padding: 10px 16px 6px; font-size: 0.75rem; font-weight: 500; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; }
    .tune-save-status { position: fixed; bottom: 24px; right: 24px; padding: 12px 20px; background: var(--success); color: white; border-radius: 8px; font-size: 0.9rem; opacity: 0; transform: translateY(10px); transition: all 0.3s; z-index: 50; }
    .tune-save-status.visible { opacity: 1; transform: translateY(0); }

    .section-action-bar {
      display: flex; justify-content: flex-end; gap: 8px;
      padding: 10px 16px; animation: fadeSlideIn 0.2s ease;
    }
    @keyframes fadeSlideIn {
      from { opacity: 0; transform: translateY(-4px); }
      to { opacity: 1; transform: translateY(0); }
    }
    .section-cancel-btn {
      padding: 6px 16px; border-radius: 6px; border: 1px solid var(--line);
      background: transparent; color: var(--muted); font-size: 0.8rem;
      cursor: pointer; transition: all 0.15s;
    }
    .section-cancel-btn:hover { background: rgba(255,255,255,0.05); color: var(--text); border-color: var(--muted); }
    .section-save-btn {
      padding: 6px 16px; border-radius: 6px; border: 1px solid var(--accent);
      background: var(--accent); color: #000; font-size: 0.8rem; font-weight: 600;
      cursor: pointer; transition: all 0.15s;
    }
    .section-save-btn:hover { opacity: 0.9; }

    /* Room Balance / Solar sliders */
    .tune-control-row { display: grid; grid-template-columns: 1fr auto; align-items: baseline; padding: 8px 14px 2px 22px; gap: 0 12px; }
    .tune-control-left { display: flex; align-items: center; gap: 6px; }
    .tune-control-label { font-size: 0.82rem; color: var(--muted); }
    .tune-control-reset { font-size: 0.7rem; color: var(--muted2); cursor: pointer; opacity: 0; transition: opacity 0.15s; text-transform: uppercase; letter-spacing: 0.03em; }
    .tune-control-row:hover .tune-control-reset { opacity: 1; }
    .tune-control-reset:hover { color: var(--accent); }
    .tune-slider-row { padding: 2px 22px 8px 30px; max-width: 70%; }
    .tune-slider-word { font-size: 0.75rem; color: var(--muted2); white-space: nowrap; display: block; margin-top: 2px; }
    .tune-inline-slider { -webkit-appearance: none; appearance: none; width: 100%; height: 4px; border-radius: 2px; background: rgba(255,255,255,0.12); outline: none; cursor: pointer; min-width: 80px; }
    .tune-inline-slider::-webkit-slider-thumb { -webkit-appearance: none; width: 18px; height: 18px; border-radius: 50%; cursor: pointer; border: 2px solid rgba(255,255,255,0.3); }
    .tune-inline-slider::-moz-range-thumb { width: 18px; height: 18px; border-radius: 50%; cursor: pointer; border: 2px solid rgba(255,255,255,0.3); }
    .tune-inline-slider--light { accent-color: var(--accent); }
    .tune-inline-slider--light::-webkit-slider-thumb { background: var(--accent); }
    .tune-inline-slider--light::-moz-range-thumb { background: var(--accent); }
    .tune-inline-slider--sun { accent-color: #fbbf24; }
    .tune-inline-slider--sun::-webkit-slider-thumb { background: #fbbf24; }
    .tune-inline-slider--sun::-moz-range-thumb { background: #fbbf24; }

    /* Lights card — collapsible like brightness/alarm */
    .tune-lights-header { display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px 14px; user-select: none; }
    .tune-lights-title { font-size: 1.0rem; font-weight: 600; color: var(--text); }
    .tune-lights-chevron { display: inline-block; font-size: 1.1rem; line-height: 1; transition: transform 0.25s; color: var(--muted2); flex-shrink: 0; }
    .tune-lights-card.is-open .tune-lights-chevron { transform: rotate(90deg); }
    .tune-lights-body { max-height: 0; opacity: 0; overflow: hidden; transition: max-height 0.3s ease, opacity 0.25s ease; padding-bottom: 0; }
    .tune-lights-card.is-open .tune-lights-body { max-height: 1000px; opacity: 1; padding-bottom: 8px; }
    .tune-light-item { padding: 0 14px; border-bottom: 1px solid var(--line); }
    .tune-light-item:last-child { border-bottom: none; }
    .tune-light-summary { display: grid; grid-template-columns: auto 1fr auto auto; align-items: baseline; padding: 8px 0; gap: 0 8px; }
    .tune-light-name { font-size: 0.82rem; color: var(--muted); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
    .tune-light-behaviour { font-size: 0.75rem; color: var(--muted); cursor: pointer; white-space: nowrap; text-decoration: underline; text-decoration-style: dotted; text-underline-offset: 2px; }
    .tune-light-behaviour:hover { color: var(--accent); }
    .tune-light-impact { font-size: 0.82rem; color: var(--text); white-space: nowrap; text-align: right; font-variant-numeric: tabular-nums; min-width: 3em; }
    .tune-light-bri { font-size: 0.82rem; font-weight: 600; font-variant-numeric: tabular-nums; white-space: nowrap; text-align: right; min-width: 3em; color: var(--text); }
    .tune-light-expanded { display: flex; align-items: center; gap: 8px; padding: 0 0 10px; padding-left: 14px; flex-wrap: wrap; }
    .tune-light-select { background: var(--panel); color: var(--text); border: 1px solid var(--line); border-radius: 6px; padding: 2px 6px; font-size: 0.75rem; cursor: pointer; outline: none; }
    .tune-light-select:focus { border-color: var(--accent); }
    .tune-light-meta { font-size: 0.7rem; color: var(--muted2); line-height: 1.4; margin-left: 6px; }

    /* Brightness card — alarm-style collapsible */
    .tune-brightness-header { display: flex; align-items: center; gap: 8px; cursor: pointer; padding: 12px 14px; user-select: none; }
    .tune-brightness-title { font-size: 1.0rem; font-weight: 600; color: var(--text); }
    .tune-brightness-chevron { display: inline-block; font-size: 1.1rem; line-height: 1; transition: transform 0.25s; color: var(--muted2); flex-shrink: 0; }
    .tune-brightness-card.is-open .tune-brightness-chevron { transform: rotate(90deg); }
    .tune-brightness-val { margin-left: auto; font-size: 1.1rem; font-weight: 700; color: var(--text); font-variant-numeric: tabular-nums; white-space: nowrap; }
    .tune-brightness-body { max-height: 0; opacity: 0; overflow: hidden; transition: max-height 0.3s ease, opacity 0.25s ease; padding-bottom: 0; }
    .tune-brightness-card.is-open .tune-brightness-body { max-height: 500px; opacity: 1; padding-bottom: 8px; }
    .tune-detail-sub { padding: 0 22px 2px 30px; font-size: 0.7rem; color: var(--muted2); }
    .tune-source-info { font-size: 0.7rem; color: var(--muted2); padding: 2px 22px 0 30px; }
    .tune-refresh-btn { background: none; border: none; color: var(--muted2); font-size: 0.8rem; padding: 0 2px; cursor: pointer; vertical-align: middle; }
    .tune-refresh-btn:hover { color: var(--text); }
    .tune-col-headers { display: grid; grid-template-columns: 1fr auto; padding: 0 14px 2px; gap: 0 12px; }
    .tune-col-header { font-size: 11px; color: var(--muted2); text-align: right; white-space: nowrap; }
    .tune-bk-row { display: grid; grid-template-columns: 1fr auto; align-items: baseline; padding: 5px 14px 5px 22px; gap: 0 12px; }
    .tune-bk-row .tune-bk-label { color: var(--muted); font-size: 0.82rem; }
    .tune-bk-row .tune-bk-total { text-align: right; white-space: nowrap; font-variant-numeric: tabular-nums; min-width: 3em; }
    .tune-bk-row .tune-bk-total.final { font-weight: 600; }
    .tune-control-impact { font-size: 0.82rem; color: var(--text); text-align: right; white-space: nowrap; font-variant-numeric: tabular-nums; min-width: 3em; }
    .tune-group-label { font-size: 0.75rem; font-weight: 500; color: var(--muted); text-transform: uppercase; letter-spacing: 0.5px; padding: 8px 14px 4px; }
    .tune-area-total { padding-top: 8px; border-top: 1px solid rgba(255,255,255,0.06); margin-top: 4px; }
    .tune-area-total .tune-bk-label { font-weight: 600; color: var(--text) !important; }

    /* Custom behaviour dropdown */
    .tune-light-dropdown { position: absolute; z-index: 100; background: var(--panel); border: 1px solid var(--line); border-radius: 8px; box-shadow: 0 4px 16px rgba(0,0,0,0.4); min-width: 220px; overflow: hidden; }
    .tune-light-dropdown-item { padding: 8px 12px; cursor: pointer; border-bottom: 1px solid var(--line); }
    .tune-light-dropdown-item:last-child { border-bottom: none; }
    .tune-light-dropdown-item:hover { background: rgba(255,255,255,0.05); }
    .tune-light-dropdown-item.selected { background: rgba(254,172,96,0.1); }
    .tune-light-dropdown-name { font-size: 0.82rem; color: var(--text); }
    .tune-light-dropdown-meta { font-size: 0.7rem; color: var(--muted2); margin-top: 2px; }

    /* Light brightness column headers */
    .tune-light-col-headers { display: grid; grid-template-columns: auto 1fr auto auto; padding: 4px 14px 2px; gap: 0 8px; font-size: 0.65rem; color: var(--muted2); }
    .tune-light-col-headers span:nth-child(3),
    .tune-light-col-headers span:nth-child(4) { text-align: right; min-width: 3em; }
  </style>
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <script src="./shared.js"></script>
</head>
<body>
  <!-- Page Header -->
  <header class="page-header">
    <button class="back-btn" onclick="goBack()" title="Back">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="15 18 9 12 15 6"/>
      </svg>
    </button>
    <h1 class="page-title" id="page-title">Loading...</h1>
    <div class="page-header-meta" id="page-header-meta">
      <span id="header-meta-rhythm"></span>
      <span class="page-header-meta-label" id="header-meta-zone"></span>
    </div>
  </header>

  <main class="main">

    <div class="area-state" id="area-state">
      <div class="area-state-row">
        <div class="area-state-controls-left" id="controls-left">
          <button class="toggle-btn" id="toggle-circadian" onclick="toggleCircadian()" title="Circadian Light">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="5"/>
              <line x1="12" y1="1" x2="12" y2="3"/>
              <line x1="12" y1="21" x2="12" y2="23"/>
              <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
              <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
              <line x1="1" y1="12" x2="3" y2="12"/>
              <line x1="21" y1="12" x2="23" y2="12"/>
              <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
              <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
            </svg>
          </button>
          <button class="toggle-btn" id="toggle-power" onclick="executeAction('lights_toggle')" title="Power">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18.36 6.64a9 9 0 1 1-12.73 0M12 2v10"/>
            </svg>
          </button>
          <button class="toggle-btn" id="toggle-freeze" onclick="executeAction('freeze_toggle')" title="Freeze">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5"
                 stroke-linecap="round" stroke-linejoin="round">
              <line x1="12" y1="2" x2="12" y2="22"/>
              <line x1="2" y1="12" x2="22" y2="12"/>
              <line x1="5.6" y1="5.6" x2="18.4" y2="18.4"/>
              <line x1="18.4" y1="5.6" x2="5.6" y2="18.4"/>
              <line x1="12" y1="2" x2="9.5" y2="4.5"/><line x1="12" y1="2" x2="14.5" y2="4.5"/>
              <line x1="22" y1="12" x2="19.5" y2="9.5"/><line x1="22" y1="12" x2="19.5" y2="14.5"/>
              <line x1="12" y1="22" x2="14.5" y2="19.5"/><line x1="12" y1="22" x2="9.5" y2="19.5"/>
              <line x1="2" y1="12" x2="4.5" y2="14.5"/><line x1="2" y1="12" x2="4.5" y2="9.5"/>
            </svg>
          </button>
          <button class="toggle-btn" id="toggle-boost" onclick="executeAction('boost')" title="Boost">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
                 stroke-linecap="round" stroke-linejoin="round">
              <polygon points="13 2 3 14 12 14 11 22 21 10 12 10 13 2"/>
            </svg>
          </button>
        </div>
        <div class="area-state-controls" id="controls-area">
          <button class="toggle-btn" id="toggle-full-send" onclick="confirmFullSend()" title="Full Send: push to entire Rhythm Zone">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="5 8 12 2 19 8"/>
              <line x1="4" y1="12" x2="20" y2="12"/>
              <polyline points="5 16 12 22 19 16"/>
            </svg>
          </button>
          <button class="toggle-btn" id="toggle-glo-up" onclick="executeAction('glo_up')" title="GloUp: send area settings to Rhythm Zone">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="5 13 12 6 19 13"/>
              <line x1="4" y1="19" x2="20" y2="19"/>
            </svg>
          </button>
          <button class="toggle-btn" id="toggle-glo-down" onclick="executeAction('glo_down')" title="GloDown: pull Rhythm Zone settings to this area">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <line x1="4" y1="5" x2="20" y2="5"/>
              <polyline points="5 11 12 18 19 11"/>
            </svg>
          </button>
          <button class="toggle-btn" id="toggle-glo-reset" onclick="executeAction('glo_reset')" title="Reset: return to rhythm">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>
          </button>
        </div>
      </div>
      <div class="area-state-status-row">
        <div class="area-state-values" id="state-values"></div>
        <div class="timer-status" id="timer-status"></div>
      </div>
    </div>

    <div class="row-slider-section">
      <div class="row-slider-track" id="area-banner-slider" data-mode="step">
        <div class="row-slider-fill"></div>
        <div class="row-slider-thumb"></div>
      </div>
    </div>

    <div id="circadian-content-wrap" style="position: relative;">
    <div class="adjust-section">
      <div class="adjust-slider-row">
        <div class="slider-group">
          <div class="slider-column">
            <div class="slider-label">Bright</div>
            <div class="slider-extreme" id="bright-max" onclick="executeSetPosition(100,'brightness')">brightest</div>
            <div class="slider-track" data-mode="brightness">
              <div class="slider-fill"></div>
              <div class="slider-thumb"></div>
            </div>
            <div class="slider-extreme" id="bright-min" onclick="executeSetPosition(0,'brightness')">dimmest</div>
          </div>
          <div class="step-buttons">
            <button class="step-btn" onclick="executeAction('bright_up')" title="Brighten">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 15 12 9 18 15"/></svg>
            </button>
            <button class="step-btn" onclick="executeAction('bright_down')" title="Dim">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>
            </button>
          </div>
        </div>
        <div class="slider-group">
          <div class="slider-column">
            <div class="slider-label">Color</div>
            <div class="slider-extreme" id="color-max" onclick="executeSetPosition(100,'color')">coolest</div>
            <div class="slider-track" data-mode="color">
              <div class="slider-fill"></div>
              <div class="slider-thumb"></div>
            </div>
            <div class="slider-extreme" id="color-min" onclick="executeSetPosition(0,'color')">warmest</div>
          </div>
          <div class="step-buttons">
            <button class="step-btn" onclick="executeAction('color_up')" title="Cooler">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 15 12 9 18 15"/></svg>
            </button>
            <button class="step-btn" onclick="executeAction('color_down')" title="Warmer">
              <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="6 9 12 15 18 9"/></svg>
            </button>
          </div>
        </div>
      </div>
    </div>
    <div id="mini-chart"></div>
    <button class="enable-circadian-btn" id="enable-circadian-btn"
            style="display:none;" onclick="executeAction('circadian_on')">
      <svg viewBox="0 0 24 24" width="18" height="18" fill="none" stroke="currentColor" stroke-width="2">
        <circle cx="12" cy="12" r="5"/>
        <line x1="12" y1="1" x2="12" y2="3"/>
        <line x1="12" y1="21" x2="12" y2="23"/>
        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
        <line x1="1" y1="12" x2="3" y2="12"/>
        <line x1="21" y1="12" x2="23" y2="12"/>
        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
      </svg>
      Enable
    </button>
    </div>

    <!-- Alarm Section -->
    <div id="wake-alarm-section" class="wake-alarm-section" style="display:none;">
      <div class="wake-alarm-card">
        <div class="wake-alarm-header" onclick="toggleAlarmBody()">
          <span class="wake-alarm-chevron" id="wake-alarm-chevron">&#x203A;</span>
          <span class="wake-alarm-title">Alarm</span>
          <label class="wake-alarm-toggle" onclick="event.stopPropagation()">
            <input type="checkbox" id="wake-alarm-enabled" onchange="onAlarmFieldChanged()">
            <span class="slider"></span>
          </label>
          <span style="margin-left:auto; display:flex; flex-direction:column; align-items:flex-end;">
            <span class="wake-next-alarm" id="wake-next-alarm"></span>
            <a id="wake-override-clear" href="#" onclick="event.preventDefault(); event.stopPropagation(); clearOverrideFromHeader();" style="display:none; font-size:0.65rem; color:var(--muted2); text-decoration:underline; line-height:1;">clear temp override</a>
          </span>
        </div>
        <div class="wake-alarm-body" id="wake-alarm-body">
         <div class="wake-alarm-body-inner">
          <div class="tune-group-label" style="padding-top:4px; margin-bottom:6px;">Schedule</div>

          <div>
            <div class="alarm-scheduled-layout">
              <div class="alarm-mode-radios">
                <label onclick="setWakeAlarmMode('rhythm')"><input type="radio" name="wake-mode" id="wake-mode-rhythm" checked> Rhythm</label>
                <label onclick="setWakeAlarmMode('custom')"><input type="radio" name="wake-mode" id="wake-mode-custom"> Custom</label>
                <a id="alarm-temp-override-link" href="#" onclick="event.preventDefault(); event.stopPropagation(); openAreaTempOverridePopup(this);" style="display:none; font-size:0.75rem; color:var(--muted2); text-decoration:underline;">create temp override</a>
              </div>
              <div class="alarm-scheduled-content">
                <div class="wake-day-bubbles" id="wake-alarm-days">
                  <div class="wake-day-col"><button class="wake-day-bubble" data-day="0" onclick="toggleWakeDay(this)">Mo</button><span class="wake-day-time" data-daytime="0"></span></div>
                  <div class="wake-day-col"><button class="wake-day-bubble" data-day="1" onclick="toggleWakeDay(this)">Tu</button><span class="wake-day-time" data-daytime="1"></span></div>
                  <div class="wake-day-col"><button class="wake-day-bubble" data-day="2" onclick="toggleWakeDay(this)">We</button><span class="wake-day-time" data-daytime="2"></span></div>
                  <div class="wake-day-col"><button class="wake-day-bubble" data-day="3" onclick="toggleWakeDay(this)">Th</button><span class="wake-day-time" data-daytime="3"></span></div>
                  <div class="wake-day-col"><button class="wake-day-bubble" data-day="4" onclick="toggleWakeDay(this)">Fr</button><span class="wake-day-time" data-daytime="4"></span></div>
                  <div class="wake-day-col"><button class="wake-day-bubble" data-day="5" onclick="toggleWakeDay(this)">Sa</button><span class="wake-day-time" data-daytime="5"></span></div>
                  <div class="wake-day-col"><button class="wake-day-bubble" data-day="6" onclick="toggleWakeDay(this)">Su</button><span class="wake-day-time" data-daytime="6"></span></div>
                </div>
                <div id="wake-rhythm-controls">
                  <div class="wake-alarm-row">
                    <div class="wake-offset-control">
                      <button class="wake-offset-btn" onclick="adjustWakeOffset(-5)">-</button>
                      <span class="wake-offset-value" id="wake-offset-value">0 min</span>
                      <button class="wake-offset-btn" onclick="adjustWakeOffset(5)">+</button>
                    </div>
                  </div>
                </div>
                <div id="wake-custom-controls" style="display:none;">
                  <div class="wake-alarm-row">
                    <input type="time" class="wake-time-input" id="wake-custom-time" value="07:00" onchange="onAlarmFieldChanged()">
                  </div>
                </div>
              </div>
            </div>
          </div>
          <div class="section-action-bar" id="alarm-action-bar" style="display:none;">
            <button class="section-cancel-btn" onclick="cancelAlarmChanges()">Cancel</button>
            <button class="section-save-btn" onclick="saveAlarmChanges()">Save</button>
          </div>
         </div>
        </div>
      </div>
    </div>

    <!-- Tune Section -->
    <div id="area-tune-section" style="display:none; margin: 16px;">
      <div class="tune-card tune-brightness-card" id="tune-brightness-card"></div>
      <div class="tune-card tune-lights-card" id="tune-lights-card"></div>
      <div class="tune-save-status" id="tune-save-status">Saved</div>
    </div>
  </main>

  <script>
    // ============================================================
    // State
    // ============================================================
    let selectedArea = null;
    let areaStatus = {};
    let zoneStates = {};
    let cachedConfig = null;
    let cachedSunTimes = null;
    let cachedGlozones = {};
    let areas = [];
    let refreshInterval = null;
    let tickInterval = null;
    let basePath = '';
    let sliderInteracting = false;
    let tuneSnapshot = null;
    let alarmSnapshot = null;

    // ============================================================
    // Circadian Curve Calculation (from areas.html modal)
    // ============================================================

    const SPEED_TO_SLOPE = [0, 0.4, 0.6, 0.8, 1.0, 1.3, 1.7, 2.3, 3.0, 4.0, 5.5];

    function logistic(x, midpoint, slope, y0, y1) {
      try {
        const expVal = Math.exp(-slope * (x - midpoint));
        return y0 + (y1 - y0) / (1 + expVal);
      } catch {
        return slope * (x - midpoint) > 0 ? y1 : y0;
      }
    }

    function wrap24(x) {
      return ((x % 24) + 24) % 24;
    }

    function inverseMidpoint(x, targetValue, slope, y0, y1) {
      const epsilon = 0.001;
      const clamped = Math.max(y0 + epsilon, Math.min(y1 - epsilon, targetValue));
      const ratio = (clamped - y0) / (y1 - y0);
      try {
        return x + Math.log((1 - ratio) / ratio) / slope;
      } catch (e) {
        return x;
      }
    }

    function computeShiftedMidpoint(targetTimeH48, brightnessPct, slope, bMinNorm, bMaxNorm) {
      if (brightnessPct === 50) return targetTimeH48;
      const targetNorm = bMinNorm + (bMaxNorm - bMinNorm) * (brightnessPct / 100);
      return inverseMidpoint(targetTimeH48, targetNorm, slope, bMinNorm, bMaxNorm);
    }

    function getWindowWeight(hour, windowStart, windowEnd, fadeHrs) {
      const h = wrap24(hour);
      let inWindow = false;
      let distFromStart = 0;
      let distToEnd = 0;

      if (windowStart > windowEnd) {
        inWindow = h >= windowStart || h <= windowEnd;
        if (inWindow) {
          distFromStart = h >= windowStart ? (h - windowStart) : (h + 24 - windowStart);
          distToEnd = h <= windowEnd ? (windowEnd - h) : (windowEnd + 24 - h);
        }
      } else {
        inWindow = h >= windowStart && h <= windowEnd;
        if (inWindow) {
          distFromStart = h - windowStart;
          distToEnd = windowEnd - h;
        }
      }

      if (!inWindow) {
        return { inWindow: false, weight: 0 };
      }

      let weight = 1;
      if (fadeHrs > 0.01) {
        if (distFromStart < fadeHrs) {
          weight = Math.min(weight, distFromStart / fadeHrs);
        }
        if (distToEnd < fadeHrs) {
          weight = Math.min(weight, distToEnd / fadeHrs);
        }
      }

      return { inWindow: true, weight };
    }

    function rad(d) { return d * Math.PI / 180; }

    function solarDeclination(doy) {
      return (23.44 * Math.PI / 180) * Math.sin(2 * Math.PI * (284 + doy) / 365);
    }

    function getSunElevationAtHour(hour, lat, lon) {
      const date = new Date();
      const doy = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
      const decl = solarDeclination(doy);
      const latRad = lat * Math.PI / 180;
      const tz = -date.getTimezoneOffset() / 60;
      const solarNoon = 12 + tz - (lon / 15);
      const hourAngle = (hour - solarNoon) * 15 * Math.PI / 180;
      const sinElev = Math.sin(latRad) * Math.sin(decl) + Math.cos(latRad) * Math.cos(decl) * Math.cos(hourAngle);
      return Math.max(0, Math.asin(sinElev) * 180 / Math.PI);
    }

    function elevationToOutdoorNorm(elevDeg) {
      if (elevDeg <= 0) return 0;
      const FULL_SUN_INTENSITY = 8.4;
      const clearSkyLux = 120000 * Math.sin(elevDeg * Math.PI / 180);
      if (clearSkyLux <= 300) return 0;
      return Math.min(1.0, Math.log2(clearSkyLux / 300) / FULL_SUN_INTENSITY);
    }

    function getSunTimes(lat, lon) {
      const date = new Date();
      const n = Math.floor((date - new Date(date.getFullYear(), 0, 0)) / 86400000);
      const J = n + ((lon < 0 ? 360 + lon : lon) / 360);
      const M = (357.5291 + 0.9856 * J) % 360;
      const C = 1.9148 * Math.sin(rad(M)) + 0.02 * Math.sin(rad(2 * M)) + 0.0003 * Math.sin(rad(3 * M));
      const L = (M + 102.9372 + C + 180) % 360;
      const D = Math.asin(Math.sin(rad(L)) * Math.sin(rad(23.44)));
      const cosH0 = (Math.cos(rad(90.833)) - Math.sin(rad(lat)) * Math.sin(D)) / (Math.cos(rad(lat)) * Math.cos(D));

      if (cosH0 < -1 || cosH0 > 1) {
        const sn = 12 - date.getTimezoneOffset() / 60 - (lon / 15);
        return { sunrise: sn - 6, sunset: sn + 6, solarNoon: sn, solarMid: (sn + 12) % 24 };
      }

      const H0 = Math.acos(cosH0);
      const dl = (2 * H0 * 180 / Math.PI) / 15;
      const tz = -date.getTimezoneOffset() / 60;
      const sn = 12 + tz - (lon / 15);
      return { sunrise: sn - dl / 2, sunset: sn + dl / 2, solarNoon: sn, solarMid: (sn + 12) % 24 };
    }

    function liftMidpointToPhase(midpoint, phaseStart, phaseEnd) {
      const phaseCenter = (phaseStart + phaseEnd) / 2;
      let mid = midpoint;
      while (mid < phaseCenter - 12) mid += 24;
      while (mid > phaseCenter + 12) mid -= 24;
      const margin = 0.01;
      return Math.max(phaseStart + margin, Math.min(phaseEnd - margin, mid));
    }

    function applySolarRule(baseCCT, hour, cfg, sunTimes, colorOverride) {
      if (!sunTimes) return baseCCT;

      let cct = baseCCT;
      const sunrise = sunTimes.sunrise;
      const sunset = sunTimes.sunset;
      const solarMid = sunTimes.solarMid;
      // Warm night — ceiling
      if (cfg.warm_night_enabled) {
        let warmTarget = cfg.warm_night_target;
        if (colorOverride && colorOverride > 0) {
          warmTarget += colorOverride;
        }

        if (cct > warmTarget) {
          const fadeHrs = cfg.warm_night_fade / 60;
          const startOffsetHrs = cfg.warm_night_start / 60;
          const endOffsetHrs = cfg.warm_night_end / 60;
          const mode = cfg.warm_night_mode;

          let windowStart, windowEnd;
          if (mode === 'sunrise') {
            windowStart = wrap24(solarMid);
            windowEnd = wrap24(sunrise + endOffsetHrs);
          } else if (mode === 'sunset') {
            windowStart = wrap24(sunset + startOffsetHrs);
            windowEnd = wrap24(solarMid);
          } else {
            windowStart = wrap24(sunset + startOffsetHrs);
            windowEnd = wrap24(sunrise + endOffsetHrs);
          }

          const { inWindow, weight } = getWindowWeight(hour, windowStart, windowEnd, fadeHrs);
          if (inWindow && weight > 0) {
            cct = cct + (warmTarget - cct) * weight;
          }
        }
      }

      // Daylight color blend — per-hour elevation scaled by current conditions
      const lat = cachedConfig ? cachedConfig.latitude || 35.0 : 35.0;
      const lon = cachedConfig ? cachedConfig.longitude || -78.6 : -78.6;
      const clearSkyAtHour = elevationToOutdoorNorm(getSunElevationAtHour(hour, lat, lon));
      const condMult = sunTimes.conditionMultiplier ?? 1.0;
      const outdoorNorm = clearSkyAtHour * condMult;
      const daylightCct = cfg.daylight_cct || 0;
      const colorSensitivity = cfg.color_sensitivity ?? 1.50;
      if (cfg.daylight_enabled !== false && daylightCct > 0 && outdoorNorm > 0) {
        let blend = Math.min(1.0, outdoorNorm * colorSensitivity);
        // Apply daylight window (start/end offsets) + fade
        const startOffsetHrs = (cfg.daylight_start ?? 60) / 60;
        const endOffsetHrs = (cfg.daylight_end ?? -60) / 60;
        const fadeHrs = (cfg.daylight_fade ?? 60) / 60;
        const ds = wrap24(sunrise + startOffsetHrs);
        const de = wrap24(sunset + endOffsetHrs);
        const dw = getWindowWeight(hour, ds, de, fadeHrs);
        blend *= dw.weight;
        let daylightTarget = daylightCct;
        if (colorOverride && colorOverride < 0) {
          daylightTarget += colorOverride;
        }
        if (daylightTarget > cct && blend > 0) {
          cct += (daylightTarget - cct) * blend;
        }
      }

      return cct;
    }

    // Resolve effective wake/bed times considering schedule override and alt days.
    // Uses phase-aware logic: the graph needs the wake/bed for the current phase
    // and the next phase, which may fall on different weekdays.
    function resolveEffectiveCfg(cfg, zoneName, opts) {
      const resolved = { ...cfg };
      const skipOverride = opts?.skipOverride;

      // 1. Schedule override takes priority (forces specific times for all days)
      // Skipped for graph rendering — overrides affect alarm only, not circadian rhythm
      if (!skipOverride) {
        const zoneData = cachedGlozones?.zones?.[zoneName];
        const override = zoneData?.schedule_override;
        if (override) {
          if (override.mode === 'main') {
            resolved.wake_alt_time = null;
            resolved.bed_alt_time = null;
            return resolved;
          } else if (override.mode === 'alt') {
            if (resolved.wake_alt_time != null) resolved.wake_time = resolved.wake_alt_time;
            if (resolved.bed_alt_time != null) resolved.bed_time = resolved.bed_alt_time;
            resolved.wake_alt_time = null;
            resolved.bed_alt_time = null;
            return resolved;
          } else if (override.mode === 'custom') {
            if (override.custom_wake != null) resolved.wake_time = override.custom_wake;
            if (override.custom_bed != null) resolved.bed_time = override.custom_bed;
            resolved.wake_alt_time = null;
            resolved.bed_alt_time = null;
            return resolved;
          }
        }
      }

      // 2. Phase-aware alt day resolution
      const now = new Date();
      const weekday = now.getDay() === 0 ? 6 : now.getDay() - 1; // JS Sun=0 → Mon=0..Sun=6
      const hour = now.getHours() + now.getMinutes() / 60;
      const ascendStart = resolved.ascend_start ?? 3;
      let descendStart = resolved.descend_start ?? 12;
      if (descendStart <= ascendStart) descendStart += 24;
      const h48 = hour < ascendStart ? hour + 24 : hour;
      const inAscend = h48 >= ascendStart && h48 < descendStart;

      if (inAscend) {
        // Currently ascending: wake = today, bed = today
        const wakeWeekday = weekday;
        const bedWeekday = weekday;
        if (resolved.wake_alt_time != null && resolved.wake_alt_days?.includes(wakeWeekday)) {
          resolved.wake_time = resolved.wake_alt_time;
        }
        if (resolved.bed_alt_time != null && resolved.bed_alt_days?.includes(bedWeekday)) {
          resolved.bed_time = resolved.bed_alt_time;
        }
      } else {
        // Currently descending: bed = today (or yesterday if post-midnight),
        // wake = tomorrow (next ascend phase)
        let bedWeekday = weekday;
        if (hour < ascendStart) {
          bedWeekday = (weekday - 1 + 7) % 7;
        }
        const wakeWeekday = hour < ascendStart ? weekday : (weekday + 1) % 7;
        if (resolved.bed_alt_time != null && resolved.bed_alt_days?.includes(bedWeekday)) {
          resolved.bed_time = resolved.bed_alt_time;
        }
        if (resolved.wake_alt_time != null && resolved.wake_alt_days?.includes(wakeWeekday)) {
          resolved.wake_time = resolved.wake_alt_time;
        }
      }
      return resolved;
    }

    function calcMiniBrightness(hour, cfg, state, currentHour) {
      const tAscend = cfg.ascend_start;
      let tDescend = cfg.descend_start;
      if (tDescend <= tAscend) tDescend += 24;

      const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, cfg.wake_speed))];
      const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, cfg.bed_speed))];
      const bMin = cfg.min_brightness / 100;
      const bMax = cfg.max_brightness / 100;

      const cursorH48 = currentHour < tAscend ? currentHour + 24 : currentHour;
      const cursorInAscend = cursorH48 >= tAscend && cursorH48 < tDescend;

      let wakeMid = cursorInAscend ? (state.brightness_mid ?? cfg.wake_time) : cfg.wake_time;
      let bedMid = !cursorInAscend ? (state.brightness_mid ?? cfg.bed_time) : cfg.bed_time;

      // Apply brightness target shift — shift both midpoints so the full
      // 24h chart is correct regardless of which phase we're currently in.
      if (state.brightness_mid == null) {
        const wakeBrightPct = cfg.wake_brightness || 50;
        if (wakeBrightPct !== 50) {
          let mid48 = wakeMid;
          while (mid48 < tAscend) mid48 += 24;
          while (mid48 > tDescend) mid48 -= 24;
          wakeMid = computeShiftedMidpoint(mid48, wakeBrightPct, kAscend, bMin, bMax) % 24;
        }
        const bedBrightPct = cfg.bed_brightness || 50;
        if (bedBrightPct !== 50) {
          let mid48 = bedMid;
          while (mid48 < tDescend) mid48 += 24;
          while (mid48 > tDescend + 24) mid48 -= 24;
          bedMid = computeShiftedMidpoint(mid48, bedBrightPct, -kDescend, bMin, bMax) % 24;
        }
      }

      const h48 = hour < tAscend ? hour + 24 : hour;
      const inAscend = h48 >= tAscend && h48 < tDescend;

      const mid48 = inAscend
        ? liftMidpointToPhase(wakeMid, tAscend, tDescend)
        : liftMidpointToPhase(bedMid, tDescend, tDescend + 24);

      let value;
      if (inAscend) {
        value = logistic(h48, mid48, kAscend, bMin, bMax);
      } else {
        const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
        value = logistic(hDescend48, mid48, -kDescend, bMin, bMax);
      }

      return Math.max(bMin, Math.min(bMax, value));
    }

    function calcMiniColor(hour, cfg, state, sunTimes, currentHour) {
      const tAscend = cfg.ascend_start;
      let tDescend = cfg.descend_start;
      if (tDescend <= tAscend) tDescend += 24;

      const kAscend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, cfg.wake_speed))];
      const kDescend = SPEED_TO_SLOPE[Math.max(1, Math.min(10, cfg.bed_speed))];
      const bMin = cfg.min_brightness / 100;
      const bMax = cfg.max_brightness / 100;
      const cLow = cfg.min_color_temp;
      const cHigh = cfg.max_color_temp;

      const cursorH48 = currentHour < tAscend ? currentHour + 24 : currentHour;
      const cursorInAscend = cursorH48 >= tAscend && cursorH48 < tDescend;

      let colorWakeMid = cursorInAscend ? (state.color_mid ?? cfg.wake_time) : cfg.wake_time;
      let colorBedMid = !cursorInAscend ? (state.color_mid ?? cfg.bed_time) : cfg.bed_time;

      // Apply brightness target shift for color — shift both midpoints
      // so the full 24h chart is correct regardless of current phase.
      if (state.color_mid == null) {
        const wakeBrightPct = cfg.wake_brightness || 50;
        if (wakeBrightPct !== 50) {
          let cMid48 = colorWakeMid;
          while (cMid48 < tAscend) cMid48 += 24;
          while (cMid48 > tDescend) cMid48 -= 24;
          colorWakeMid = computeShiftedMidpoint(cMid48, wakeBrightPct, kAscend, bMin, bMax) % 24;
        }
        const bedBrightPct = cfg.bed_brightness || 50;
        if (bedBrightPct !== 50) {
          let cMid48 = colorBedMid;
          while (cMid48 < tDescend) cMid48 += 24;
          while (cMid48 > tDescend + 24) cMid48 -= 24;
          colorBedMid = computeShiftedMidpoint(cMid48, bedBrightPct, -kDescend, bMin, bMax) % 24;
        }
      }

      const h48 = hour < tAscend ? hour + 24 : hour;
      const inAscend = h48 >= tAscend && h48 < tDescend;

      const mid48 = inAscend
        ? liftMidpointToPhase(colorWakeMid, tAscend, tDescend)
        : liftMidpointToPhase(colorBedMid, tDescend, tDescend + 24);

      let normalized;
      if (inAscend) {
        normalized = logistic(h48, mid48, kAscend, 0, 1);
      } else {
        const hDescend48 = (h48 < tDescend) ? h48 + 24 : h48;
        normalized = logistic(hDescend48, mid48, -kDescend, 0, 1);
      }
      normalized = Math.max(0, Math.min(1, normalized));

      let cct = cLow + (cHigh - cLow) * normalized;
      cct = applySolarRule(cct, hour, cfg, sunTimes, state.color_override);

      return cct;
    }

    function calcMiniCurveData(cfg, state, sunTimes, currentHour) {
      const numSamples = 240;
      const hours = [];
      const brightnessPct = [];
      const cct = [];

      for (let i = 0; i < numSamples; i++) {
        const h = (i / numSamples) * 24;
        hours.push(h);
        brightnessPct.push(calcMiniBrightness(h, cfg, state, currentHour) * 100);
        cct.push(calcMiniColor(h, cfg, state, sunTimes, currentHour));
      }

      return { hours, brightnessPct, cct };
    }

    // ============================================================
    // Mini Circadian Graph — Rendering (from areas.html modal)
    // ============================================================

    function formatHourLabel(h) {
      const h24 = ((h % 24) + 24) % 24;
      let hr = Math.floor(h24);
      let min = Math.round((h24 - hr) * 60);
      if (min === 60) { min = 0; hr = (hr + 1) % 24; }
      const suffix = hr < 12 ? 'a' : 'p';
      const hr12 = hr === 0 ? 12 : (hr > 12 ? hr - 12 : hr);
      return min === 0 ? `${hr12}${suffix}` : `${hr12}:${min.toString().padStart(2, '0')}${suffix}`;
    }

    function formatCountdown(isoTimestamp) {
      if (!isoTimestamp) return null;
      const expires = new Date(isoTimestamp);
      if (isNaN(expires.getTime())) return null;
      const now = new Date();
      const diffMs = expires - now;
      if (diffMs <= 0) return null;
      const totalSec = Math.floor(diffMs / 1000);
      if (totalSec < 60) return `${totalSec}s`;
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      if (min < 60) return sec > 0 ? `${min}m ${sec}s` : `${min}m`;
      const hr = Math.floor(min / 60);
      const remMin = min % 60;
      return remMin > 0 ? `${hr}h ${remMin}m` : `${hr}h`;
    }

    function renderMiniChart(cfg, state, sunTimes, currentHour, isActive) {
      if (!cfg || !sunTimes) return;

      const data = calcMiniCurveData(cfg, state, sunTimes, currentHour);
      const { hours, brightnessPct, cct } = data;

      const traces = [];

      // Color-gradient brightness curve (filled + line segments)
      const step = 2;
      for (let i = step; i < hours.length; i += step) {
        const color = cctToRGB(cct[i]);
        const fillColor = colorWithAlpha(color, 0.5);
        const x0 = hours[i - step];
        const x1 = hours[i];
        const y0 = brightnessPct[i - step];
        const y1 = brightnessPct[i];

        // Filled area under curve
        traces.push({
          type: 'scatter', mode: 'lines',
          x: [x0, x1, x1, x0], y: [y0, y1, 0, 0],
          fill: 'toself', line: { width: 0 }, fillcolor: fillColor,
          hoverinfo: 'skip', showlegend: false
        });

        // Colored line segment
        traces.push({
          type: 'scatter', mode: 'lines',
          x: [x0, x1], y: [y0, y1],
          line: { width: 3, color },
          hoverinfo: 'skip', showlegend: false
        });
      }

      // Hover trace — CCT-colored tooltips
      const hoverDetails = brightnessPct.map((v, i) =>
        `${formatHourLabel(hours[i])} • ${Math.round(v)}% • ${Math.round(cct[i])}K`
      );
      const hoverBgColors = cct.map(k => colorWithAlpha(cctToRGB(k), 0.92));
      const hoverTextColors = cct.map(k => readableTextColor(cctToRGB(k)));
      const hoverBorderColors = cct.map(k => colorWithAlpha(cctToRGB(k), 0.65));

      traces.push({
        type: 'scatter', mode: 'lines',
        x: hours, y: brightnessPct,
        line: { width: 0 }, showlegend: false,
        text: hoverDetails,
        hovertemplate: '%{text}<extra></extra>',
        hoverlabel: {
          bgcolor: hoverBgColors,
          bordercolor: hoverBorderColors,
          font: { color: hoverTextColors, size: 13 }
        }
      });

      // Live position marker (large size, outline color depends on active state)
      const markerBri = calcMiniBrightness(currentHour, cfg, state, currentHour) * 100;
      const markerCCT = calcMiniColor(currentHour, cfg, state, sunTimes, currentHour);
      const markerColor = cctToRGB(markerCCT);
      const markerOutline = isActive ? '#fff' : '#000';

      traces.push({
        x: [currentHour], y: [markerBri],
        mode: 'markers',
        marker: { size: 22, color: markerColor, line: { width: 3, color: markerOutline } },
        hoverinfo: 'skip', showlegend: false
      });

      // Shapes and annotations
      const shapes = [];
      const annotations = [];

      // Wake/bed vertical dashed lines
      const wakeTime = wrap24(cfg.wake_time);
      const bedTime = wrap24(cfg.bed_time);

      shapes.push({
        type: 'line', xref: 'x', yref: 'paper',
        x0: wakeTime, x1: wakeTime, y0: -0.15, y1: 1,
        line: { color: 'rgba(92, 179, 255, 0.35)', width: 1.5, dash: 'dot' }
      });
      shapes.push({
        type: 'line', xref: 'x', yref: 'paper',
        x0: bedTime, x1: bedTime, y0: -0.15, y1: 1,
        line: { color: 'rgba(255, 230, 128, 0.35)', width: 1.5, dash: 'dot' }
      });

      // Sunrise/sunset vertical ticks
      const sunrise = sunTimes.sunrise;
      const sunset = sunTimes.sunset;
      const sunTickStyle = { color: 'rgba(215,215,215,0.4)', width: 1, dash: 'dot' };
      if (Number.isFinite(sunrise)) {
        shapes.push({
          type: 'line', xref: 'x', yref: 'paper',
          x0: sunrise, x1: sunrise, y0: -0.22, y1: 0,
          line: sunTickStyle
        });
      }
      if (Number.isFinite(sunset)) {
        shapes.push({
          type: 'line', xref: 'x', yref: 'paper',
          x0: sunset, x1: sunset, y0: -0.22, y1: 0,
          line: sunTickStyle
        });
      }

      // Wake/bed labels
      annotations.push({
        x: wakeTime, y: -0.18, xref: 'x', yref: 'paper',
        text: 'wake', showarrow: false,
        font: { size: 10, color: '#5cb3ff' },
        hovertext: formatHourLabel(wakeTime),
        hoverlabel: { bgcolor: '#7fc7ff', bordercolor: '#7fc7ff', font: { color: '#000', size: 12 } }
      });
      annotations.push({
        x: bedTime, y: -0.18, xref: 'x', yref: 'paper',
        text: 'bed', showarrow: false,
        font: { size: 10, color: '#ffe680' },
        hovertext: formatHourLabel(bedTime),
        hoverlabel: { bgcolor: '#ffe680', bordercolor: '#ffe680', font: { color: '#000', size: 12 } }
      });

      // Sunrise/sunset labels
      if (Number.isFinite(sunrise)) {
        annotations.push({
          x: sunrise, y: -0.25, xref: 'x', yref: 'paper',
          text: 'sunrise', showarrow: false,
          font: { size: 9, color: 'rgba(215,215,215,0.6)' },
          hovertext: formatHourLabel(sunrise),
          hoverlabel: { bgcolor: '#3a3a3a', bordercolor: '#3a3a3a', font: { color: '#fff', size: 12 } }
        });
      }
      if (Number.isFinite(sunset)) {
        annotations.push({
          x: sunset, y: -0.25, xref: 'x', yref: 'paper',
          text: 'sunset', showarrow: false,
          font: { size: 9, color: 'rgba(215,215,215,0.6)' },
          hovertext: formatHourLabel(sunset),
          hoverlabel: { bgcolor: '#3a3a3a', bordercolor: '#3a3a3a', font: { color: '#fff', size: 12 } }
        });
      }

      // Cursor vertical line
      const isFrozen = state && state.frozen_at != null;
      const cursorHour = currentHour;
      const cursorLineStyle = { color: '#fdfdfd', width: 2, dash: 'dot' };
      const gap = 8;
      const lowerEnd = Math.max(0, markerBri - gap);
      const upperStart = Math.min(110, markerBri + gap);

      shapes.push({
        type: 'line', xref: 'x', yref: 'y',
        x0: cursorHour, x1: cursorHour, y0: 0, y1: lowerEnd,
        line: cursorLineStyle, layer: 'above'
      });
      shapes.push({
        type: 'line', xref: 'x', yref: 'y',
        x0: cursorHour, x1: cursorHour, y0: upperStart, y1: 110,
        line: cursorLineStyle, layer: 'above'
      });
      shapes.push({
        type: 'line', xref: 'x', yref: 'paper',
        x0: cursorHour, x1: cursorHour, y0: -0.26, y1: 0,
        line: cursorLineStyle, layer: 'above'
      });

      // Cursor label
      const cursorTimeStr = formatHourLabel(cursorHour);
      const cursorLabel = isFrozen ? 'frozen' : 'now';
      const cursorColor = isFrozen ? '#63b3ed' : '#fdfdfd';
      annotations.push({
        x: cursorHour, y: -0.38, xref: 'x', yref: 'paper',
        text: `${cursorLabel}<br>${cursorTimeStr}`, showarrow: false,
        font: { size: 10, color: cursorColor },
        align: 'center'
      });

      const layout = {
        paper_bgcolor: '#0a0a0a',
        plot_bgcolor: '#0a0a0a',
        margin: { t: 24, r: 12, l: 36, b: 85 },
        hovermode: 'closest',
        xaxis: {
          range: [0, 24],
          dtick: 3,
          tickvals: [0, 3, 6, 9, 12, 15, 18, 21, 24],
          ticktext: ['12a', '3a', '6a', '9a', '12p', '3p', '6p', '9p', '12a'],
          gridcolor: 'rgba(80,100,130,0.22)',
          tickfont: { color: '#c8c8c8', size: 10 },
          ticklen: 3,
          tickcolor: 'rgba(160,190,220,0.2)'
        },
        yaxis: {
          range: [0, 110],
          gridcolor: 'rgba(80,100,130,0.22)',
          tickfont: { color: '#c8c8c8', size: 10 },
          ticklen: 3,
          title: '',
          showticklabels: true,
          dtick: 25
        },
        shapes,
        annotations,
        showlegend: false
      };

      Plotly.react('mini-chart', traces, layout, {
        displayModeBar: false,
        responsive: true
      });
    }

    // ============================================================
    // Slider Functions (from areas.html modal)
    // ============================================================

    function getSliderCfgAndState() {
      if (selectedArea) {
        const status = areaStatus[selectedArea.area_id] || {};
        if (!cachedConfig || !cachedSunTimes) return null;
        const zoneName = status.zone_name;
        const zs = zoneName ? (zoneStates[zoneName] || {}) : {};
        const zoneData = zoneName ? (cachedGlozones?.zones?.[zoneName] || {}) : {};
        let cfg = { ...cachedConfig, ...zoneData };
        cfg = resolveEffectiveCfg(cfg, zoneName, { skipOverride: true });
        const areaState = {
          brightness_mid: status.brightness_mid ?? null,
          color_mid: status.color_mid ?? null,
          color_override: status.color_override ?? null,
          frozen_at: status.frozen_at ?? null
        };
        let currentHour;
        if (status.frozen && status.frozen_at != null) {
          currentHour = status.frozen_at;
        } else {
          const now = new Date();
          currentHour = now.getHours() + now.getMinutes() / 60;
        }
        return { cfg, areaState, currentHour };
      }
      return null;
    }

    function updateAllSliders() {
      const ctx = getSliderCfgAndState();
      if (!ctx) return;
      const { cfg, areaState, currentHour } = ctx;
      const currentBri = calcMiniBrightness(currentHour, cfg, areaState, currentHour) * 100;
      const currentCCT = calcMiniColor(currentHour, cfg, areaState, cachedSunTimes, currentHour);
      const bMin = cfg.min_brightness, bMax = cfg.max_brightness;
      const cMin = cfg.min_color_temp, cMax = cfg.max_color_temp;

      const briFrac = bMax > bMin ? Math.max(0, Math.min(100, (currentBri - bMin) / (bMax - bMin) * 100)) : 50;
      const cctFrac = cMax > cMin ? Math.max(0, Math.min(100, (currentCCT - cMin) / (cMax - cMin) * 100)) : 50;
      const gloFrac = briFrac;

      const effRange = getEffectiveColorRange(cfg, currentHour, areaState.color_override);

      document.querySelectorAll('.slider-track').forEach(track => {
        if (track.classList.contains('dragging')) return;
        const mode = track.dataset.mode;
        track.style.background = buildTrackGradient(mode, cfg, currentBri, currentCCT, effRange);
        const pct = mode === 'step' ? gloFrac : mode === 'brightness' ? briFrac : cctFrac;
        applyOneSlider(track, pct, currentBri, currentCCT, mode);
      });

      // Banner slider — compute color delta (actual CCT vs base curve CCT at this position)
      const baseCCT = effRange.effMin + (effRange.effMax - effRange.effMin) * gloFrac / 100;
      const colorDelta = currentCCT - baseCCT;
      updateBannerSlider(gloFrac, cfg, effRange, colorDelta);
    }

    function buildHorizontalGradient(cfg, effectiveColorRange, colorDelta) {
      const bMin = cfg.min_brightness, bMax = cfg.max_brightness;
      const cMin = cfg.min_color_temp, cMax = cfg.max_color_temp;
      const effMin = effectiveColorRange ? effectiveColorRange.effMin : cMin;
      const effMax = effectiveColorRange ? effectiveColorRange.effMax : cMax;
      const d = colorDelta || 0;
      const stops = [];
      const n = 6;
      for (let i = 0; i <= n; i++) {
        const frac = i / n;
        const b = bMin + (bMax - bMin) * frac;
        const k = (effMin + d) + ((effMax + d) - (effMin + d)) * frac;
        const color = tintColorByBrightness(cctToRGB(k), b);
        stops.push(color + ' ' + Math.round(frac * 100) + '%');
      }
      return 'linear-gradient(to right, ' + stops.join(', ') + ')';
    }

    function updateBannerSlider(pct, cfg, effRange, colorDelta) {
      const banner = document.getElementById('area-banner-slider');
      if (!banner || banner.classList.contains('dragging')) return;
      if (cfg && effRange) {
        banner.style.background = buildHorizontalGradient(cfg, effRange, colorDelta);
      }
      const thumb = banner.querySelector('.row-slider-thumb');
      if (thumb) {
        thumb.style.left = pct + '%';
      }
    }

    function getEffectiveColorRange(cfg, currentHour, colorOverride) {
      // Compute the effective CCT range after solar rules clamp at the current hour
      const cMin = cfg.min_color_temp, cMax = cfg.max_color_temp;
      if (!cachedSunTimes) return { effMin: cMin, effMax: cMax };
      const effMin = applySolarRule(cMin, currentHour, cfg, cachedSunTimes, colorOverride);
      const effMax = applySolarRule(cMax, currentHour, cfg, cachedSunTimes, colorOverride);
      return { effMin, effMax };
    }

    function buildTrackGradient(mode, cfg, currentBri, currentCCT, effectiveColorRange) {
      const bMin = cfg.min_brightness, bMax = cfg.max_brightness;
      const cMin = cfg.min_color_temp, cMax = cfg.max_color_temp;
      const stops = [];
      const n = 6;
      for (let i = 0; i <= n; i++) {
        const frac = i / n;
        let color;
        if (mode === 'color') {
          const k = cMin + (cMax - cMin) * frac;
          color = cctToRGB(k);
        } else if (mode === 'brightness') {
          const b = bMin + (bMax - bMin) * frac;
          color = tintColorByBrightness(cctToRGB(currentCCT), b);
        } else {
          // Step/circadian slider: use effective (solar-clamped) color range
          const b = bMin + (bMax - bMin) * frac;
          const effMin = effectiveColorRange ? effectiveColorRange.effMin : cMin;
          const effMax = effectiveColorRange ? effectiveColorRange.effMax : cMax;
          const k = effMin + (effMax - effMin) * frac;
          color = tintColorByBrightness(cctToRGB(k), b);
        }
        stops.push(color + ' ' + Math.round(frac * 100) + '%');
      }
      return 'linear-gradient(to top, ' + stops.join(', ') + ')';
    }

    function applyOneSlider(track, pct, bri, cct, mode) {
      const fill = track.querySelector('.slider-fill');
      const thumb = track.querySelector('.slider-thumb');
      if (!fill || !thumb) return;
      // Dim overlay: covers from top down to thumb position
      fill.style.height = (100 - pct) + '%';
      // Thumb position and color
      thumb.style.bottom = pct + '%';
      const color = cctToRGB(cct);
      const tinted = mode === 'color' ? color : tintColorByBrightness(color, bri);
      thumb.style.background = tinted;
      thumb.style.borderColor = color;
    }

    function getPositionFromPointer(track, e) {
      const rect = track.getBoundingClientRect();
      const y = Math.max(0, Math.min(1, (rect.bottom - e.clientY) / rect.height));
      return y * 100;
    }

    function initSliderHandlers() {
      document.querySelectorAll('.slider-track').forEach(track => {
        let lastPos = null;
        const mode = track.dataset.mode;

        function onDown(e) {
          e.preventDefault();
          sliderInteracting = true;
          track.classList.add('dragging');
          track.setPointerCapture(e.pointerId);
          lastPos = getPositionFromPointer(track, e);
          previewSlider(track, lastPos);
        }
        function onMove(e) {
          if (!track.classList.contains('dragging')) return;
          e.preventDefault();
          lastPos = getPositionFromPointer(track, e);
          previewSlider(track, lastPos);
        }
        function onUp(e) {
          if (!track.classList.contains('dragging')) return;
          e.preventDefault();
          track.classList.remove('dragging');
          sliderInteracting = false;
          if (lastPos !== null) {
            executeSetPosition(Math.round(lastPos), mode);
          }
        }

        track.addEventListener('pointerdown', onDown);
        track.addEventListener('pointermove', onMove);
        track.addEventListener('pointerup', onUp);
        track.addEventListener('pointercancel', onUp);
      });

      // Banner slider (horizontal)
      const banner = document.getElementById('area-banner-slider');
      if (banner) {
        let bannerLastPos = null;
        function bannerPos(e) {
          const rect = banner.getBoundingClientRect();
          return Math.max(0, Math.min(100, (e.clientX - rect.left) / rect.width * 100));
        }
        banner.addEventListener('pointerdown', (e) => {
          e.preventDefault();
          sliderInteracting = true;
          banner.classList.add('dragging');
          banner.setPointerCapture(e.pointerId);
          bannerLastPos = bannerPos(e);
          const thumb = banner.querySelector('.row-slider-thumb');
          if (thumb) thumb.style.left = bannerLastPos + '%';
          previewSlider(banner, bannerLastPos);
        });
        banner.addEventListener('pointermove', (e) => {
          if (!banner.classList.contains('dragging')) return;
          e.preventDefault();
          bannerLastPos = bannerPos(e);
          const thumb = banner.querySelector('.row-slider-thumb');
          if (thumb) thumb.style.left = bannerLastPos + '%';
          previewSlider(banner, bannerLastPos);
        });
        function bannerUp(e) {
          if (!banner.classList.contains('dragging')) return;
          e.preventDefault();
          banner.classList.remove('dragging');
          sliderInteracting = false;
          if (bannerLastPos !== null) {
            executeSetPosition(Math.round(bannerLastPos), 'step');
          }
        }
        banner.addEventListener('pointerup', bannerUp);
        banner.addEventListener('pointercancel', bannerUp);
      }
    }

    function previewSlider(track, position) {
      const dragMode = track.dataset.mode;
      const ctx = getSliderCfgAndState();
      if (!ctx) return;
      const { cfg, areaState } = ctx;
      const now = new Date();
      const currentHour = now.getHours() + now.getMinutes() / 60;

      const bMin = cfg.min_brightness, bMax = cfg.max_brightness;
      const cMin = cfg.min_color_temp, cMax = cfg.max_color_temp;
      const currentBri = calcMiniBrightness(currentHour, cfg, areaState, currentHour) * 100;
      const currentCCT = calcMiniColor(currentHour, cfg, areaState, cachedSunTimes, currentHour);

      let previewBri, previewCCT;
      if (dragMode === 'brightness') {
        previewBri = bMin + (bMax - bMin) * position / 100;
        previewCCT = currentCCT;
      } else if (dragMode === 'color') {
        previewBri = currentBri;
        previewCCT = cMin + (cMax - cMin) * position / 100;
      } else {
        previewBri = bMin + (bMax - bMin) * position / 100;
        previewCCT = cMin + (cMax - cMin) * position / 100;
      }

      const briFrac = bMax > bMin ? Math.max(0, Math.min(100, (previewBri - bMin) / (bMax - bMin) * 100)) : 50;
      const cctFrac = cMax > cMin ? Math.max(0, Math.min(100, (previewCCT - cMin) / (cMax - cMin) * 100)) : 50;
      const gloFrac = briFrac;

      const effRange = getEffectiveColorRange(cfg, currentHour, areaState.color_override);

      document.querySelectorAll('.slider-track').forEach(t => {
        const m = t.dataset.mode;
        t.style.background = buildTrackGradient(m, cfg, previewBri, previewCCT, effRange);
        const pct = m === 'step' ? gloFrac : m === 'brightness' ? briFrac : cctFrac;
        applyOneSlider(t, pct, previewBri, previewCCT, m);
      });

      // Also update banner slider — compute color delta from preview
      const previewBaseCCT = effRange.effMin + (effRange.effMax - effRange.effMin) * gloFrac / 100;
      const previewColorDelta = previewCCT - previewBaseCCT;
      updateBannerSlider(gloFrac, cfg, effRange, previewColorDelta);
    }

    // ============================================================
    // Initialization
    // ============================================================
    document.addEventListener('DOMContentLoaded', async () => {
      // Compute base path for API calls (handles ingress prefix)
      const path = window.location.pathname;
      const areaMatch = path.match(/^(.*)\/area\/[^/]+\/?$/);
      if (areaMatch) {
        basePath = areaMatch[1] || '';
      }

      // Get selected area from injected data
      const data = window.circadianData || {};
      const selectedAreaId = data.selectedAreaId;
      cachedConfig = data.config;

      // Compute sun times client-side from config lat/lon
      if (cachedConfig) {
        const lat = cachedConfig.latitude || 35.0;
        const lon = cachedConfig.longitude || -78.6;
        cachedSunTimes = getSunTimes(lat, lon);
      }

      // Fetch initial data
      await loadInitialData();

      // Determine if area page
      if (selectedAreaId) {
        setupAreaPage(selectedAreaId);
      } else {
        document.getElementById('page-title').textContent = 'Not Found';
      }

      // Start refresh intervals
      startRefresh();
      initSliderHandlers();

    });

    async function loadInitialData() {
      try {
        const [statusRes, zsRes, areasRes, gzRes] = await Promise.all([
          fetch(basePath + '/api/area-status'),
          fetch(basePath + '/api/zone-states'),
          fetch(basePath + '/api/areas'),
          fetch(basePath + '/api/glozones')
        ]);
        if (gzRes.ok) cachedGlozones = await gzRes.json();
        if (statusRes.ok) areaStatus = await statusRes.json();
        // Compute condition multiplier: ratio of actual outdoor reading to clear-sky model
        if (cachedSunTimes && cachedConfig) {
          const firstStatus = Object.values(areaStatus)[0];
          if (firstStatus) {
            const actualNorm = firstStatus.outdoor_normalized ?? firstStatus.sun_factor ?? 0;
            cachedSunTimes.outdoorNormalized = actualNorm;
            // Derive condition multiplier from current reading vs clear-sky at current hour
            const now = new Date();
            const currentHour = now.getHours() + now.getMinutes() / 60;
            const lat = cachedConfig.latitude || 35.0;
            const lon = cachedConfig.longitude || -78.6;
            const clearSkyNow = elevationToOutdoorNorm(getSunElevationAtHour(currentHour, lat, lon));
            cachedSunTimes.conditionMultiplier = clearSkyNow > 0.01 ? Math.min(1.0, actualNorm / clearSkyNow) : 1.0;
          }
        }
        if (zsRes.ok) {
          const zs = await zsRes.json();
          zoneStates = zs.zone_states || {};
        }
        if (areasRes.ok) areas = await areasRes.json();
      } catch (err) {
        console.error('Error loading initial data:', err);
      }
    }

    function setupAreaPage(areaId) {
      const area = areas.find(a => a.area_id === areaId);
      const status = areaStatus[areaId] || {};

      if (!area) {
        document.getElementById('page-title').textContent = 'Area not found';
        return;
      }

      selectedArea = {
        ...area,
        area_id: areaId,
        is_on: status.is_on || false,
        brightness: status.curve_brightness || status.brightness || 0,
        kelvin: status.kelvin || 4000,
        frozen: status.frozen || false,
        boosted: status.boosted || false,
        zone_name: status.zone_name || null,
        preset_name: status.preset_name || null,
        is_circadian: status.is_circadian !== false,
        boost_brightness: status.boost_brightness || null,
        boost_expires_at: status.boost_expires_at || null,
        boost_started_from_off: status.boost_started_from_off || false,
        is_motion_coupled: status.is_motion_coupled || false,
        motion_expires_at: status.motion_expires_at || null,
        motion_warning_active: status.motion_warning_active || false
      };

      document.getElementById('page-title').textContent = 'Area: ' + area.name;

      // Show area controls
      document.getElementById('controls-left').style.display = 'flex';
      document.getElementById('controls-area').style.display = 'flex';

      updateContent();
      setTimeout(() => {
        renderMiniChartForArea(areaId);
        updateAllSliders();
      }, 50);
      loadTuneSection();
      loadWakeAlarmSettings();
    }


    function getRefreshInterval() {
      if (cachedConfig) {
        const val = cachedConfig.home_refresh_interval;
        if (val && val >= 2 && val <= 60) return val;
      }
      return 10;
    }

    function startRefresh() {
      tickInterval = setInterval(updateTimerStatus, 1000);
      const intervalMs = getRefreshInterval() * 1000;
      refreshInterval = setInterval(async () => {
        if (sliderInteracting) return;
        try {
          if (selectedArea) {
            const res = await fetch(basePath + `/api/area-status?area_id=${encodeURIComponent(selectedArea.area_id)}`);
            if (res.ok) {
              const singleStatus = await res.json();
              Object.assign(areaStatus, singleStatus);

              // Update cachedSunTimes with outdoor_normalized and condition multiplier
              const ls0 = singleStatus[selectedArea.area_id] || {};
              if (cachedSunTimes && cachedConfig) {
                const actualNorm = ls0.outdoor_normalized ?? ls0.sun_factor ?? 0;
                cachedSunTimes.outdoorNormalized = actualNorm;
                const now = new Date();
                const currentHour = now.getHours() + now.getMinutes() / 60;
                const lat = cachedConfig.latitude || 35.0;
                const lon = cachedConfig.longitude || -78.6;
                const clearSkyNow = elevationToOutdoorNorm(getSunElevationAtHour(currentHour, lat, lon));
                cachedSunTimes.conditionMultiplier = clearSkyNow > 0.01 ? Math.min(1.0, actualNorm / clearSkyNow) : 1.0;
              }

              // Update tuneState with fresh server data
              if (tuneState.initialized) {
                const ls = ls0;
                const _as = areaStatus[selectedArea.area_id] || {};
                tuneState.baseBri = _as.curve_brightness || _as.brightness || 50;
                tuneState.baseKelvin = ls.base_kelvin ?? ((areaStatus[selectedArea.area_id] || {}).kelvin || 4000);
                tuneState.sunElev = ls.sun_elevation ?? 0;
                tuneState.outdoorNormalized = ls.outdoor_normalized ?? ls.sun_factor ?? 0.0;
                tuneState.outdoorSource = ls.outdoor_source ?? 'none';
                tuneState.outdoorSourceEntity = ls.outdoor_source_entity ?? null;
                tuneState.outdoorLastUpdate = ls.outdoor_last_update ?? null;
                tuneState.brightnessSensitivity = ls.brightness_sensitivity ?? 5.0;
                tuneState.luxSmoothed = ls.lux_smoothed ?? null;
                tuneState.luxCeiling = ls.lux_ceiling ?? null;
                tuneState.luxFloor = ls.lux_floor ?? null;
                tuneState.weatherCondition = ls.weather_condition ?? null;
                tuneState.solarBreakdown = ls.solar_breakdown ?? null;
                tuneState.boosted = _as.boosted || false;
                tuneState.boostBrightness = _as.boost_brightness || 0;

                // Update base row display in details card
                const elDetBase = document.getElementById('tune-det-base-total');
                if (elDetBase) elDetBase.textContent = tuneState.baseBri + '%';

                recalcTune();
              }
            }
            updateContent();
            renderMiniChartForArea(selectedArea.area_id);
          }
          updateAllSliders();
        } catch (err) {
          console.error('Error refreshing:', err);
        }
      }, intervalMs);
    }

    function stopRefresh() {
      if (tickInterval) { clearInterval(tickInterval); tickInterval = null; }
      if (refreshInterval) { clearInterval(refreshInterval); refreshInterval = null; }
    }

    // ============================================================
    // Navigation
    // ============================================================
    function goBack() {
      if (isTuneDirty() || isAlarmDirty()) {
        if (!confirm('You have unsaved changes. Discard and leave?')) return;
      }
      stopRefresh();
      const params = new URLSearchParams(window.location.search);
      const from = params.get('from');
      if (from === 'tune') {
        window.location.href = basePath + '/tune';
      } else {
        window.location.href = basePath + '/';
      }
    }

    // ============================================================
    // Content Updates
    // ============================================================
    function updateContent() {
      if (!selectedArea) return;
      const status = areaStatus[selectedArea.area_id] || {};

      Object.assign(selectedArea, {
        is_on: status.is_on || false,
        brightness: status.curve_brightness || status.brightness || 0,
        kelvin: status.kelvin || 4000,
        frozen: status.frozen || false,
        boosted: status.boosted || false,
        zone_name: status.zone_name || null,
        preset_name: status.preset_name || null,
        is_circadian: status.is_circadian !== false,
        boost_brightness: status.boost_brightness || null,
        boost_expires_at: status.boost_expires_at || null,
        boost_started_from_off: status.boost_started_from_off || false,
        is_motion_coupled: status.is_motion_coupled || false,
        motion_expires_at: status.motion_expires_at || null,
        motion_warning_active: status.motion_warning_active || false
      });

      // Header shading based on CCT and brightness
      const stateEl = document.getElementById('area-state');
      if (selectedArea.is_circadian === false) {
        // Circadian off: very muted neutral — don't imply off or a specific color
        stateEl.style.setProperty('--state-bg', '#1a1a1a');
        stateEl.style.setProperty('--state-fill', selectedArea.is_on ? '0.08' : '0');
      } else if (selectedArea.is_on) {
        const cctColor = cctToRGB(selectedArea.kelvin);
        const tintedColor = tintColorByBrightness(cctColor, selectedArea.brightness);
        stateEl.style.setProperty('--state-bg', tintedColor);
        stateEl.style.setProperty('--state-fill', (selectedArea.brightness / 100).toFixed(3));
      } else {
        stateEl.style.setProperty('--state-bg', 'var(--panel)');
        stateEl.style.setProperty('--state-fill', '0');
      }

      // Values display
      const valuesEl = document.getElementById('state-values');
      if (selectedArea.is_on) {
        const cctColor = cctToRGB(selectedArea.kelvin);
        const tintedColor = tintColorByBrightness(cctColor, selectedArea.brightness);
        valuesEl.style.color = readableTextColor(tintedColor);
      } else {
        valuesEl.style.color = 'var(--muted)';
      }
      valuesEl.textContent = `${Math.round(selectedArea.brightness)}% • ${Math.round(selectedArea.kelvin)}K`;

      // Header meta: zone link + "Rhythm zone" label
      const metaZone = document.getElementById('header-meta-zone');
      const metaRhythm = document.getElementById('header-meta-rhythm');
      const areaZoneName = selectedArea.zone_name;
      if (areaZoneName) {
        metaRhythm.innerHTML = `<a href="${basePath}/zone/${encodeURIComponent(areaZoneName)}?back=area/${encodeURIComponent(selectedArea.area_id)}">${areaZoneName}</a>`;
        metaRhythm.style.display = '';
        metaZone.textContent = 'zone';
        metaZone.style.display = '';
      } else {
        metaRhythm.innerHTML = '';
        metaRhythm.style.display = 'none';
        metaZone.textContent = '';
        metaZone.style.display = 'none';
      }

      // Update toggle button states
      const powerBtn = document.getElementById('toggle-power');
      const freezeBtn = document.getElementById('toggle-freeze');
      const boostBtn = document.getElementById('toggle-boost');

      if (powerBtn) powerBtn.classList.toggle('active', selectedArea.is_on);
      if (freezeBtn) freezeBtn.classList.toggle('active', selectedArea.frozen);
      if (boostBtn) boostBtn.classList.toggle('active', selectedArea.boosted);

      // Dynamic tooltips with zone/rhythm names
      const zoneName = selectedArea.zone_name;
      const fullSendBtn = document.getElementById('toggle-full-send');
      const gloUpBtn = document.getElementById('toggle-glo-up');
      const gloDownBtn = document.getElementById('toggle-glo-down');
      const gloResetBtn = document.getElementById('toggle-glo-reset');
      if (fullSendBtn) fullSendBtn.title = `Full Send --> to all areas in '${zoneName || 'Rhythm Zone'}'`;
      if (gloUpBtn) gloUpBtn.title = `GloUp: send to '${zoneName || 'Rhythm Zone'}'`;
      if (gloDownBtn) gloDownBtn.title = `GloDown: pull from '${zoneName || 'Rhythm Zone'}'`;
      if (gloResetBtn) gloResetBtn.title = `Reset Glo --> '${zoneName || 'zone'}'`;

      // Circadian-off overlay + header toggle
      const wrap = document.getElementById('circadian-content-wrap');
      const enableBtn = document.getElementById('enable-circadian-btn');
      const circToggle = document.getElementById('toggle-circadian');
      const rightBtns = document.querySelectorAll('#controls-area .toggle-btn');
      if (wrap && enableBtn) {
        if (selectedArea.is_circadian === false) {
          wrap.classList.add('circadian-off-overlay');
          enableBtn.style.display = 'flex';
          if (freezeBtn) freezeBtn.disabled = true;
          if (boostBtn) boostBtn.disabled = true;
          rightBtns.forEach(btn => btn.disabled = true);
        } else {
          wrap.classList.remove('circadian-off-overlay');
          enableBtn.style.display = 'none';
          if (freezeBtn) freezeBtn.disabled = false;
          if (boostBtn) boostBtn.disabled = false;
          rightBtns.forEach(btn => btn.disabled = false);
        }
      }
      if (circToggle) {
        circToggle.classList.toggle('active', selectedArea.is_circadian);
        circToggle.title = selectedArea.is_circadian ? 'Circadian Light: active' : 'Circadian Light: off';
      }

      updateTimerStatus();
    }


    function updateTimerStatus() {
      const el = document.getElementById('timer-status');
      if (!selectedArea) {
        el.innerHTML = '';
        return;
      }

      const parts = [];

      if (selectedArea) {
        const hasMotion = selectedArea.motion_expires_at && selectedArea.motion_expires_at !== 'forever';
        const hasBoostedMotion = selectedArea.boosted && selectedArea.is_motion_coupled;
        const warnClass = selectedArea.motion_warning_active ? ' timer-warning' : '';

        if (hasMotion && hasBoostedMotion) {
          const remaining = formatCountdown(selectedArea.motion_expires_at);
          if (remaining) {
            parts.push(`<span class="timer-motion${warnClass}">Motion +${selectedArea.boost_brightness}%: ${remaining}<span class="timer-arrow">→</span>off</span>`);
          }
        } else {
          if (hasMotion) {
            const remaining = formatCountdown(selectedArea.motion_expires_at);
            if (remaining) {
              parts.push(`<span class="timer-motion${warnClass}">Motion: ${remaining}<span class="timer-arrow">→</span>off</span>`);
            }
          }

          if (selectedArea.boosted && selectedArea.boost_brightness) {
            let text = `+${selectedArea.boost_brightness}%`;
            if (selectedArea.boost_expires_at === 'forever') {
              // No suffix — just show the boost percentage
            } else if (selectedArea.boost_expires_at === 'motion') {
              if (selectedArea.motion_expires_at) {
                const remaining = formatCountdown(selectedArea.motion_expires_at);
                if (remaining) {
                  text += ` · ${remaining}<span class="timer-arrow">→</span>circadian`;
                } else {
                  text += ' · ending';
                }
              } else {
                text += ' · until motion ends';
              }
            } else if (selectedArea.boost_expires_at) {
              const remaining = formatCountdown(selectedArea.boost_expires_at);
              if (remaining) {
                const outcome = selectedArea.boost_started_from_off ? 'off' : 'circadian';
                text += ` · ${remaining}<span class="timer-arrow">→</span>${outcome}`;
              }
            }
            parts.push(`<span class="timer-boost">Boost: ${text}</span>`);
          }
        }

        if (selectedArea.frozen) {
          parts.push(`<span class="timer-frozen">❄</span>`);
        }
      }

      el.innerHTML = parts.join('');
    }

    // ============================================================
    // Chart Rendering
    // ============================================================
    function renderMiniChartForArea(areaId) {
      const status = areaStatus[areaId] || {};
      if (!cachedConfig || !cachedSunTimes) return;

      // Use zone data as authoritative source
      const zoneName = status.zone_name;
      const zoneData = zoneName ? (cachedGlozones?.zones?.[zoneName] || {}) : {};
      let cfg = { ...cachedConfig, ...zoneData };
      cfg = resolveEffectiveCfg(cfg, zoneName, { skipOverride: true });

      const areaState = {
        brightness_mid: status.brightness_mid ?? null,
        color_mid: status.color_mid ?? null,
        color_override: status.color_override ?? null,
        frozen_at: status.frozen_at ?? null
      };

      let currentHour;
      if (status.frozen && status.frozen_at != null) {
        currentHour = status.frozen_at;
      } else {
        const now = new Date();
        currentHour = now.getHours() + now.getMinutes() / 60;
      }

      const isActive = (status.is_on || false) && (status.is_circadian !== false);
      renderMiniChart(cfg, areaState, cachedSunTimes, currentHour, isActive);
    }


    // ============================================================
    // Actions
    // ============================================================
    function toggleCircadian() {
      if (!selectedArea) return;
      const action = selectedArea.is_circadian ? 'circadian_off' : 'circadian_on';
      executeAction(action);
    }

    async function confirmFullSend() {
      if (!selectedArea) return;
      const zoneName = selectedArea.zone_name;
      if (!zoneName) { alert('This area is not in a Rhythm Zone.'); return; }

      if (cachedConfig?.confirm_zone_pushes) {
        const bri = Math.round(selectedArea.brightness);
        const kelvin = Math.round(selectedArea.kelvin);
        const affectedAreas = areas.filter(a => {
          const s = areaStatus[a.area_id] || {};
          if (s.zone_name !== zoneName || !s.is_on) return false;
          return Math.round(s.brightness || 0) !== bri || Math.round(s.kelvin || 4000) !== kelvin;
        });
        if (affectedAreas.length > 0) {
          const areaList = affectedAreas.map(a => a.name).join('\n');
          const msg = `Full Send ${bri}% / ${kelvin}K to "${zoneName}"? These areas will adjust:\n\n${areaList}`;
          if (!confirm(msg)) return;
        }
      }
      executeAction('full_send');
    }

    async function executeAction(action) {
      if (!selectedArea) return;

      try {
        const response = await fetch(basePath + '/api/area/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ area_id: selectedArea.area_id, action: action })
        });

        if (response.ok) {
          setTimeout(async () => {
            try {
              const areaId = selectedArea.area_id;
              const res = await fetch(basePath + `/api/area-status?area_id=${encodeURIComponent(areaId)}`);
              if (res.ok) {
                const singleStatus = await res.json();
                Object.assign(areaStatus, singleStatus);
              }
              updateContent();
              renderMiniChartForArea(areaId);
              updateAllSliders();
            } catch (err) {
              console.error('Error refreshing after action:', err);
            }
          }, 500);
        } else {
          const error = await response.json();
          console.error('Action failed:', error);
          alert(`Action failed: ${error.error || 'Unknown error'}`);
        }
      } catch (err) {
        console.error('Error executing action:', err);
        alert('Error executing action');
      }
    }

    async function executeSetPosition(value, mode) {
      if (!selectedArea) return;

      const payload = { area_id: selectedArea.area_id, action: 'set_position', value: value, mode: mode };

      try {
        const response = await fetch(basePath + '/api/area/action', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        if (response.ok) {
          setTimeout(async () => {
            try {
              const res = await fetch(basePath + `/api/area-status?area_id=${encodeURIComponent(selectedArea.area_id)}`);
              if (res.ok) {
                const singleStatus = await res.json();
                Object.assign(areaStatus, singleStatus);
              }
              updateContent();
              renderMiniChartForArea(selectedArea.area_id);
              updateAllSliders();
            } catch (err) {
              console.error('Error refreshing after set_position:', err);
            }
          }, 500);
        }
      } catch (err) {
        console.error('Error executing set_position:', err);
      }
    }
    // ---- Tune Section ----
    let tuneDebounceTimers = {};

    const LUMEN_STEPS = [
      { label: "Very Low",    intensity: 2.00 },
      { label: "Low",         intensity: 1.54 },
      { label: "Soft",        intensity: 1.33 },
      { label: "Gentle",      intensity: 1.14 },
      { label: "Normal",      intensity: 1.00 },
      { label: "Balanced",    intensity: 0.91 },
      { label: "Bright",      intensity: 0.80 },
      { label: "Strong",      intensity: 0.71 },
      { label: "Very Bright", intensity: 0.61 },
      { label: "Maximum",     intensity: 0.50 },
    ];

    const SOLAR_STEPS = [
      { label: "None",           exposure: 0.00 },
      { label: "Minimal",        exposure: 0.15 },
      { label: "Low",            exposure: 0.30 },
      { label: "Moderate",       exposure: 0.50 },
      { label: "Significant",    exposure: 0.70 },
      { label: "High",           exposure: 0.85 },
      { label: "Full",           exposure: 1.00 },
      { label: "Amplified",      exposure: 1.30 },
      { label: "Very amplified", exposure: 1.65 },
      { label: "Sun room",       exposure: 2.00 },
    ];

    function formatImpact(val) {
      if (val > 0) return '+' + val;
      if (val < 0) return '' + val;
      return '0';
    }

    let tuneState = {
      initialized: false,
      baseBri: 50, baseKelvin: 4000,
      sunElev: 0, outdoorNormalized: 0.0,
      outdoorSource: 'none',
      outdoorSourceEntity: null, outdoorLastUpdate: null,
      luxSmoothed: null, luxCeiling: null, luxFloor: null, weatherCondition: null,
      ctEnabled: false, ctBegin: 1650, ctEnd: 2250, ctMax: 1.4,
      brightnessSensitivity: 5.0,
      solarBreakdown: null,
      areaFactor: 1.0,
      lumenStep: 4,
      solarStep: 0,
      lights: [],
      presets: {},
      globalOffThreshold: 3,
      minBri: 1, maxBri: 100,
      areaId: null,
      areaInfo: null,
      areaName: '',
      expandedLightIdx: null,
      boosted: false,
      boostBrightness: 0,
    };

    function tunePresetMeta(presets, filterName, nowPct) {
      const preset = presets[filterName];
      if (!preset) return '';
      const atBright = preset.at_bright ?? 100;
      const atDim = preset.at_dim ?? 100;
      const offThresh = preset.off_threshold ?? 0;
      let parts = [];
      if (nowPct !== undefined) parts.push('now ' + nowPct + '%');
      parts.push('at dim ' + atDim + '%');
      parts.push('at bright ' + atBright + '%');
      if (offThresh > 0) parts.push('off &lt;' + offThresh);
      return parts.join(' &middot; ');
    }

    function showTuneSave() {
      const el = document.getElementById('tune-save-status');
      el.classList.add('visible');
      setTimeout(() => el.classList.remove('visible'), 2000);
    }

    function saveTuneAreaBrightness(areaId, fields) {
      const key = 'tune_' + areaId + JSON.stringify(fields);
      clearTimeout(tuneDebounceTimers[key]);
      tuneDebounceTimers[key] = setTimeout(async () => {
        try {
          const resp = await fetch(basePath + '/api/light-filters/area-brightness', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ area_id: areaId, ...fields })
          });
          if (resp.ok) showTuneSave();
        } catch (err) {
          console.error('Error saving tune area brightness:', err);
        }
      }, 300);
    }

    async function saveTuneLightFilter(areaId, entityId, filterName) {
      try {
        const resp = await fetch(basePath + '/api/light-filters/light-filter', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ area_id: areaId, entity_id: entityId, filter: filterName })
        });
        if (resp.ok) showTuneSave();
      } catch (err) {
        console.error('Error saving tune light filter:', err);
      }
    }

    // ---- Deferred save/cancel: snapshots + dirty tracking ----

    function captureTuneSnapshot() {
      tuneSnapshot = {
        lumenStep: tuneState.lumenStep,
        solarStep: tuneState.solarStep,
        lightFilters: {}
      };
      for (const light of tuneState.lights) {
        tuneSnapshot.lightFilters[light.entity_id] = light.filterName;
      }
    }

    function captureAlarmSnapshot() {
      alarmSnapshot = {
        enabled: document.getElementById('wake-alarm-enabled').checked,
        mode: wakeAlarmMode,
        offset: wakeAlarmOffset,
        customTime: document.getElementById('wake-custom-time')?.value || '07:00',
        days: []
      };
      document.querySelectorAll('#wake-alarm-days .wake-day-bubble.active').forEach(btn => {
        alarmSnapshot.days.push(parseInt(btn.dataset.day));
      });
      alarmSnapshot.days.sort();
    }

    function isBrightnessDirty() {
      if (!tuneSnapshot) return false;
      if (tuneState.lumenStep !== tuneSnapshot.lumenStep) return true;
      if (tuneState.solarStep !== tuneSnapshot.solarStep) return true;
      return false;
    }

    function isLightsDirty() {
      if (!tuneSnapshot) return false;
      for (const light of tuneState.lights) {
        if (light.filterName !== (tuneSnapshot.lightFilters[light.entity_id] || 'Standard')) return true;
      }
      return false;
    }

    function isTuneDirty() {
      return isBrightnessDirty() || isLightsDirty();
    }

    function isAlarmDirty() {
      if (!alarmSnapshot) return false;
      if (document.getElementById('wake-alarm-enabled').checked !== alarmSnapshot.enabled) return true;
      if (wakeAlarmMode !== alarmSnapshot.mode) return true;
      if (wakeAlarmOffset !== alarmSnapshot.offset) return true;
      if ((document.getElementById('wake-custom-time')?.value || '07:00') !== alarmSnapshot.customTime) return true;
      const currentDays = [];
      document.querySelectorAll('#wake-alarm-days .wake-day-bubble.active').forEach(btn => {
        currentDays.push(parseInt(btn.dataset.day));
      });
      currentDays.sort();
      return JSON.stringify(currentDays) !== JSON.stringify(alarmSnapshot.days);
    }

    function updateTuneButtons() {
      const briBar = document.getElementById('tune-action-bar');
      if (briBar) briBar.style.display = isBrightnessDirty() ? 'flex' : 'none';
      const lightsBar = document.getElementById('lights-action-bar');
      if (lightsBar) lightsBar.style.display = isLightsDirty() ? 'flex' : 'none';
    }

    function updateAlarmButtons() {
      const bar = document.getElementById('alarm-action-bar');
      if (bar) bar.style.display = isAlarmDirty() ? 'flex' : 'none';
    }

    async function saveBrightnessChanges() {
      const areaId = tuneState.areaId;
      if (!areaId) return;
      const factor = 1 / LUMEN_STEPS[tuneState.lumenStep].intensity;
      const exposure = SOLAR_STEPS[tuneState.solarStep].exposure;
      await fetch(basePath + '/api/light-filters/area-brightness', {
        method: 'POST', headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ area_id: areaId, brightness_factor: factor, natural_light_exposure: exposure })
      });
      captureTuneSnapshot();
      updateTuneButtons();
      showTuneSave();
    }

    async function saveLightsChanges() {
      const areaId = tuneState.areaId;
      if (!areaId) return;
      for (const light of tuneState.lights) {
        const orig = tuneSnapshot?.lightFilters[light.entity_id] || 'Standard';
        if (light.filterName !== orig) {
          await fetch(basePath + '/api/light-filters/light-filter', {
            method: 'POST', headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ area_id: areaId, entity_id: light.entity_id, filter: light.filterName })
          });
        }
      }
      captureTuneSnapshot();
      updateTuneButtons();
      showTuneSave();
    }

    async function saveAlarmChanges() {
      await saveWakeAlarmSettings();
      captureAlarmSnapshot();
      updateAlarmButtons();
    }

    function cancelBrightnessChanges() {
      if (!tuneSnapshot) return;
      tuneState.lumenStep = tuneSnapshot.lumenStep;
      tuneState.areaFactor = 1 / LUMEN_STEPS[tuneSnapshot.lumenStep].intensity;
      tuneState.solarStep = tuneSnapshot.solarStep;
      const lumenSlider = document.getElementById('tune-slider-lumen');
      if (lumenSlider) lumenSlider.value = tuneSnapshot.lumenStep;
      const solarSlider = document.getElementById('tune-slider-solar');
      if (solarSlider) solarSlider.value = tuneSnapshot.solarStep;
      recalcTune();
      updateTuneButtons();
    }

    function cancelLightsChanges() {
      if (!tuneSnapshot) return;
      for (const light of tuneState.lights) {
        const orig = tuneSnapshot.lightFilters[light.entity_id] || 'Standard';
        light.filterName = orig;
        const sel = document.querySelector(`.tune-light-select[data-light-idx="${light.idx}"]`);
        if (sel) sel.textContent = orig + ' \u25BE';
        const labelEl = document.getElementById('tune-light-preset-label-' + light.idx);
        if (labelEl) labelEl.textContent = orig;
        if (!tuneState.areaInfo.light_filters) tuneState.areaInfo.light_filters = {};
        if (orig === 'Standard') {
          delete tuneState.areaInfo.light_filters[light.entity_id];
        } else {
          tuneState.areaInfo.light_filters[light.entity_id] = orig;
        }
      }
      recalcTune();
      updateTuneButtons();
    }

    function cancelAlarmChanges() {
      if (!alarmSnapshot) return;
      document.getElementById('wake-alarm-enabled').checked = alarmSnapshot.enabled;
      wakeAlarmMode = alarmSnapshot.mode;
      setWakeAlarmModeUI(alarmSnapshot.mode);
      wakeAlarmOffset = alarmSnapshot.offset;
      document.getElementById('wake-offset-value').textContent = formatOffset(alarmSnapshot.offset);
      const customTimeEl = document.getElementById('wake-custom-time');
      if (customTimeEl) customTimeEl.value = alarmSnapshot.customTime;
      document.querySelectorAll('#wake-alarm-days .wake-day-bubble').forEach(btn => {
        const d = parseInt(btn.dataset.day);
        btn.classList.toggle('active', alarmSnapshot.days.includes(d));
      });
      showResolvedWakeTime();
      updateAlarmButtons();
    }

    function onAlarmFieldChanged() {
      showResolvedWakeTime();
      updateAlarmButtons();
    }

    // ---- Custom behaviour dropdown ----
    function closeBehaviourDropdown() {
      const existing = document.querySelector('.tune-light-dropdown');
      if (existing) existing.remove();
    }

    function openBehaviourDropdown(idx, anchorEl) {
      closeBehaviourDropdown();
      const light = tuneState.lights[idx];
      if (!light) return;
      const presets = tuneState.presets;
      const presetNames = Object.keys(presets);

      const dropdown = document.createElement('div');
      dropdown.className = 'tune-light-dropdown';

      for (const pName of presetNames) {
        const preset = presets[pName] || {};
        const atDim = preset.at_dim ?? 100;
        const atBright = preset.at_bright ?? 100;
        const offThresh = preset.off_threshold ?? tuneState.globalOffThreshold;
        const isSelected = pName === light.filterName;

        const item = document.createElement('div');
        item.className = 'tune-light-dropdown-item' + (isSelected ? ' selected' : '');
        item.innerHTML = '<div class="tune-light-dropdown-name">' + pName + '</div>'
          + '<div class="tune-light-dropdown-meta">dim ' + atDim + '% &middot; bright ' + atBright + '% &middot; off &lt;' + offThresh + '</div>';
        item.addEventListener('click', () => {
          light.filterName = pName;
          if (!tuneState.areaInfo.light_filters) tuneState.areaInfo.light_filters = {};
          if (pName === 'Standard') {
            delete tuneState.areaInfo.light_filters[light.entity_id];
          } else {
            tuneState.areaInfo.light_filters[light.entity_id] = pName;
          }
          const labelEl = document.getElementById('tune-light-preset-label-' + idx);
          if (labelEl) labelEl.textContent = pName;
          const metaEl = document.getElementById('tune-meta-' + idx);
          if (metaEl) metaEl.innerHTML = tunePresetMeta(presets, pName);
          if (anchorEl) anchorEl.textContent = pName + ' \u25BE';
          recalcTune();
          updateTuneButtons();
          closeBehaviourDropdown();
        });
        dropdown.appendChild(item);
      }

      document.body.appendChild(dropdown);

      // Position relative to anchor
      const rect = anchorEl.getBoundingClientRect();
      let left = rect.left;
      let top = rect.bottom + 4;
      if (left + dropdown.offsetWidth > window.innerWidth - 8) left = window.innerWidth - dropdown.offsetWidth - 8;
      if (top + dropdown.offsetHeight > window.innerHeight - 8) top = rect.top - dropdown.offsetHeight - 4;
      dropdown.style.left = left + 'px';
      dropdown.style.top = top + 'px';
      dropdown.style.position = 'fixed';

      // Close on outside click
      setTimeout(() => {
        const closeHandler = (e) => {
          if (!dropdown.contains(e.target) && e.target !== anchorEl) {
            closeBehaviourDropdown();
            document.removeEventListener('click', closeHandler, true);
          }
        };
        document.addEventListener('click', closeHandler, true);
      }, 0);
    }

    // ---- recalcTune: pure client-side math, reads tuneState, writes to DOM ----
    function recalcTune() {
      if (!tuneState.initialized) return;
      const ts = tuneState;

      // -- Brightness cascade --
      const baseBriPct = ts.baseBri;
      let running = baseBriPct / 100;

      // Boost (additive, matching backend)
      const boostAmount = ts.boosted ? (ts.boostBrightness || 0) : 0;
      const beforeBoost = Math.round(running * 100);
      running += boostAmount / 100;
      const afterBoost = Math.round(running * 100);
      const boostImpact = afterBoost - beforeBoost;

      // Lumen adjustment
      ts.areaFactor = 1 / LUMEN_STEPS[ts.lumenStep].intensity;
      const areaFactorPct = Math.round(ts.areaFactor * 100);
      const beforeLumen = Math.round(running * 100);
      running *= ts.areaFactor;
      const afterLumen = Math.round(running * 100);
      const lumenImpact = afterLumen - beforeLumen;

      // Solar: client-side NL factor (mirrors brain.py:calculate_natural_light_factor)
      const exposure = SOLAR_STEPS[ts.solarStep].exposure;
      let nlFactor = 1.0;
      if (exposure > 0 && ts.outdoorNormalized > 0) {
        // Apply daylight fade weight to outdoor brightness (matches brain.py)
        const fadeWeight = (ts.solarBreakdown && ts.solarBreakdown.daylight_fade_weight != null)
          ? ts.solarBreakdown.daylight_fade_weight : 1.0;
        const fadedOutdoor = ts.outdoorNormalized * fadeWeight;
        nlFactor = Math.max(0.0, 1.0 - exposure * fadedOutdoor * ts.brightnessSensitivity);
      }
      const nlFactorPct = Math.round(nlFactor * 100);
      const beforeSolar = Math.round(running * 100);
      running *= nlFactor;
      const afterSolar = Math.round(running * 100);
      const solarImpact = afterSolar - beforeSolar;

      // Color temp adjustment
      let ctFactor = 1.0;
      if (ts.ctEnabled && ts.baseKelvin != null) {
        if (ts.baseKelvin <= ts.ctBegin) ctFactor = ts.ctMax;
        else if (ts.baseKelvin < ts.ctEnd) ctFactor = 1.0 + ((ts.ctEnd - ts.baseKelvin) / (ts.ctEnd - ts.ctBegin)) * (ts.ctMax - 1.0);
      }
      const ctFactorPct = Math.round(ctFactor * 100);
      const beforeCt = Math.round(running * 100);
      running *= ctFactor;
      const afterCt = Math.round(running * 100);
      const ctImpactAbs = afterCt - beforeCt;

      // Adjusted brightness (combined)
      const adjustedBri = Math.round(running * 100);
      const netImpact = adjustedBri - baseBriPct;

      // -- Compute adjusted color temp --
      let adjustedK = ts.baseKelvin;
      const sb = ts.solarBreakdown;
      if (sb) {
        adjustedK += (sb.daylight_shift || 0);
        if (sb.warm_night_enabled) adjustedK -= (sb.night_shift || 0);
      }

      // -- Brightness card: slider word labels --
      const elLumenWord = document.getElementById('tune-lumen-word');
      if (elLumenWord) elLumenWord.textContent = LUMEN_STEPS[ts.lumenStep].label;
      const elSolarWord = document.getElementById('tune-solar-word');
      if (elSolarWord) {
        const sLabel = SOLAR_STEPS[ts.solarStep].label;
        const sExposure = SOLAR_STEPS[ts.solarStep].exposure;
        elSolarWord.textContent = sExposure > 0 ? sLabel + ' ' + sExposure.toFixed(1) : sLabel;
      }

      // -- Card 3: Lights --
      const briRange = ts.maxBri - ts.minBri;
      const curvePos = briRange > 0 ? Math.max(0, Math.min(1, (ts.baseBri - ts.minBri) / briRange)) : 0;

      for (const light of ts.lights) {
        const preset = ts.presets[light.filterName] || { at_bright: 100, at_dim: 100 };
        const atDim = preset.at_dim ?? 100;
        const atBright = preset.at_bright ?? 100;
        const offThresh = preset.off_threshold ?? ts.globalOffThreshold;
        const filterMult = (atDim + (atBright - atDim) * curvePos) / 100;
        const nowPct = Math.round(filterMult * 100);
        const rawFinal = running * 100 * filterMult;
        const isOff = rawFinal < offThresh;
        const wasCapped = rawFinal > 100;
        const finalVal = isOff ? 0 : Math.min(100, Math.round(rawFinal));

        const elBri = document.getElementById('tune-light-bri-' + light.idx);
        if (elBri) {
          elBri.className = 'tune-light-bri';
          elBri.textContent = finalVal + '%';
          elBri.style.color = (wasCapped && finalVal === 100) ? 'var(--muted)' : '';
        }
        const elImpact = document.getElementById('tune-light-impact-' + light.idx);
        if (elImpact) {
          const netImpact = finalVal - adjustedBri;
          elImpact.textContent = formatImpact(netImpact) + '%';
        }
        const elMeta = document.getElementById('tune-meta-' + light.idx);
        if (elMeta) elMeta.innerHTML = tunePresetMeta(ts.presets, light.filterName);
      }

      // -- Brightness card: cascade values --
      const elBaseBri = document.getElementById('tune-det-base-total');
      if (elBaseBri) elBaseBri.textContent = baseBriPct + '%';

      const elBoostVal = document.getElementById('tune-det-boost-val');
      if (elBoostVal) {
        elBoostVal.textContent = ts.boosted ? '+' + boostAmount + '%' : '\u2014';
      }

      const elCtVal = document.getElementById('tune-det-ct-val');
      if (elCtVal) {
        elCtVal.textContent = ts.ctEnabled ? formatImpact(ctImpactAbs) + '%' : 'disabled';
        elCtVal.style.color = ts.ctEnabled ? '' : 'var(--muted)';
      }
      const elCtDetail = document.getElementById('tune-det-ct-detail');
      const elCtDetailRow = document.getElementById('tune-ct-detail-row');
      if (elCtDetail && elCtDetailRow) {
        if (ts.ctEnabled && ts.baseKelvin != null) {
          elCtDetail.textContent = formatImpact(ctImpactAbs) + '% @ ' + ts.baseKelvin + 'K';
          elCtDetailRow.style.display = '';
        } else {
          elCtDetailRow.style.display = 'none';
        }
      }


      const elLumenImpact = document.getElementById('tune-det-lumen-val');
      if (elLumenImpact) elLumenImpact.textContent = formatImpact(lumenImpact) + '%';

      const elSolarImpact = document.getElementById('tune-det-solar-val');
      if (elSolarImpact) elSolarImpact.textContent = formatImpact(solarImpact) + '%';

      const elBriHeader = document.getElementById('tune-brightness-header-val');
      if (elBriHeader) elBriHeader.textContent = adjustedBri + '%';

      // -- Solar source info (above slider) --
      const sourceInfo = document.getElementById('tune-source-info');
      if (sourceInfo) {
        const sunIntPct = Math.round(ts.outdoorNormalized * 100);
        let timeStr = '';
        if (ts.outdoorLastUpdate) {
          const d = new Date(ts.outdoorLastUpdate * 1000);
          let h = d.getHours(), m = d.getMinutes();
          const ampm = h >= 12 ? 'p' : 'a';
          h = h % 12 || 12;
          timeStr = h + ':' + (m < 10 ? '0' : '') + m + ampm;
        }
        let status = '';
        if (ts.outdoorSource === 'lux' && ts.luxSmoothed != null) {
          status = 'lux \u00b7 ' + Math.round(ts.luxSmoothed).toLocaleString() + ' lx';
        } else if (ts.outdoorSource === 'weather' && ts.weatherCondition) {
          status = ts.weatherCondition.replace(/-/g, ' ');
        } else if (ts.outdoorSource === 'angle') {
          status = 'sun angle \u00b7 ' + (ts.sunElev ?? 0) + '\u00b0';
        }
        sourceInfo.innerHTML = sunIntPct + '%'
          + (status ? ' | ' + status : '')
          + (timeStr ? ' @ ' + timeStr : '')
          + ' <button class="tune-refresh-btn" id="tune-refresh-outdoor" title="Refresh">&#x21bb;</button>';
        const refreshBtn = document.getElementById('tune-refresh-outdoor');
        if (refreshBtn && !refreshBtn._bound) {
          refreshBtn._bound = true;
          refreshBtn.addEventListener('click', async () => {
            refreshBtn.textContent = '\u22ef';
            try {
              await fetch('./api/refresh-outdoor', { method: 'POST' });
            } catch (e) {}
            setTimeout(() => { refreshBtn.innerHTML = '&#x21bb;'; }, 1500);
          });
        }
      }

    }

    // ---- renderUnifiedTune: builds the entire tune section (4 cards) ----
    function renderUnifiedTune(filtersData, config, statusData, areaId) {
      const section = document.getElementById('area-tune-section');
      if (!filtersData || !areaId) { section.style.display = 'none'; return; }

      // Find area in zones
      let areaInfo = null;
      for (const zone of Object.values(filtersData.zones || {})) {
        const found = (zone.areas || []).find(a => a.id === areaId);
        if (found) { areaInfo = found; break; }
      }
      if (!areaInfo) { section.style.display = 'none'; return; }

      section.style.display = 'block';

      const presets = filtersData.presets || {};
      const presetNames = Object.keys(presets);
      const areaLights = (filtersData.area_lights || {})[areaId] || [];
      const lightFilters = (areaInfo && areaInfo.light_filters) || {};
      const factor = areaInfo.brightness_factor ?? 1.0;
      const storedExposure = areaInfo.natural_light_exposure ?? 0.0;

      // Find closest lumen step from stored factor
      const currentIntensity = 1 / factor;
      let lumenStep = 4;
      let closestDist = Infinity;
      for (let i = 0; i < LUMEN_STEPS.length; i++) {
        const dist = Math.abs(LUMEN_STEPS[i].intensity - currentIntensity);
        if (dist < closestDist) { closestDist = dist; lumenStep = i; }
      }

      // Find closest solar step from stored exposure
      let solarStep = 0;
      closestDist = Infinity;
      for (let i = 0; i < SOLAR_STEPS.length; i++) {
        const dist = Math.abs(SOLAR_STEPS[i].exposure - storedExposure);
        if (dist < closestDist) { closestDist = dist; solarStep = i; }
      }

      const status = areaStatus[areaId] || {};
      const liveStatus = statusData[areaId] || {};
      const baseBri = status.curve_brightness || status.brightness || 50;
      const kelvin = status.kelvin || 4000;

      // Zone min/max
      const areaZoneName = selectedArea.zone_name;
      const zoneData = areaZoneName ? (cachedGlozones?.zones?.[areaZoneName] || {}) : {};
      const minBri = zoneData.min_brightness || (cachedConfig && cachedConfig.min_brightness) || 1;
      const maxBri = zoneData.max_brightness || (cachedConfig && cachedConfig.max_brightness) || 100;

      // Build lights array for tuneState
      const sortedLights = [...areaLights].sort((a, b) => a.name.localeCompare(b.name));
      const lightsArr = sortedLights.map((l, idx) => ({
        entity_id: l.entity_id,
        name: l.name,
        filterName: lightFilters[l.entity_id] || 'Standard',
        idx: idx,
      }));

      // Populate tuneState
      Object.assign(tuneState, {
        initialized: true,
        baseBri: baseBri,
        baseKelvin: liveStatus.base_kelvin ?? kelvin,
        sunElev: liveStatus.sun_elevation ?? 0,
        outdoorNormalized: liveStatus.outdoor_normalized ?? liveStatus.sun_factor ?? 0.0,
        outdoorSource: liveStatus.outdoor_source ?? 'none',
        outdoorSourceEntity: liveStatus.outdoor_source_entity ?? null,
        outdoorLastUpdate: liveStatus.outdoor_last_update ?? null,
        luxSmoothed: liveStatus.lux_smoothed ?? null,
        luxCeiling: liveStatus.lux_ceiling ?? null,
        luxFloor: liveStatus.lux_floor ?? null,
        weatherCondition: liveStatus.weather_condition ?? null,
        ctEnabled: config.ct_comp_enabled || false,
        ctBegin: config.ct_comp_begin || 1650,
        ctEnd: config.ct_comp_end || 2250,
        ctMax: config.ct_comp_factor || 1.4,
        brightnessSensitivity: liveStatus.brightness_sensitivity ?? 5.0,
        solarBreakdown: liveStatus.solar_breakdown ?? null,
        areaFactor: 1 / LUMEN_STEPS[lumenStep].intensity,
        lumenStep: lumenStep,
        solarStep: solarStep,
        lights: lightsArr,
        presets: presets,
        globalOffThreshold: filtersData.off_threshold ?? 3,
        minBri: minBri,
        maxBri: maxBri,
        areaId: areaId,
        areaInfo: areaInfo,
        areaName: selectedArea.name || '',
        expandedLightIdx: null,
        boosted: status.boosted || false,
        boostBrightness: status.boost_brightness || 0,
      });

      // ── Card 3: Lights ──
      const lightsCard = document.getElementById('tune-lights-card');
      const lightsExpanded = localStorage.getItem('tune_lights_expanded') !== 'false';
      let lhtml = '<div class="tune-lights-header" onclick="toggleLightsBody()">';
      lhtml += '<span class="tune-lights-chevron" id="tune-lights-chevron">&#x203A;</span>';
      lhtml += '<span class="tune-lights-title">Light brightness</span>';
      lhtml += '</div>';
      lhtml += '<div class="tune-lights-body" id="tune-lights-body">';
      lhtml += '<div id="tune-lights-list">';
      if (sortedLights.length === 0) {
        lhtml += '<div style="padding:10px 14px;color:var(--muted2);font-size:0.82rem;">No lights found</div>';
      } else {
        lhtml += '<div class="tune-light-col-headers"><span></span><span>behav.</span><span>adjust</span><span>final</span></div>';
        for (const light of lightsArr) {
          const meta = tunePresetMeta(presets, light.filterName);
          const triggerHtml = '<button class="tune-light-select" data-light-idx="' + light.idx + '" onclick="openBehaviourDropdown(' + light.idx + ', this)">' + light.filterName + ' &#x25BE;</button>';

          lhtml += '<div class="tune-light-item" data-idx="' + light.idx + '">';
          lhtml += '<div class="tune-light-summary" data-idx="' + light.idx + '">'
            + '<span class="tune-light-name" title="' + light.entity_id + '">' + light.name + '</span>'
            + '<span class="tune-light-behaviour" id="tune-light-preset-label-' + light.idx + '" data-idx="' + light.idx + '">' + light.filterName + '</span>'
            + '<span class="tune-light-impact" id="tune-light-impact-' + light.idx + '"></span>'
            + '<span class="tune-light-bri" id="tune-light-bri-' + light.idx + '"></span>'
            + '</div>';
          lhtml += '<div class="tune-light-expanded" id="tune-light-exp-' + light.idx + '" style="display:none;">'
            + triggerHtml
            + '<span class="tune-light-meta" id="tune-meta-' + light.idx + '">' + meta + '</span>'
            + '</div>';
          lhtml += '</div>';
        }
      }
      lhtml += '</div>';
      lhtml += '<div class="section-action-bar" id="lights-action-bar" style="display:none;">';
      lhtml += '<button class="section-cancel-btn" onclick="cancelLightsChanges()">Cancel</button>';
      lhtml += '<button class="section-save-btn" onclick="saveLightsChanges()">Save</button>';
      lhtml += '</div>';
      lhtml += '</div>'; // close tune-lights-body
      lightsCard.innerHTML = lhtml;
      if (lightsExpanded) lightsCard.classList.add('is-open');

      // ── Brightness card (merged) ──
      const brightnessCard = document.getElementById('tune-brightness-card');
      const briExpanded = localStorage.getItem('tune_details_expanded') !== 'false';
      let bhtml = '<div class="tune-brightness-header" onclick="toggleBrightnessBody()">';
      bhtml += '<span class="tune-brightness-chevron" id="tune-brightness-chevron">&#x203A;</span>';
      bhtml += '<span class="tune-brightness-title">Area brightness</span>';
      bhtml += '<span class="tune-brightness-val" id="tune-brightness-header-val">--</span>';
      bhtml += '</div>';
      bhtml += '<div class="tune-brightness-body" id="tune-brightness-body">';
      bhtml += '<div class="tune-group-label">Adjustments</div>';
      bhtml += '<div class="tune-bk-row"><span class="tune-bk-label">Starting</span>'
        + '<span class="tune-bk-total" id="tune-det-base-total">' + baseBri + '%</span></div>';
      bhtml += '<div class="tune-bk-row"><span class="tune-bk-label">Color temp</span>'
        + '<span class="tune-bk-total" id="tune-det-ct-val"></span></div>';
      bhtml += '<div class="tune-detail-sub" id="tune-ct-detail-row"><span id="tune-det-ct-detail"></span></div>';
      // Room Balance with inline slider
      bhtml += '<div class="tune-control-row"><span class="tune-control-left"><span class="tune-control-label">Room balance</span>'
        + '<span class="tune-control-reset" id="tune-reset-lumen">reset</span></span>'
        + '<span class="tune-control-impact" id="tune-det-lumen-val"></span></div>';
      bhtml += '<div class="tune-slider-row">'
        + '<input type="range" class="tune-inline-slider tune-inline-slider--light" id="tune-slider-lumen" min="0" max="9" step="1" value="' + lumenStep + '">'
        + '<span class="tune-slider-word" id="tune-lumen-word">' + LUMEN_STEPS[lumenStep].label + '</span></div>';
      // Solar exposure with inline slider
      bhtml += '<div class="tune-control-row"><span class="tune-control-left"><span class="tune-control-label">Solar exposure</span>'
        + '<span class="tune-control-reset" id="tune-reset-solar">reset</span></span>'
        + '<span class="tune-control-impact" id="tune-det-solar-val"></span></div>';
      bhtml += '<div class="tune-source-info" id="tune-source-info"></div>';
      bhtml += '<div class="tune-slider-row">'
        + '<input type="range" class="tune-inline-slider tune-inline-slider--sun" id="tune-slider-solar" min="0" max="9" step="1" value="' + solarStep + '">'
        + '<span class="tune-slider-word" id="tune-solar-word">' + SOLAR_STEPS[solarStep].label + '</span></div>';
      // Boost row
      bhtml += '<div class="tune-bk-row"><span class="tune-bk-label">Boost</span>'
        + '<span class="tune-bk-total" id="tune-det-boost-val">\u2014</span></div>';
      bhtml += '<div class="section-action-bar" id="tune-action-bar" style="display:none;">';
      bhtml += '<button class="section-cancel-btn" onclick="cancelBrightnessChanges()">Cancel</button>';
      bhtml += '<button class="section-save-btn" onclick="saveBrightnessChanges()">Save</button>';
      bhtml += '</div>';
      bhtml += '</div>';
      brightnessCard.innerHTML = bhtml;

      // Set initial expanded state
      if (briExpanded) brightnessCard.classList.add('is-open');

      // ── Wire events ──

      // Lumen slider
      const lumenSlider = document.getElementById('tune-slider-lumen');
      if (lumenSlider) {
        lumenSlider.addEventListener('input', () => {
          sliderInteracting = true;
          tuneState.lumenStep = parseInt(lumenSlider.value);
          recalcTune();
          updateTuneButtons();
        });
        lumenSlider.addEventListener('change', () => {
          sliderInteracting = false;
          updateTuneButtons();
        });
      }

      // Solar slider
      const solarSlider = document.getElementById('tune-slider-solar');
      if (solarSlider) {
        solarSlider.addEventListener('input', () => {
          sliderInteracting = true;
          tuneState.solarStep = parseInt(solarSlider.value);
          recalcTune();
          updateTuneButtons();
        });
        solarSlider.addEventListener('change', () => {
          sliderInteracting = false;
          updateTuneButtons();
        });
      }

      // Reset lumen to last saved value
      const resetLumen = document.getElementById('tune-reset-lumen');
      if (resetLumen) {
        resetLumen.onclick = (e) => {
          e.stopPropagation();
          const savedStep = tuneSnapshot ? tuneSnapshot.lumenStep : 4;
          tuneState.lumenStep = savedStep;
          tuneState.areaFactor = 1 / LUMEN_STEPS[savedStep].intensity;
          if (lumenSlider) lumenSlider.value = savedStep;
          recalcTune();
          updateTuneButtons();
        };
      }

      // Reset solar to last saved value
      const resetSolar = document.getElementById('tune-reset-solar');
      if (resetSolar) {
        resetSolar.onclick = (e) => {
          e.stopPropagation();
          const savedStep = tuneSnapshot ? tuneSnapshot.solarStep : 0;
          tuneState.solarStep = savedStep;
          if (solarSlider) solarSlider.value = savedStep;
          recalcTune();
          updateTuneButtons();
        };
      }

      // Light accordion + preset selects
      const lightsList = document.getElementById('tune-lights-list');
      if (lightsList) {
        // Behaviour link clicks toggle expanded area
        lightsList.querySelectorAll('.tune-light-behaviour').forEach(link => {
          link.addEventListener('click', (e) => {
            e.stopPropagation();
            const idx = parseInt(link.dataset.idx);
            const wasExpanded = tuneState.expandedLightIdx === idx;
            // Collapse current
            if (tuneState.expandedLightIdx !== null) {
              const prev = document.getElementById('tune-light-exp-' + tuneState.expandedLightIdx);
              if (prev) prev.style.display = 'none';
            }
            if (wasExpanded) {
              tuneState.expandedLightIdx = null;
            } else {
              tuneState.expandedLightIdx = idx;
              const exp = document.getElementById('tune-light-exp-' + idx);
              if (exp) exp.style.display = 'block';
            }
          });
        });

      }

      // Initial calc
      recalcTune();
      captureTuneSnapshot();
    }

    async function loadTuneSection() {
      if (!selectedArea) return;
      const section = document.getElementById('area-tune-section');

      try {
        const areaId = selectedArea.area_id;
        const [filtersRes, configRes, statusRes] = await Promise.all([
          fetch(basePath + '/api/light-filters'),
          fetch(basePath + '/api/config'),
          fetch(basePath + '/api/area-status?area_id=' + encodeURIComponent(areaId))
        ]);
        if (!filtersRes.ok || !configRes.ok) { section.style.display = 'none'; return; }
        const filtersData = await filtersRes.json();
        const config = await configRes.json();
        const statusData = statusRes.ok ? await statusRes.json() : {};

        renderUnifiedTune(filtersData, config, statusData, areaId);
      } catch (err) {
        section.style.display = 'none';
        console.error('Tune section error:', err);
      }
    }

    // ============================================================
    // Wake Alarm
    // ============================================================
    let wakeAlarmOffset = 0;
    let wakeAlarmMode = 'rhythm';

    function toggleAlarmBody() {
      const card = document.querySelector('.wake-alarm-card');
      if (!card) return;
      const isOpen = card.classList.toggle('is-open');
      localStorage.setItem('wake_alarm_collapsed', isOpen ? 'false' : 'true');
      // Update override/link visibility based on expand state
      const zoneName = selectedArea?.zone_name;
      const hasOverride = !!(zoneName && cachedGlozones?.zones?.[zoneName]?.schedule_override);
      updateOverrideIndicator(hasOverride);
    }

    function toggleBrightnessBody() {
      const card = document.querySelector('.tune-brightness-card');
      if (!card) return;
      const isOpen = card.classList.toggle('is-open');
      localStorage.setItem('tune_details_expanded', isOpen ? 'true' : 'false');
    }

    function toggleLightsBody() {
      const card = document.querySelector('.tune-lights-card');
      if (!card) return;
      const isOpen = card.classList.toggle('is-open');
      localStorage.setItem('tune_lights_expanded', isOpen ? 'true' : 'false');
    }

    async function loadWakeAlarmSettings() {
      if (!selectedArea) return;
      const section = document.getElementById('wake-alarm-section');
      section.style.display = 'block';

      try {
        const res = await fetch(basePath + '/api/area-settings/' + encodeURIComponent(selectedArea.area_id));
        if (!res.ok) return;
        const settings = await res.json();

        const enabled = settings.wake_alarm || false;
        document.getElementById('wake-alarm-enabled').checked = enabled;

        // Always start alarm card closed when entering area details
        const card = document.querySelector('.wake-alarm-card');
        card?.classList.remove('is-open');

        // Days
        const days = settings.wake_alarm_days || [0, 1, 2, 3, 4, 5, 6];
        document.querySelectorAll('#wake-alarm-days .wake-day-bubble').forEach(btn => {
          const d = parseInt(btn.dataset.day);
          btn.classList.toggle('active', days.includes(d));
        });

        // Mode
        wakeAlarmMode = settings.wake_alarm_mode || 'rhythm';
        setWakeAlarmModeUI(wakeAlarmMode);

        // Offset
        wakeAlarmOffset = settings.wake_alarm_offset || 0;
        document.getElementById('wake-offset-value').textContent = formatOffset(wakeAlarmOffset);

        // Custom time
        if (settings.wake_alarm_time != null) {
          const h = Math.floor(settings.wake_alarm_time);
          const m = Math.round((settings.wake_alarm_time - h) * 60);
          document.getElementById('wake-custom-time').value =
            String(h).padStart(2, '0') + ':' + String(m).padStart(2, '0');
        }

        showResolvedWakeTime();
        captureAlarmSnapshot();

        // Fetch backend next_wake_alarm (accounts for overrides)
        fetchNextWakeAlarm();
      } catch (err) {
        console.error('Error loading wake alarm settings:', err);
      }
    }

    async function fetchNextWakeAlarm() {
      if (!selectedArea) return;
      try {
        const res = await fetch(basePath + `/api/area-status?area_id=${encodeURIComponent(selectedArea.area_id)}`);
        if (!res.ok) return;
        const data = await res.json();
        const status = data[selectedArea.area_id];
        const nextEl = document.getElementById('wake-next-alarm');
        if (!nextEl) return;
        const alarmEnabled = document.getElementById('wake-alarm-enabled')?.checked;
        if (!alarmEnabled) { nextEl.textContent = ''; updateOverrideIndicator(false); return; }
        const nwa = status?.next_wake_alarm;
        if (nwa) {
          nextEl.textContent = nwa.time + (nwa.day ? ' ' + nwa.day : '');
        } else {
          nextEl.textContent = '';
        }
        // Check for override
        const zoneName = selectedArea?.zone_name;
        const hasOverride = !!(zoneName && cachedGlozones?.zones?.[zoneName]?.schedule_override);
        updateOverrideIndicator(hasOverride);
      } catch (err) {
        // fall back to client-side display (already set by showResolvedWakeTime)
      }
    }

    function updateOverrideIndicator(hasOverride) {
      const clearEl = document.getElementById('wake-override-clear');
      const overrideLink = document.getElementById('alarm-temp-override-link');
      const bodyVisible = document.querySelector('.wake-alarm-card')?.classList.contains('is-open');
      // "clear temp override" shown in header when override exists (always visible, not just when expanded)
      if (clearEl) clearEl.style.display = hasOverride ? '' : 'none';
      // "create temp override" link shown in body when expanded and no override
      if (overrideLink) overrideLink.style.display = (!hasOverride && bodyVisible) ? '' : 'none';
    }

    async function clearOverrideFromHeader() {
      await clearTempAlarm();
      updateOverrideIndicator(false);
    }

    async function saveWakeAlarmSettings() {
      if (!selectedArea) return;

      const enabled = document.getElementById('wake-alarm-enabled').checked;

      const days = [];
      document.querySelectorAll('#wake-alarm-days .wake-day-bubble.active').forEach(btn => {
        days.push(parseInt(btn.dataset.day));
      });

      let customTime = null;
      if (wakeAlarmMode === 'custom') {
        const val = document.getElementById('wake-custom-time').value;
        if (val) {
          const [h, m] = val.split(':').map(Number);
          customTime = h + m / 60.0;
        }
      }

      const payload = {
        wake_alarm: enabled,
        wake_alarm_mode: wakeAlarmMode,
        wake_alarm_offset: wakeAlarmOffset,
        wake_alarm_time: customTime,
        wake_alarm_days: days
      };

      try {
        await fetch(basePath + '/api/area-settings/' + encodeURIComponent(selectedArea.area_id), {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload)
        });
        fetchNextWakeAlarm();
      } catch (err) {
        console.error('Error saving wake alarm settings:', err);
      }
    }

    function toggleWakeDay(btn) {
      btn.classList.toggle('active');
      showResolvedWakeTime();
      updateAlarmButtons();
    }

    function setWakeAlarmMode(mode) {
      wakeAlarmMode = mode;
      setWakeAlarmModeUI(mode);
      showResolvedWakeTime();
      updateAlarmButtons();
    }

    function setWakeAlarmModeUI(mode) {
      document.getElementById('wake-mode-rhythm').checked = (mode === 'rhythm');
      document.getElementById('wake-mode-custom').checked = (mode === 'custom');
      document.getElementById('wake-rhythm-controls').style.display = mode === 'rhythm' ? 'block' : 'none';
      document.getElementById('wake-custom-controls').style.display = mode === 'custom' ? 'block' : 'none';
    }

    function adjustWakeOffset(delta) {
      wakeAlarmOffset += delta;
      document.getElementById('wake-offset-value').textContent = formatOffset(wakeAlarmOffset);
      showResolvedWakeTime();
      updateAlarmButtons();
    }

    function formatOffset(minutes) {
      if (minutes === 0) return '0 min';
      return (minutes > 0 ? '+' : '') + minutes + ' min';
    }

    function formatAlarmTime(decimalHours) {
      // Format decimal hours to "8:15a" style — no leading zero, lowercase a/p, no space
      let h = Math.floor(((decimalHours % 24) + 24) % 24);
      const m = Math.round((decimalHours - Math.floor(decimalHours)) * 60);
      const suffix = h < 12 ? 'a' : 'p';
      if (h === 0) h = 12;
      else if (h > 12) h -= 12;
      return h + ':' + String(m).padStart(2, '0') + suffix;
    }

    function getResolvedWakeTimeForDay(pyDay) {
      // Returns resolved alarm time (decimal hours) for a given Python-weekday (Mon=0..Sun=6)
      if (wakeAlarmMode === 'custom') {
        const val = document.getElementById('wake-custom-time').value;
        if (val) {
          const [h, m] = val.split(':').map(Number);
          return h + m / 60.0;
        }
        return null;
      }
      // Rhythm mode - read from zone data
      const areaZoneName = selectedArea && selectedArea.zone_name;
      const zoneData = areaZoneName ? (cachedGlozones?.zones?.[areaZoneName] || null) : null;
      if (!zoneData) return null;

      let wakeTime = zoneData.wake_time || 7.0;
      const altTime = zoneData.wake_alt_time;
      const altDays = zoneData.wake_alt_days || [];
      if (altTime != null && altDays.includes(pyDay)) {
        wakeTime = altTime;
      }
      return wakeTime + wakeAlarmOffset / 60.0;
    }

    function showResolvedWakeTime() {
      // Get active days
      const activeDays = [];
      document.querySelectorAll('#wake-alarm-days .wake-day-bubble.active').forEach(btn => {
        activeDays.push(parseInt(btn.dataset.day));
      });

      // Update per-day time labels
      for (let d = 0; d < 7; d++) {
        const span = document.querySelector(`.wake-day-time[data-daytime="${d}"]`);
        if (!span) continue;
        if (activeDays.includes(d)) {
          const t = getResolvedWakeTimeForDay(d);
          span.textContent = t != null ? formatAlarmTime(t) : '';
        } else {
          span.textContent = '';
        }
      }

      // Compute next alarm (only shown when alarm is enabled)
      const nextEl = document.getElementById('wake-next-alarm');
      if (!nextEl) return;

      const alarmEnabled = document.getElementById('wake-alarm-enabled')?.checked;
      if (!alarmEnabled) { nextEl.textContent = ''; return; }

      const dayAbbrs = ['Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat', 'Sun'];
      const monthAbbrs = ['Jan', 'Feb', 'Mar', 'Apr', 'May', 'Jun', 'Jul', 'Aug', 'Sep', 'Oct', 'Nov', 'Dec'];
      const now = new Date();
      const jsToday = now.getDay(); // JS: Sun=0
      const pyToday = jsToday === 0 ? 6 : jsToday - 1; // Python: Mon=0
      const nowDecimal = now.getHours() + now.getMinutes() / 60.0;

      for (let i = 0; i < 14; i++) {
        const pyDay = (pyToday + i) % 7;
        if (!activeDays.includes(pyDay)) continue;
        const t = getResolvedWakeTimeForDay(pyDay);
        if (t == null) continue;
        if (i === 0 && nowDecimal >= t) continue; // today but already passed
        let dayLabel;
        if (i === 0) {
          dayLabel = 'today';
        } else if (i === 1) {
          dayLabel = 'tom (' + dayAbbrs[pyDay] + ')';
        } else if (i > 5) {
          const alarmDate = new Date(now);
          alarmDate.setDate(alarmDate.getDate() + i);
          dayLabel = dayAbbrs[pyDay] + ' (' + monthAbbrs[alarmDate.getMonth()] + ' ' + alarmDate.getDate() + ')';
        } else {
          dayLabel = dayAbbrs[pyDay];
        }
        nextEl.textContent = formatAlarmTime(t) + ' ' + dayLabel;
        return;
      }
      nextEl.textContent = '';
    }

    function formatDecimalHour(h) {
      const hrs = Math.floor(h);
      const mins = Math.round((h - hrs) * 60);
      return String(hrs).padStart(2, '0') + ':' + String(mins).padStart(2, '0');
    }

    function fmtRelativeDate(isoDateStr) {
      const DAYS = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
      const SHORT = ['Sun','Mon','Tue','Wed','Thu','Fri','Sat'];
      const MONTHS = ['Jan','Feb','Mar','Apr','May','Jun','Jul','Aug','Sep','Oct','Nov','Dec'];
      const target = new Date(isoDateStr + 'T00:00:00');
      const today = new Date(); today.setHours(0,0,0,0);
      const diff = Math.round((target - today) / 86400000);
      if (diff > 730) return '';  // "forever" override — no through text
      if (diff <= 0) return 'today (' + SHORT[target.getDay()] + ')';
      if (diff === 1) return 'tom (' + SHORT[target.getDay()] + ')';
      if (diff <= 5) return DAYS[target.getDay()];
      return DAYS[target.getDay()] + ' (' + MONTHS[target.getMonth()] + ' ' + target.getDate() + ')';
    }

    async function applyTempAlarm() {
      if (!selectedArea) return;
      const zoneName = selectedArea.zone_name;
      if (!zoneName) return;

      const mode = document.querySelector('input[name="spo-mode"]:checked')?.value;
      if (!mode) { alert('Please select an alarm option.'); return; }

      const body = {
        mode: mode,
        until_date: document.getElementById('spo-until-date').value,
        until_event: 'wake',
      };
      if (mode === 'custom') {
        body.custom_wake = parseFloat(document.getElementById('spo-custom-wake').value) % 24;
      }

      try {
        const res = await fetch(basePath + '/api/glozones/' + encodeURIComponent(zoneName) + '/schedule-override', {
          method: 'PUT',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(body),
        });
        if (res.ok) {
          const gzRes = await fetch(basePath + '/api/glozones');
          if (gzRes.ok) cachedGlozones = await gzRes.json();
          closeAreaTempOverridePopup();
          updateOverrideIndicator(true);
          fetchNextWakeAlarm();
        }
      } catch (err) {
        console.error('Error applying temp alarm:', err);
      }
    }

    function openAreaTempOverridePopup(anchorEl) {
      closeAreaTempOverridePopup();
      if (!selectedArea) return;
      const zoneName = selectedArea.zone_name;
      if (!zoneName) return;
      const zoneData = cachedGlozones?.zones?.[zoneName];
      if (!zoneData) return;

      const mainWake = zoneData.wake_time ?? 7;
      const altWake = zoneData.wake_alt_time;
      const hasAlt = altWake != null;
      const override = zoneData.schedule_override;

      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      const untilDate = tomorrow.toISOString().split('T')[0];

      const popover = document.createElement('div');
      popover.className = 'area-override-popover';
      popover.id = 'area-override-popover';
      popover.onclick = (e) => e.stopPropagation();

      if (override) {
        let desc = '';
        if (override.mode === 'main') desc = formatAlarmTime(mainWake);
        else if (override.mode === 'alt' && altWake != null) desc = formatAlarmTime(altWake);
        else if (override.mode === 'custom' && override.custom_wake != null) desc = formatAlarmTime(override.custom_wake);
        else if (override.mode === 'off') desc = 'paused';

        const throughLabel = fmtRelativeDate(override.until_date || '');
        const untilStr = throughLabel ? ' daily through ' + throughLabel : '';

        popover.innerHTML = `
          <div class="schedule-popover-title">Temp alarm override</div>
          <div class="spo-info">${desc}${untilStr}</div>
          <div class="schedule-popover-clear"><button onclick="clearTempAlarm()">Clear</button></div>
        `;
      } else {
        const wakeAltDays = zoneData.wake_alt_days || [];
        let nextIsPrimary = true;
        if (hasAlt && wakeAltDays.length > 0) {
          const now = new Date();
          const currentHour = now.getHours() + now.getMinutes() / 60;
          let checkDay = now.getDay() === 0 ? 6 : now.getDay() - 1;
          const todayAlarm = wakeAltDays.includes(checkDay) ? altWake : mainWake;
          if (currentHour >= todayAlarm) checkDay = (checkDay + 1) % 7;
          nextIsPrimary = !wakeAltDays.includes(checkDay);
        }

        let otherTimeHtml = '';
        if (hasAlt) {
          if (nextIsPrimary) {
            otherTimeHtml = `
            <div class="spo-radio-row" onclick="document.getElementById('spo-alt').checked=true">
              <input type="radio" id="spo-alt" name="spo-mode" value="alt">
              <div class="spo-time-cell">${formatAlarmTime(altWake)}</div>
            </div>`;
          } else {
            otherTimeHtml = `
            <div class="spo-radio-row" onclick="document.getElementById('spo-main').checked=true">
              <input type="radio" id="spo-main" name="spo-mode" value="main">
              <div class="spo-time-cell">${formatAlarmTime(mainWake)}</div>
            </div>`;
          }
        }

        const customWake = 12;

        popover.innerHTML = `
          <div class="schedule-popover-title">Temp alarm override</div>
          <div class="spo-grid">
            <div class="spo-radio-row" onclick="document.getElementById('spo-off').checked=true">
              <input type="radio" id="spo-off" name="spo-mode" value="off">
              <div class="spo-time-cell">pause (no alarm)</div>
            </div>
            ${otherTimeHtml}
            <div class="spo-radio-row" onclick="document.getElementById('spo-custom').checked=true">
              <input type="radio" id="spo-custom" name="spo-mode" value="custom">
              <div class="spo-time-cell" style="display:flex; align-items:center; gap:8px;">
                <span id="spo-wake-display" style="min-width:3.5em;">${formatAlarmTime(customWake)}</span>
                <input type="range" id="spo-custom-wake" min="0" max="24" step="0.25" value="${customWake}" style="flex:1; height:4px; accent-color:var(--muted);">
              </div>
            </div>
          </div>
          <div class="schedule-popover-apply-row" style="flex-direction:column; align-items:stretch;">
            <div style="padding:6px 0 2px; font-size:0.88rem;">daily through:</div>
            <div style="display:flex; flex-direction:column; gap:4px; padding:2px 0 6px; padding-left:20px;">
              <label style="display:flex; align-items:center; gap:4px; cursor:pointer; font-size:0.8rem; opacity:0.7;"><input type="radio" name="spo-through" value="today" onchange="areaPopoverThroughChanged()" style="accent-color:var(--muted);"> today</label>
              <label style="display:flex; align-items:center; gap:4px; cursor:pointer; font-size:0.8rem; opacity:0.7;"><input type="radio" name="spo-through" value="tomorrow" checked onchange="areaPopoverThroughChanged()" style="accent-color:var(--muted);"> tomorrow</label>
              <label style="display:flex; align-items:center; gap:4px; cursor:pointer; font-size:0.8rem; opacity:0.7;"><input type="radio" name="spo-through" value="forever" onchange="areaPopoverThroughChanged()" style="accent-color:var(--muted);"> forever</label>
              <label style="display:flex; align-items:center; gap:4px; cursor:pointer; font-size:0.8rem; opacity:0.7;"><input type="radio" name="spo-through" value="pick" onchange="areaPopoverThroughChanged()" style="accent-color:var(--muted);"> pick date</label>
              <input type="date" id="spo-until-date" value="${untilDate}" style="display:none; margin-top:2px; width:130px;">
            </div>
            <div style="display:flex; justify-content:flex-end; gap:8px; margin-top:8px;">
              <button onclick="closeAreaTempOverridePopup()" style="padding:6px 12px; border-radius:6px; border:1px solid var(--line); background:none; color:var(--muted); font-size:0.8rem; cursor:pointer;">Cancel</button>
              <button class="primary" onclick="applyTempAlarm()">Save</button>
            </div>
          </div>
        `;
      }

      document.body.appendChild(popover);

      // Position relative to anchor
      const rect = anchorEl.getBoundingClientRect();
      const popW = popover.offsetWidth;
      const popH = popover.offsetHeight;
      let left = rect.left + rect.width / 2 - popW / 2;
      let top = rect.bottom + 6;
      if (left < 8) left = 8;
      if (left + popW > window.innerWidth - 8) left = window.innerWidth - popW - 8;
      if (top + popH > window.innerHeight - 8) top = rect.top - popH - 6;
      popover.style.left = left + 'px';
      popover.style.top = top + 'px';

      // Wire up custom slider
      const customWakeInput = document.getElementById('spo-custom-wake');
      if (customWakeInput) {
        const wakeDisplay = document.getElementById('spo-wake-display');
        const selectCustom = () => { document.getElementById('spo-custom').checked = true; };
        customWakeInput.addEventListener('input', () => {
          selectCustom();
          wakeDisplay.textContent = formatAlarmTime(parseFloat(customWakeInput.value) % 24);
        });
        customWakeInput.addEventListener('mousedown', (e) => e.stopPropagation());
        customWakeInput.addEventListener('pointerdown', (e) => { e.stopPropagation(); selectCustom(); });
      }

      // Close on outside click
      setTimeout(() => {
        document.addEventListener('click', closeAreaTempOverridePopupOnOutsideClick);
      }, 0);
    }

    function closeAreaTempOverridePopup() {
      const existing = document.getElementById('area-override-popover');
      if (existing) existing.remove();
      document.removeEventListener('click', closeAreaTempOverridePopupOnOutsideClick);
    }

    function closeAreaTempOverridePopupOnOutsideClick(e) {
      const popover = document.getElementById('area-override-popover');
      if (popover && !popover.contains(e.target)) {
        closeAreaTempOverridePopup();
      }
    }

    function areaPopoverThroughChanged() {
      const val = document.querySelector('input[name="spo-through"]:checked')?.value;
      const datePicker = document.getElementById('spo-until-date');
      if (!datePicker) return;
      const today = new Date();
      if (val === 'today') {
        datePicker.value = today.toISOString().split('T')[0];
        datePicker.style.display = 'none';
      } else if (val === 'tomorrow') {
        today.setDate(today.getDate() + 1);
        datePicker.value = today.toISOString().split('T')[0];
        datePicker.style.display = 'none';
      } else if (val === 'forever') {
        datePicker.value = '2099-12-31';
        datePicker.style.display = 'none';
      } else {
        datePicker.style.display = '';
        setTimeout(() => { try { datePicker.showPicker(); } catch(e) {} }, 50);
      }
    }

    async function clearTempAlarm() {
      if (!selectedArea) return;
      const zoneName = selectedArea.zone_name;
      if (!zoneName) return;

      try {
        const res = await fetch(basePath + '/api/glozones/' + encodeURIComponent(zoneName) + '/schedule-override', {
          method: 'DELETE',
        });
        if (res.ok) {
          const gzRes = await fetch(basePath + '/api/glozones');
          if (gzRes.ok) cachedGlozones = await gzRes.json();
          closeAreaTempOverridePopup();
          fetchNextWakeAlarm();
        }
      } catch (err) {
        console.error('Error clearing temp alarm:', err);
      }
    }
  </script>
</body>
</html>
