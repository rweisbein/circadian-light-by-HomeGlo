<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Circadian Light - Area</title>
  <style>
    :root {
      --bg: #000;
      --panel: #111;
      --card: #1a1a1a;
      --accent: #feac60;
      --accent-hover: #ffc078;
      --text: #e2e8f0;
      --muted: #94a3b8;
      --muted2: #64748b;
      --line: #334155;
      --success: #22c55e;
      --warning: #f59e0b;
      --danger: #ef4444;
    }

    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg);
      color: var(--text);
      min-height: 100vh;
    }

    /* Page header with back button */
    .page-header {
      background: var(--panel);
      border-bottom: 1px solid var(--line);
      padding: 12px 16px;
      display: flex;
      align-items: center;
      gap: 12px;
      position: sticky;
      top: 0;
      z-index: 100;
    }

    .back-btn {
      display: flex;
      align-items: center;
      justify-content: center;
      width: 36px;
      height: 36px;
      border-radius: 8px;
      border: 1px solid var(--line);
      background: var(--card);
      color: var(--text);
      cursor: pointer;
      transition: all 0.2s;
      flex-shrink: 0;
    }

    .back-btn:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--accent);
    }

    .back-btn svg {
      width: 20px;
      height: 20px;
    }

    .page-title {
      font-size: 1.1rem;
      font-weight: 600;
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Main content */
    .main {
      max-width: 600px;
      margin: 0 auto;
      padding: 16px;
    }

    /* Context info (Glo zone + Rhythm) */
    .context-info {
      display: flex;
      gap: 20px;
      padding: 8px 0 12px;
      font-size: 0.85rem;
    }

    .context-line {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .context-label {
      color: var(--muted);
    }

    .context-link {
      color: var(--accent);
      text-decoration: none;
      transition: color 0.2s;
    }

    .context-link:hover {
      color: var(--accent-hover);
      text-decoration: underline;
    }

    /* Area state display - with dynamic shading */
    .area-state {
      --state-bg: var(--panel);
      --state-fill: 0;
      background: var(--state-bg);
      border-radius: 8px;
      padding: 16px;
      margin-bottom: 12px;
      position: relative;
      overflow: hidden;
    }

    .area-state::before {
      content: '';
      position: absolute;
      inset: 0;
      background: rgba(255,255,255,0.12);
      opacity: var(--state-fill);
      pointer-events: none;
    }

    .area-state-row {
      display: flex;
      align-items: center;
      gap: 12px;
      position: relative;
      z-index: 1;
      flex-wrap: wrap;
    }

    .area-state-info {
      flex: 1;
      min-width: 80px;
      display: flex;
      align-items: center;
    }

    .area-state-values {
      font-size: 1.4rem;
      font-weight: 500;
      display: flex;
      align-items: center;
      height: 100%;
      gap: 6px;
    }

    .area-state-controls {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
      background: rgba(0,0,0,0.5);
      padding: 6px;
      border-radius: 10px;
    }

    .zone-state-controls {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
      background: rgba(0,0,0,0.5);
      padding: 6px;
      border-radius: 10px;
    }

    .area-state-controls-left {
      display: flex;
      gap: 8px;
      flex-shrink: 0;
      background: rgba(0,0,0,0.5);
      padding: 6px;
      border-radius: 10px;
    }

    /* Toggle switch styles */
    .toggle-btn {
      width: 40px;
      height: 40px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,0.2);
      background: rgba(30,30,30,0.9);
      color: var(--muted);
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: all 0.2s;
      font-size: 1.1rem;
    }

    .toggle-btn:hover {
      border-color: rgba(255,255,255,0.4);
      background: rgba(50,50,50,0.9);
    }

    .toggle-btn.active {
      background: rgba(60,60,60,0.9);
      color: var(--text);
      border-color: var(--accent);
    }

    .toggle-btn svg {
      width: 18px;
      height: 18px;
    }

    /* Timer status row */
    .timer-status {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
      font-size: 0.8rem;
      min-height: 0;
    }

    .timer-status:empty {
      display: none;
    }

    .timer-motion {
      color: var(--muted);
      opacity: 0.7;
    }

    .timer-boost {
      color: var(--muted);
      opacity: 0.7;
      margin-left: auto;
    }

    .timer-frozen {
      color: #63b3ed;
      opacity: 0.85;
    }

    .timer-arrow {
      color: var(--muted2);
      margin: 0 3px;
    }

    .timer-warning {
      color: #e6a817;
      animation: timer-pulse 1s ease-in-out infinite;
    }

    @keyframes timer-pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.4; }
    }

    /* Mini chart container */
    #mini-chart {
      width: 100%;
      height: 280px;
      margin: 8px 0;
    }

    /* Adjust sliders */
    .adjust-section {
      margin-bottom: 12px;
      -webkit-user-select: none;
      user-select: none;
    }

    .adjust-slider-row {
      display: flex;
      align-items: stretch;
      justify-content: center;
      gap: 24px;
    }

    .slider-column {
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 4px;
    }

    .slider-label {
      font-size: 0.65rem;
      color: var(--muted);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }

    .slider-track {
      position: relative;
      width: 14px;
      height: 160px;
      background: rgba(255,255,255,0.08);
      border-radius: 7px;
      cursor: pointer;
      touch-action: none;
      overflow: hidden;
    }

    .slider-fill {
      position: absolute;
      bottom: 0;
      left: 0;
      width: 100%;
      background: var(--accent);
      pointer-events: none;
      transition: height 0.15s ease;
      border-radius: 0 0 7px 7px;
    }

    .slider-unfill {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      background: rgba(0,0,0,0.55);
      pointer-events: none;
      transition: height 0.15s ease;
      border-radius: 7px 7px 0 0;
    }

    .slider-thumb {
      position: absolute;
      left: 50%;
      width: 22px;
      height: 22px;
      border-radius: 50%;
      background: #fff;
      border: 2px solid rgba(255,255,255,0.8);
      box-shadow: 0 1px 6px rgba(0,0,0,0.4);
      transform: translate(-50%, 50%);
      pointer-events: none;
      transition: bottom 0.15s ease, background 0.15s ease;
      z-index: 2;
    }

    .slider-track.dragging .slider-fill,
    .slider-track.dragging .slider-thumb {
      transition: none;
    }

    .slider-extreme {
      font-size: 0.6rem;
      color: var(--muted);
      cursor: pointer;
      padding: 2px 0;
      letter-spacing: 0.02em;
    }

    .slider-extreme:hover {
      color: var(--text);
    }

    /* Loading state */
    .loading {
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 48px;
      color: var(--muted);
    }

    /* Mobile adjustments */
    @media (max-width: 480px) {
      .area-state-row {
        gap: 8px;
      }
      .area-state-controls-left,
      .area-state-controls,
      .zone-state-controls {
        padding: 4px;
        gap: 4px;
      }
      .toggle-btn {
        width: 36px;
        height: 36px;
      }
      .area-state-values {
        font-size: 1.2rem;
      }
      .adjust-slider-row {
        gap: 16px;
      }
      .slider-track {
        height: 140px;
      }
    }
  </style>
</head>
<body>
  <!-- Page Header -->
  <header class="page-header">
    <button class="back-btn" onclick="goBack()" title="Back">
      <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
        <polyline points="15 18 9 12 15 6"/>
      </svg>
    </button>
    <h1 class="page-title" id="page-title">Loading...</h1>
  </header>

  <main class="main">
    <div class="context-info" id="context-info">
      <div class="context-line"><span class="context-label">Glo zone:</span> <span id="zone-link">-</span></div>
      <div class="context-line" id="rhythm-line" style="display:none;"><span class="context-label">Daily Rhythm:</span> <span class="context-link" id="rhythm-link">-</span></div>
    </div>

    <div class="area-state" id="area-state">
      <div class="area-state-row">
        <div class="area-state-controls-left" id="controls-left">
          <button class="toggle-btn" id="toggle-circadian" onclick="toggleCircadian()" title="Circadian">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <circle cx="12" cy="12" r="5"/>
              <line x1="12" y1="1" x2="12" y2="3"/>
              <line x1="12" y1="21" x2="12" y2="23"/>
              <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/>
              <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/>
              <line x1="1" y1="12" x2="3" y2="12"/>
              <line x1="21" y1="12" x2="23" y2="12"/>
              <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/>
              <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/>
            </svg>
          </button>
          <button class="toggle-btn" id="toggle-power" onclick="executeAction('lights_toggle')" title="Power">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <path d="M18.36 6.64a9 9 0 1 1-12.73 0M12 2v10"/>
            </svg>
          </button>
          <button class="toggle-btn" id="toggle-freeze" onclick="executeAction('freeze_toggle')" title="Freeze">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
              <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/>
              <path d="M7 11V7a5 5 0 0 1 10 0v4"/>
            </svg>
          </button>
          <button class="toggle-btn" id="toggle-boost" onclick="executeAction('boost')" title="Boost">
            <span style="font-weight:900; font-size:16px; font-family:serif; line-height:1;">B</span>
          </button>
        </div>
        <div class="area-state-info">
          <div class="area-state-values" id="state-values">-</div>
        </div>
        <div class="area-state-controls" id="controls-area">
          <button class="toggle-btn" id="toggle-glo-up" onclick="executeAction('glo_up')" title="GloUp: send area settings to GloZone">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <polyline points="5 13 12 6 19 13"/>
              <line x1="4" y1="19" x2="20" y2="19"/>
            </svg>
          </button>
          <button class="toggle-btn" id="toggle-glo-down" onclick="executeAction('glo_down')" title="GloDown: pull GloZone settings to this area">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round">
              <line x1="4" y1="5" x2="20" y2="5"/>
              <polyline points="5 11 12 18 19 11"/>
            </svg>
          </button>
        </div>
        <div class="zone-state-controls" id="controls-zone" style="display:none;">
          <button class="toggle-btn" id="toggle-glozone-reset" onclick="executeAction('glozone_reset')" title="Reset GloZone: set GloZone to Daily Rhythm">
            <svg viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5" stroke-linecap="round" stroke-linejoin="round"><polyline points="1 4 1 10 7 10"/><path d="M3.51 15a9 9 0 1 0 2.13-9.36L1 10"/></svg>
          </button>
          <button class="toggle-btn" id="toggle-glozone-down" onclick="executeAction('glozone_down')" title="GloZone Down: push zone settings to all areas">
            <svg viewBox="0 0 16 20" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round" stroke-linejoin="round"><polyline points="3 5 8 10 13 5"/><polyline points="3 11 8 16 13 11"/></svg>
          </button>
        </div>
      </div>
    </div>

    <div class="timer-status" id="timer-status"></div>

    <div id="mini-chart"></div>

    <div class="adjust-section">
      <div class="adjust-slider-row">
        <div class="slider-column">
          <div class="slider-label">Glo</div>
          <div class="slider-extreme" onclick="executeAction('set_britelite')">BriteLite</div>
          <div class="slider-track" data-mode="step">
            <div class="slider-fill"></div>
            <div class="slider-thumb"></div>
          </div>
          <div class="slider-extreme" onclick="executeAction('set_nitelite')">NiteLite</div>
        </div>
        <div class="slider-column">
          <div class="slider-label">Bright</div>
          <div class="slider-extreme" onclick="executeSetPosition(100,'brightness')">max</div>
          <div class="slider-track" data-mode="brightness">
            <div class="slider-fill"></div>
            <div class="slider-thumb"></div>
          </div>
          <div class="slider-extreme" onclick="executeSetPosition(0,'brightness')">min</div>
        </div>
        <div class="slider-column">
          <div class="slider-label">Color</div>
          <div class="slider-extreme" onclick="executeSetPosition(100,'color')">max</div>
          <div class="slider-track" data-mode="color">
            <div class="slider-fill"></div>
            <div class="slider-thumb"></div>
          </div>
          <div class="slider-extreme" onclick="executeSetPosition(0,'color')">min</div>
        </div>
      </div>
    </div>
  </main>

  <script>
    // ============================================================
    // State
    // ============================================================
    let selectedArea = null;
    let selectedZoneName = null;
    let areaStatus = {};
    let zoneStates = {};
    let cachedConfig = null;
    let cachedSunTimes = null;
    let cachedRhythms = {};
    let areas = [];
    let refreshInterval = null;
    let tickInterval = null;
    let basePath = '';

    // ============================================================
    // Initialization
    // ============================================================
    document.addEventListener('DOMContentLoaded', async () => {
      // Compute base path for API calls (handles ingress prefix)
      const path = window.location.pathname;
      // Match /area/{id} or /zone/{name}
      const areaMatch = path.match(/^(.*)\/area\/[^/]+\/?$/);
      const zoneMatch = path.match(/^(.*)\/zone\/[^/]+\/?$/);
      if (areaMatch) {
        basePath = areaMatch[1] || '';
      } else if (zoneMatch) {
        basePath = zoneMatch[1] || '';
      }

      // Get selected area/zone from injected data
      const data = window.circadianData || {};
      const selectedAreaId = data.selectedAreaId;
      selectedZoneName = data.selectedZoneName;
      cachedConfig = data.config;

      // Fetch initial data
      await loadInitialData();

      // Determine if area or zone page
      if (selectedZoneName) {
        setupZonePage(selectedZoneName);
      } else if (selectedAreaId) {
        setupAreaPage(selectedAreaId);
      } else {
        document.getElementById('page-title').textContent = 'Not Found';
      }

      // Start refresh intervals
      startRefresh();
      initSliderHandlers();
    });

    async function loadInitialData() {
      try {
        const [statusRes, zsRes, areasRes, sunRes, rhythmsRes] = await Promise.all([
          fetch(basePath + '/api/area-status'),
          fetch(basePath + '/api/zone-states'),
          fetch(basePath + '/api/areas'),
          fetch(basePath + '/api/sun_times'),
          fetch(basePath + '/api/circadian-rhythms')
        ]);
        if (statusRes.ok) areaStatus = await statusRes.json();
        if (zsRes.ok) {
          const zs = await zsRes.json();
          zoneStates = zs.zone_states || {};
        }
        if (areasRes.ok) areas = await areasRes.json();
        if (sunRes.ok) cachedSunTimes = await sunRes.json();
        if (rhythmsRes.ok) {
          const r = await rhythmsRes.json();
          cachedRhythms = r.rhythms || {};
        }
      } catch (err) {
        console.error('Error loading initial data:', err);
      }
    }

    function setupAreaPage(areaId) {
      const area = areas.find(a => a.area_id === areaId);
      const status = areaStatus[areaId] || {};

      if (!area) {
        document.getElementById('page-title').textContent = 'Area not found';
        return;
      }

      selectedArea = {
        ...area,
        area_id: areaId,
        is_on: status.is_on || false,
        brightness: status.brightness || 0,
        kelvin: status.kelvin || 4000,
        frozen: status.frozen || false,
        boosted: status.boosted || false,
        zone_name: status.zone_name || null,
        preset_name: status.preset_name || null,
        is_circadian: status.is_circadian || false,
        boost_brightness: status.boost_brightness || null,
        boost_expires_at: status.boost_expires_at || null,
        boost_started_from_off: status.boost_started_from_off || false,
        is_motion_coupled: status.is_motion_coupled || false,
        motion_expires_at: status.motion_expires_at || null,
        motion_warning_active: status.motion_warning_active || false
      };

      document.getElementById('page-title').textContent = 'Area: ' + area.name;

      // Show area controls, hide zone controls
      document.getElementById('controls-left').style.display = 'flex';
      document.getElementById('controls-area').style.display = 'flex';
      document.getElementById('controls-zone').style.display = 'none';

      updateContent();
      setTimeout(() => renderMiniChart(), 50);
    }

    function setupZonePage(zoneName) {
      selectedZoneName = zoneName;
      document.getElementById('page-title').textContent = 'Zone: ' + zoneName;

      // Find first area in the zone as proxy
      for (const area of areas) {
        const status = areaStatus[area.area_id] || {};
        if (status.zone_name === zoneName) {
          selectedArea = {
            ...area,
            is_on: status.is_on || false,
            brightness: status.brightness || 0,
            kelvin: status.kelvin || 4000,
            frozen: status.frozen || false,
            boosted: status.boosted || false,
            zone_name: status.zone_name || null,
            preset_name: status.preset_name || null,
            is_circadian: status.is_circadian || false,
            boost_brightness: status.boost_brightness || null,
            boost_expires_at: status.boost_expires_at || null,
            boost_started_from_off: status.boost_started_from_off || false,
            is_motion_coupled: status.is_motion_coupled || false,
            motion_expires_at: status.motion_expires_at || null,
            motion_warning_active: status.motion_warning_active || false
          };
          break;
        }
      }

      // Hide area controls, show zone controls
      document.getElementById('controls-left').style.display = 'none';
      document.getElementById('controls-area').style.display = 'none';
      document.getElementById('controls-zone').style.display = 'flex';

      // Hide first context line (zone name - we're already on zone page)
      const contextLines = document.querySelectorAll('#context-info .context-line');
      if (contextLines[0]) contextLines[0].style.display = 'none';

      updateZoneContent();
      setTimeout(() => renderMiniChartForZone(), 50);
    }

    function startRefresh() {
      tickInterval = setInterval(updateTimerStatus, 1000);
      refreshInterval = setInterval(async () => {
        try {
          if (selectedZoneName) {
            const [zsRes, aRes] = await Promise.all([
              fetch(basePath + '/api/zone-states'),
              selectedArea ? fetch(basePath + `/api/area-status?area_id=${encodeURIComponent(selectedArea.area_id)}`) : Promise.resolve(null)
            ]);
            if (zsRes.ok) {
              const zs = await zsRes.json();
              zoneStates = zs.zone_states || {};
            }
            if (aRes && aRes.ok) {
              const singleStatus = await aRes.json();
              Object.assign(areaStatus, singleStatus);
            }
            updateZoneContent();
          } else if (selectedArea) {
            const res = await fetch(basePath + `/api/area-status?area_id=${encodeURIComponent(selectedArea.area_id)}`);
            if (res.ok) {
              const singleStatus = await res.json();
              Object.assign(areaStatus, singleStatus);
            }
            updateContent();
          }
        } catch (err) {
          console.error('Error refreshing:', err);
        }
      }, 1000);
    }

    function stopRefresh() {
      if (tickInterval) { clearInterval(tickInterval); tickInterval = null; }
      if (refreshInterval) { clearInterval(refreshInterval); refreshInterval = null; }
    }

    // ============================================================
    // Navigation
    // ============================================================
    function goBack() {
      stopRefresh();
      // Navigate back to home
      window.location.href = basePath + '/';
    }

    // ============================================================
    // Content Updates
    // ============================================================
    function updateContent() {
      if (!selectedArea) return;
      const status = areaStatus[selectedArea.area_id] || {};

      // Update selectedArea with latest status
      Object.assign(selectedArea, {
        is_on: status.is_on || false,
        brightness: status.brightness || 0,
        kelvin: status.kelvin || 4000,
        frozen: status.frozen || false,
        boosted: status.boosted || false,
        zone_name: status.zone_name || null,
        preset_name: status.preset_name || null,
        is_circadian: status.is_circadian || false,
        boost_brightness: status.boost_brightness || null,
        boost_expires_at: status.boost_expires_at || null,
        boost_started_from_off: status.boost_started_from_off || false,
        is_motion_coupled: status.is_motion_coupled || false,
        motion_expires_at: status.motion_expires_at || null,
        motion_warning_active: status.motion_warning_active || false
      });

      // Update header shading
      const stateEl = document.getElementById('area-state');
      if (selectedArea.is_on) {
        const cctColor = cctToRGB(selectedArea.kelvin);
        const tintedColor = tintColorByBrightness(cctColor, selectedArea.brightness);
        stateEl.style.setProperty('--state-bg', tintedColor);
        stateEl.style.setProperty('--state-fill', (selectedArea.brightness / 100).toFixed(3));
      } else {
        stateEl.style.setProperty('--state-bg', 'var(--panel)');
        stateEl.style.setProperty('--state-fill', '0');
      }

      // Values display
      const valuesEl = document.getElementById('state-values');
      if (selectedArea.is_on) {
        const cctColor = cctToRGB(selectedArea.kelvin);
        const tintedColor = tintColorByBrightness(cctColor, selectedArea.brightness);
        valuesEl.style.color = readableTextColor(tintedColor);
      } else {
        valuesEl.style.color = 'var(--muted)';
      }
      valuesEl.textContent = `${Math.round(selectedArea.brightness)}% \u2022 ${Math.round(selectedArea.kelvin)}K`;

      // Context info
      const zoneLinkEl = document.getElementById('zone-link');
      zoneLinkEl.textContent = selectedArea.zone_name || 'Unassigned';

      // Rhythm line
      const rhythmLine = document.getElementById('rhythm-line');
      const rhythmLinkEl = document.getElementById('rhythm-link');
      const areaZoneState = selectedArea.zone_name ? (zoneStates[selectedArea.zone_name] || {}) : {};
      const areaRhythmName = areaZoneState.rhythm || null;
      if (areaRhythmName) {
        rhythmLinkEl.innerHTML = `<a href="${basePath}/rhythm/${encodeURIComponent(areaRhythmName)}?back=home" style="color: var(--accent); text-decoration: none;">${areaRhythmName}</a>`;
        rhythmLine.style.display = '';
      } else {
        rhythmLine.style.display = 'none';
      }

      // Update toggle button states
      const powerBtn = document.getElementById('toggle-power');
      const circadianBtn = document.getElementById('toggle-circadian');
      const freezeBtn = document.getElementById('toggle-freeze');
      const boostBtn = document.getElementById('toggle-boost');

      if (powerBtn) powerBtn.classList.toggle('active', selectedArea.is_on);
      if (circadianBtn) circadianBtn.classList.toggle('active', selectedArea.is_circadian);
      if (freezeBtn) freezeBtn.classList.toggle('active', selectedArea.frozen);
      if (boostBtn) boostBtn.classList.toggle('active', selectedArea.boosted);

      updateTimerStatus();
    }

    function updateZoneContent() {
      if (!selectedZoneName) return;

      // Re-fetch proxy area status
      if (selectedArea) {
        const status = areaStatus[selectedArea.area_id] || {};
        Object.assign(selectedArea, {
          is_on: status.is_on || false,
          brightness: status.brightness || 0,
          kelvin: status.kelvin || 4000,
          frozen: status.frozen || false,
          boosted: status.boosted || false,
          zone_name: status.zone_name || null,
          preset_name: status.preset_name || null,
          is_circadian: status.is_circadian || false
        });
      }

      // Get zone state
      const zoneState = zoneStates[selectedZoneName] || {};
      const brightness = zoneState.brightness || (selectedArea ? selectedArea.brightness : 0);
      const kelvin = zoneState.kelvin || (selectedArea ? selectedArea.kelvin : 4000);

      // Update header shading
      const stateEl = document.getElementById('area-state');
      const cctColor = cctToRGB(kelvin);
      const tintedColor = tintColorByBrightness(cctColor, brightness);
      stateEl.style.setProperty('--state-bg', tintedColor);
      stateEl.style.setProperty('--state-fill', (brightness / 100).toFixed(3));

      // Values display
      const valuesEl = document.getElementById('state-values');
      valuesEl.style.color = readableTextColor(tintedColor);
      valuesEl.textContent = `${Math.round(brightness)}% \u2022 ${Math.round(kelvin)}K`;

      // Rhythm line
      const rhythmLine = document.getElementById('rhythm-line');
      const rhythmLinkEl = document.getElementById('rhythm-link');
      const rhythmName = zoneState.rhythm;
      if (rhythmName) {
        rhythmLinkEl.innerHTML = `<a href="${basePath}/rhythm/${encodeURIComponent(rhythmName)}?back=home" style="color: var(--accent); text-decoration: none;">${rhythmName}</a>`;
        rhythmLine.style.display = '';
      } else {
        rhythmLine.style.display = 'none';
      }

      updateTimerStatus();
    }

    function updateTimerStatus() {
      const el = document.getElementById('timer-status');
      if (!selectedArea && !selectedZoneName) {
        el.innerHTML = '';
        return;
      }

      const parts = [];

      if (selectedArea) {
        // Motion timer
        const hasMotion = selectedArea.motion_expires_at && selectedArea.motion_expires_at !== 'forever';
        if (hasMotion) {
          const expiresAt = new Date(selectedArea.motion_expires_at).getTime();
          const now = Date.now();
          const diff = expiresAt - now;
          if (diff > 0) {
            const remaining = formatDuration(diff);
            const warnClass = selectedArea.motion_warning_active ? ' timer-warning' : '';
            parts.push(`<span class="timer-motion${warnClass}">Motion +${selectedArea.boost_brightness}%: ${remaining}<span class="timer-arrow">\u2192</span>off</span>`);
          }
        }

        // Frozen indicator
        if (selectedArea.frozen && !selectedArea.boosted) {
          parts.push(`<span class="timer-frozen">Frozen</span>`);
        }

        // Boost timer
        if (selectedArea.boosted) {
          if (selectedArea.boost_expires_at === 'forever') {
            parts.push(`<span class="timer-boost">Boost: on</span>`);
          } else if (selectedArea.boost_expires_at === 'motion') {
            parts.push(`<span class="timer-boost">Boost: +motion</span>`);
          } else if (selectedArea.boost_expires_at) {
            const expiresAt = new Date(selectedArea.boost_expires_at).getTime();
            const now = Date.now();
            const diff = expiresAt - now;
            if (diff > 0) {
              const remaining = formatDuration(diff);
              const suffix = selectedArea.boost_started_from_off ? 'off' : 'on';
              parts.push(`<span class="timer-boost">Boost: ${remaining}<span class="timer-arrow">\u2192</span>${suffix}</span>`);
            }
          }
        }
      }

      el.innerHTML = parts.join(' ');
    }

    function formatDuration(ms) {
      const totalSec = Math.floor(ms / 1000);
      const min = Math.floor(totalSec / 60);
      const sec = totalSec % 60;
      if (min > 0) {
        return `${min}m ${sec}s`;
      }
      return `${sec}s`;
    }

    // ============================================================
    // Actions
    // ============================================================
    function toggleCircadian() {
      if (!selectedArea) return;
      const action = selectedArea.is_circadian ? 'circadian_off' : 'circadian_on';
      executeAction(action);
    }

    async function executeAction(action) {
      if (!selectedArea && !selectedZoneName) return;

      try {
        let response;
        if (selectedZoneName) {
          response = await fetch(basePath + '/api/zone/action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ zone_name: selectedZoneName, action: action })
          });
        } else {
          response = await fetch(basePath + '/api/area/action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ area_id: selectedArea.area_id, action: action })
          });
        }

        if (response.ok) {
          setTimeout(async () => {
            try {
              if (selectedZoneName) {
                const zsRes = await fetch(basePath + '/api/zone-states');
                if (zsRes.ok) {
                  const zs = await zsRes.json();
                  zoneStates = zs.zone_states || {};
                }
                updateZoneContent();
              } else {
                const areaId = selectedArea.area_id;
                const res = await fetch(basePath + `/api/area-status?area_id=${encodeURIComponent(areaId)}`);
                if (res.ok) {
                  const singleStatus = await res.json();
                  Object.assign(areaStatus, singleStatus);
                }
                updateContent();
              }
            } catch (err) {
              console.error('Error refreshing after action:', err);
            }
          }, 500);
        } else {
          const error = await response.json();
          console.error('Action failed:', error);
          alert(`Action failed: ${error.error || 'Unknown error'}`);
        }
      } catch (err) {
        console.error('Error executing action:', err);
        alert('Error executing action');
      }
    }

    async function executeSetPosition(percent, dimension) {
      if (!selectedArea && !selectedZoneName) return;
      try {
        let response;
        if (selectedZoneName) {
          response = await fetch(basePath + '/api/zone/action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ zone_name: selectedZoneName, action: 'set_position', percent, dimension })
          });
        } else {
          response = await fetch(basePath + '/api/area/action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ area_id: selectedArea.area_id, action: 'set_position', percent, dimension })
          });
        }
        if (response.ok) {
          setTimeout(async () => {
            if (selectedZoneName) {
              const zsRes = await fetch(basePath + '/api/zone-states');
              if (zsRes.ok) {
                const zs = await zsRes.json();
                zoneStates = zs.zone_states || {};
              }
              updateZoneContent();
            } else if (selectedArea) {
              const res = await fetch(basePath + `/api/area-status?area_id=${encodeURIComponent(selectedArea.area_id)}`);
              if (res.ok) {
                const singleStatus = await res.json();
                Object.assign(areaStatus, singleStatus);
              }
              updateContent();
            }
          }, 500);
        }
      } catch (err) {
        console.error('Error executing set_position:', err);
      }
    }

    // ============================================================
    // Slider Handlers
    // ============================================================
    function initSliderHandlers() {
      const tracks = document.querySelectorAll('.slider-track');
      tracks.forEach(track => {
        const mode = track.dataset.mode;
        let isDragging = false;

        function getPercent(e) {
          const rect = track.getBoundingClientRect();
          const clientY = e.touches ? e.touches[0].clientY : e.clientY;
          const y = clientY - rect.top;
          const pct = 1 - (y / rect.height);
          return Math.max(0, Math.min(1, pct));
        }

        function updateVisual(pct) {
          const fill = track.querySelector('.slider-fill');
          const thumb = track.querySelector('.slider-thumb');
          const heightPct = pct * 100;
          fill.style.height = heightPct + '%';
          thumb.style.bottom = heightPct + '%';
        }

        function startDrag(e) {
          e.preventDefault();
          isDragging = true;
          track.classList.add('dragging');
          const pct = getPercent(e);
          updateVisual(pct);
        }

        function moveDrag(e) {
          if (!isDragging) return;
          e.preventDefault();
          const pct = getPercent(e);
          updateVisual(pct);
        }

        function endDrag(e) {
          if (!isDragging) return;
          isDragging = false;
          track.classList.remove('dragging');
          const pct = getPercent(e.changedTouches ? e.changedTouches[0] : e);
          sendSliderAction(mode, pct);
        }

        track.addEventListener('mousedown', startDrag);
        track.addEventListener('touchstart', startDrag, { passive: false });
        document.addEventListener('mousemove', moveDrag);
        document.addEventListener('touchmove', moveDrag, { passive: false });
        document.addEventListener('mouseup', endDrag);
        document.addEventListener('touchend', endDrag);
      });
    }

    async function sendSliderAction(mode, pct) {
      if (!selectedArea && !selectedZoneName) return;
      const percent = Math.round(pct * 100);
      let action, dimension;

      if (mode === 'step') {
        action = 'set_position';
        dimension = 'step';
      } else if (mode === 'brightness') {
        action = 'set_position';
        dimension = 'brightness';
      } else if (mode === 'color') {
        action = 'set_position';
        dimension = 'color';
      } else {
        return;
      }

      try {
        let response;
        if (selectedZoneName) {
          response = await fetch(basePath + '/api/zone/action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ zone_name: selectedZoneName, action, percent, dimension })
          });
        } else {
          response = await fetch(basePath + '/api/area/action', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ area_id: selectedArea.area_id, action, percent, dimension })
          });
        }
        if (response.ok) {
          setTimeout(async () => {
            if (selectedZoneName) {
              const zsRes = await fetch(basePath + '/api/zone-states');
              if (zsRes.ok) {
                const zs = await zsRes.json();
                zoneStates = zs.zone_states || {};
              }
              updateZoneContent();
            } else if (selectedArea) {
              const res = await fetch(basePath + `/api/area-status?area_id=${encodeURIComponent(selectedArea.area_id)}`);
              if (res.ok) {
                const singleStatus = await res.json();
                Object.assign(areaStatus, singleStatus);
              }
              updateContent();
            }
          }, 500);
        }
      } catch (err) {
        console.error('Error sending slider action:', err);
      }
    }

    // ============================================================
    // Color Utilities
    // ============================================================
    function cctToRGB(kelvin) {
      const temp = kelvin / 100;
      let r, g, b;
      if (temp <= 66) {
        r = 255;
        g = temp <= 1 ? 0 : 99.4708025861 * Math.log(temp) - 161.1195681661;
        b = temp <= 19 ? 0 : 138.5177312231 * Math.log(temp - 10) - 305.0447927307;
      } else {
        r = 329.698727446 * Math.pow(temp - 60, -0.1332047592);
        g = 288.1221695283 * Math.pow(temp - 60, -0.0755148492);
        b = 255;
      }
      return `rgb(${Math.round(Math.max(0, Math.min(255, r)))}, ${Math.round(Math.max(0, Math.min(255, g)))}, ${Math.round(Math.max(0, Math.min(255, b)))})`;
    }

    function tintColorByBrightness(rgbStr, brightness) {
      const match = rgbStr.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
      if (!match) return rgbStr;
      let [, r, g, b] = match.map(Number);
      const factor = 0.08 + (brightness / 100) * 0.25;
      r = Math.round(r * factor);
      g = Math.round(g * factor);
      b = Math.round(b * factor);
      return `rgb(${r}, ${g}, ${b})`;
    }

    function readableTextColor(rgbStr) {
      const match = rgbStr.match(/rgb\((\d+),\s*(\d+),\s*(\d+)\)/);
      if (!match) return 'var(--text)';
      const [, r, g, b] = match.map(Number);
      const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
      return luminance > 0.35 ? '#1a1a1a' : '#e2e8f0';
    }

    // ============================================================
    // Mini Chart Rendering
    // ============================================================
    const SPEED_TO_SLOPE = [0, 0.4, 0.6, 0.8, 1.0, 1.3, 1.7, 2.3, 3.0, 4.0, 5.5];

    function logistic(x, midpoint, slope, y0, y1) {
      try {
        const expVal = Math.exp(-slope * (x - midpoint));
        return y0 + (y1 - y0) / (1 + expVal);
      } catch {
        return slope * (x - midpoint) > 0 ? y1 : y0;
      }
    }

    function wrap24(x) {
      return ((x % 24) + 24) % 24;
    }

    function signedDist(from, to) {
      let d = to - from;
      if (d > 12) d -= 24;
      if (d < -12) d += 24;
      return d;
    }

    function computeMiniChartData(cfg) {
      const ascendStart = cfg.ascend_start ?? 6;
      const descendStart = cfg.descend_start ?? 18;
      const minBri = cfg.min_brightness ?? 5;
      const maxBri = cfg.max_brightness ?? 100;
      const minCT = cfg.min_ct ?? 2200;
      const maxCT = cfg.max_ct ?? 5500;
      const ascendSpeed = cfg.ascend_speed ?? 5;
      const descendSpeed = cfg.descend_speed ?? 5;
      const ascendSlope = SPEED_TO_SLOPE[ascendSpeed] || 1.0;
      const descendSlope = SPEED_TO_SLOPE[descendSpeed] || 1.0;

      const ascendMid = wrap24(ascendStart + 3);
      const descendMid = wrap24(descendStart + 3);

      const points = [];
      for (let i = 0; i <= 288; i++) {
        const hour = (i / 288) * 24;
        const dAscend = signedDist(ascendMid, hour);
        const dDescend = signedDist(descendMid, hour);

        let bri, ct;
        if (Math.abs(dAscend) <= 6) {
          bri = logistic(dAscend, 0, ascendSlope, minBri, maxBri);
          ct = logistic(dAscend, 0, ascendSlope, minCT, maxCT);
        } else if (Math.abs(dDescend) <= 6) {
          bri = logistic(dDescend, 0, descendSlope, maxBri, minBri);
          ct = logistic(dDescend, 0, descendSlope, maxCT, minCT);
        } else {
          const midAscend = wrap24(ascendMid);
          const midDescend = wrap24(descendMid);
          const distToAsc = Math.abs(signedDist(hour, midAscend));
          const distToDesc = Math.abs(signedDist(hour, midDescend));
          if (distToAsc > distToDesc) {
            bri = minBri; ct = minCT;
          } else {
            bri = maxBri; ct = maxCT;
          }
        }
        points.push({ hour, bri, ct });
      }
      return points;
    }

    function renderMiniChart() {
      if (!selectedArea || !cachedConfig) return;
      const status = areaStatus[selectedArea.area_id] || {};
      const rhythmName = status.preset_name;
      let cfg;
      if (rhythmName && cachedRhythms[rhythmName]) {
        cfg = { ...cachedConfig, ...cachedRhythms[rhythmName] };
      } else {
        cfg = cachedConfig;
      }
      drawMiniChart(cfg);
    }

    function renderMiniChartForZone() {
      if (!selectedZoneName || !cachedConfig) return;
      const zoneState = zoneStates[selectedZoneName] || {};
      const rhythmName = zoneState.rhythm;
      let cfg;
      if (rhythmName && cachedRhythms[rhythmName]) {
        cfg = { ...cachedConfig, ...cachedRhythms[rhythmName] };
      } else {
        cfg = cachedConfig;
      }
      drawMiniChart(cfg);
    }

    function drawMiniChart(cfg) {
      const container = document.getElementById('mini-chart');
      if (!container) return;

      const width = container.clientWidth || 400;
      const height = container.clientHeight || 280;
      const margin = { top: 10, right: 16, bottom: 20, left: 16 };
      const chartW = width - margin.left - margin.right;
      const chartH = height - margin.top - margin.bottom;

      const points = computeMiniChartData(cfg);
      const minBri = cfg.min_brightness ?? 5;
      const maxBri = cfg.max_brightness ?? 100;
      const minCT = cfg.min_ct ?? 2200;
      const maxCT = cfg.max_ct ?? 5500;

      // Get current hour
      const now = new Date();
      const cursorHour = now.getHours() + now.getMinutes() / 60;

      // Sun times for markers
      const sunrise = cachedSunTimes?.sunrise ?? 6;
      const sunset = cachedSunTimes?.sunset ?? 18;

      let svg = `<svg viewBox="0 0 ${width} ${height}" style="width:100%;height:100%;">`;

      // Grid lines
      for (let h = 0; h <= 24; h += 6) {
        const x = margin.left + (h / 24) * chartW;
        svg += `<line x1="${x}" y1="${margin.top}" x2="${x}" y2="${height - margin.bottom}" stroke="#333" stroke-width="1"/>`;
        svg += `<text x="${x}" y="${height - 4}" text-anchor="middle" fill="#666" font-size="10">${h === 24 ? 0 : h}</text>`;
      }

      // Brightness area
      let briPath = `M ${margin.left} ${height - margin.bottom}`;
      points.forEach(p => {
        const x = margin.left + (p.hour / 24) * chartW;
        const y = margin.top + chartH - ((p.bri - minBri) / (maxBri - minBri)) * chartH;
        briPath += ` L ${x} ${y}`;
      });
      briPath += ` L ${width - margin.right} ${height - margin.bottom} Z`;
      svg += `<path d="${briPath}" fill="rgba(254,172,96,0.2)" stroke="none"/>`;

      // Brightness line
      let briLine = '';
      points.forEach((p, i) => {
        const x = margin.left + (p.hour / 24) * chartW;
        const y = margin.top + chartH - ((p.bri - minBri) / (maxBri - minBri)) * chartH;
        briLine += (i === 0 ? 'M' : 'L') + ` ${x} ${y}`;
      });
      svg += `<path d="${briLine}" fill="none" stroke="var(--accent)" stroke-width="2"/>`;

      // CT line (color gradient)
      let ctLine = '';
      points.forEach((p, i) => {
        const x = margin.left + (p.hour / 24) * chartW;
        const y = margin.top + chartH - ((p.ct - minCT) / (maxCT - minCT)) * chartH;
        ctLine += (i === 0 ? 'M' : 'L') + ` ${x} ${y}`;
      });
      svg += `<path d="${ctLine}" fill="none" stroke="#63b3ed" stroke-width="1.5" stroke-dasharray="4,2"/>`;

      // Sun markers
      const sunriseX = margin.left + (sunrise / 24) * chartW;
      const sunsetX = margin.left + (sunset / 24) * chartW;
      svg += `<circle cx="${sunriseX}" cy="${height - margin.bottom - 6}" r="4" fill="#fbbf24"/>`;
      svg += `<circle cx="${sunsetX}" cy="${height - margin.bottom - 6}" r="4" fill="#f97316"/>`;

      // Current time cursor
      const cursorX = margin.left + (cursorHour / 24) * chartW;
      svg += `<line x1="${cursorX}" y1="${margin.top}" x2="${cursorX}" y2="${height - margin.bottom}" stroke="var(--text)" stroke-width="1.5" stroke-dasharray="3,3"/>`;

      // Current values dot
      const cursorPoint = points[Math.round((cursorHour / 24) * 288)] || points[0];
      const dotY = margin.top + chartH - ((cursorPoint.bri - minBri) / (maxBri - minBri)) * chartH;
      svg += `<circle cx="${cursorX}" cy="${dotY}" r="5" fill="var(--accent)" stroke="white" stroke-width="2"/>`;

      svg += '</svg>';
      container.innerHTML = svg;
    }
  </script>
</body>
</html>
